[
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "218-218",
    "vulnerableCode": [
      "verification[_acc].verificationAddedOn = verificationAddedOn[_acc] = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.19;\n2: \n3:  \n4: \n5: contract CryptonomicaVerification {\n6: \n7:  "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "145-145",
    "vulnerableCode": [
      "require(_endTimeOfBids > now);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract DutchAuction {\n2:     \n3: \t \n4:      \n5:     uint constant public TOKEN_CLAI"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "230-230",
    "vulnerableCode": [
      "require(now > finalizedTime + TOKEN_CLAIM_WAITING_PERIOD);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract DutchAuction {\n2:     \n3: \t \n4:      \n5:     uint constant public TOKEN_CLAI"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "207-207",
    "vulnerableCode": [
      "BidSubmission(msg.sender, msg.value, missingFunds,block.timestamp);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract DutchAuction {\n2:     \n3: \t \n4:      \n5:     uint constant public TOKEN_CLAI"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "60-67",
    "vulnerableCode": [
      "mapping(address => uint) balances_34;",
      "",
      "function transfer_34(address _to, uint _value) public returns (bool) {",
      "    require(balances_34[msg.sender] - _value >= 0);  ",
      "    balances_34[msg.sender] -= _value;  ",
      "    balances_34[_to] += _value;  ",
      "    return true;",
      "  }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() ext"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "81-90",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_21;",
      "",
      "function increaseLockTime_21(uint _secondsToIncrease) public {",
      "        lockTime_21[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_21() public {",
      "        require(now > lockTime_21[msg.sender]);    ",
      "        uint transferValue_21 = 10;           ",
      "        msg.sender.transfer(transferValue_21);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() ext"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "106-113",
    "vulnerableCode": [
      "mapping(address => uint) balances_10;",
      "",
      "function transfer_10(address _to, uint _value) public returns (bool) {",
      "    require(balances_10[msg.sender] - _value >= 0);  ",
      "    balances_10[msg.sender] -= _value;  ",
      "    balances_10[_to] += _value;  ",
      "    return true;",
      "  }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() ext"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "151-157",
    "vulnerableCode": [
      "mapping(address => uint) balances_18;",
      "",
      "function transfer_18(address _to, uint _value) public returns (bool) {",
      "    require(balances_18[msg.sender] - _value >= 0);  ",
      "    balances_18[msg.sender] -= _value;  ",
      "    balances_18[_to] += _value;  ",
      "    return true;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() ext"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "160-169",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_29;",
      "",
      "function increaseLockTime_29(uint _secondsToIncrease) public {",
      "        lockTime_29[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_29() public {",
      "        require(now > lockTime_29[msg.sender]);    ",
      "        uint transferValue_29 = 10;           ",
      "        msg.sender.transfer(transferValue_29);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() ext"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "171-177",
    "vulnerableCode": [
      "mapping(address => uint) balances_6;",
      "",
      "function transfer_62(address _to, uint _value) public returns (bool) {",
      "    require(balances_6[msg.sender] - _value >= 0);  ",
      "    balances_6[msg.sender] -= _value;  ",
      "    balances_6[_to] += _value;  ",
      "    return true;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() ext"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "190-199",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_5;",
      "",
      "function increaseLockTime_5(uint _secondsToIncrease) public {",
      "        lockTime_5[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_5() public {",
      "        require(now > lockTime_5[msg.sender]);    ",
      "        uint transferValue_5 = 10;           ",
      "        msg.sender.transfer(transferValue_5);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() ext"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "201-210",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_33;",
      "",
      "function increaseLockTime_33(uint _secondsToIncrease) public {",
      "        lockTime_33[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_33() public {",
      "        require(now > lockTime_33[msg.sender]);    ",
      "        uint transferValue_33 = 10;           ",
      "        msg.sender.transfer(transferValue_33);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() ext"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "222-231",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_13;",
      "",
      "function increaseLockTime_13(uint _secondsToIncrease) public {",
      "        lockTime_13[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_13() public {",
      "        require(now > lockTime_13[msg.sender]);    ",
      "        uint transferValue_13 = 10;           ",
      "        msg.sender.transfer(transferValue_13);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() ext"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "313-317",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_9;",
      "",
      "function increaseLockTime_9(uint _secondsToIncrease) public {",
      "        lockTime_9[msg.sender] += _secondsToIncrease;  ",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() ext"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "511-517",
    "vulnerableCode": [
      "mapping(address => uint) balances_14;",
      "",
      "function transfer_14(address _to, uint _value) public returns (bool) {",
      "    require(balances_14[msg.sender] - _value >= 0);  ",
      "    balances_14[msg.sender] -= _value;  ",
      "    balances_14[_to] += _value;  ",
      "    return true;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() ext"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "525-531",
    "vulnerableCode": [
      "mapping(address => uint) balances_30;",
      "",
      "function transfer_30(address _to, uint _value) public returns (bool) {",
      "    require(balances_30[msg.sender] - _value >= 0);  ",
      "    balances_30[msg.sender] -= _value;  ",
      "    balances_30[_to] += _value;  ",
      "    return true;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() ext"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1385-1402",
    "vulnerableCode": [
      "if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256(\"deposit()\"))))",
      "{",
      "_p3d = _p3d.add(_com);",
      "_com = 0;",
      "}"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1517-1550",
    "vulnerableCode": [
      "if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256(\"deposit()\"))))",
      "{",
      "_p3d = _com;",
      "_com = 0;",
      "}"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1402-1402",
    "vulnerableCode": [
      "Divies.deposit.value(_p3d)();"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "59-60",
    "vulnerableCode": [
      "startTime = block.timestamp;",
      "endTime = startTime + 365 days;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract XTVToken is XTVNetworkGuard, ERC20Token {\n2:   using SafeMath for uint256;\n3"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "214-220",
    "vulnerableCode": [
      "mapping(address => uint) balances_3;",
      "function withdrawFunds_3 (uint256 _weiToWithdraw) public {",
      "        require(balances_3[msg.sender] >= _weiToWithdraw);",
      "    (bool success,)= msg.sender.call.value(_weiToWithdraw)(\"\");",
      "        require(success);  ",
      "        balances_3[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  mapping(address => uint) balances_15"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "265-270",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_25;",
      "function claimReward_25() public {        ",
      "        require(redeemableEther_25[msg.sender] > 0);",
      "        uint transferValue_25 = redeemableEther_25[msg.sender];",
      "        msg.sender.transfer(transferValue_25);   ",
      "        redeemableEther_25[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  mapping(address => uint) balances_15"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "276-281",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_19;",
      "function withdrawBalance_19() public{",
      "        if( ! (msg.sender.send(userBalance_19[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalance_19[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  mapping(address => uint) balances_15"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "287-293",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_26;",
      "function withdrawBalance_26() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_26[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_26[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  mapping(address => uint) balances_15"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "301-305",
    "vulnerableCode": [
      "  mapping(address => uint) balances_31;",
      "function withdrawFunds_31 (uint256 _weiToWithdraw) public {",
      "        require(balances_31[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_31[msg.sender] -= _weiToWithdraw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  mapping(address => uint) balances_15"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "309-316",
    "vulnerableCode": [
      "  bool callcount_13 = true;",
      "function userbalances_13() public{",
      "        require(callcount_13);",
      "        (bool success,)=msg.sender.call.value(1 ether)(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        callcount_13 = false;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  mapping(address => uint) balances_15"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "330-336",
    "vulnerableCode": [
      "bool callcount_20 = true;",
      "function userbalances_20() public{",
      "        require(callcount_20);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcount_20 = false;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  mapping(address => uint) balances_15"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "344-349",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_32;",
      "function claimReward_32() public {        ",
      "        require(redeemableEther_32[msg.sender] > 0);",
      "        uint transferValue_32 = redeemableEther_32[msg.sender];",
      "        msg.sender.transfer(transferValue_32);   ",
      "        redeemableEther_32[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  mapping(address => uint) balances_15"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "355-359",
    "vulnerableCode": [
      "mapping(address => uint) balances_38;",
      "function withdrawFunds_38 (uint256 _weiToWithdraw) public {",
      "        require(balances_38[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_38[msg.sender] -= _weiToWithdraw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  mapping(address => uint) balances_15"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "366-371",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_4;",
      "function claimReward_4() public {        ",
      "        require(redeemableEther_4[msg.sender] > 0);",
      "        uint transferValue_4 = redeemableEther_4[msg.sender];",
      "        msg.sender.transfer(transferValue_4);   ",
      "        redeemableEther_4[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  mapping(address => uint) balances_15"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "378-385",
    "vulnerableCode": [
      "uint256 counter_7 =0;",
      "function callcheck_7() public{",
      "        require(counter_7<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_7 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  mapping(address => uint) balances_15"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "393-400",
    "vulnerableCode": [
      "address payable lastPlayer_23;",
      "      uint jackpot_23;",
      "      function buyTicket_23() public{",
      "        if (!(lastPlayer_23.send(jackpot_23)))",
      "        revert();",
      "      lastPlayer_23 = msg.sender;",
      "      jackpot_23    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  mapping(address => uint) balances_15"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "406-413",
    "vulnerableCode": [
      "uint256 counter_14 =0;",
      "function callcheck_14() public{",
      "        require(counter_14<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_14 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  mapping(address => uint) balances_15"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "419-426",
    "vulnerableCode": [
      "address payable lastPlayer_30;",
      "      uint jackpot_30;",
      "      function buyTicket_30() public{",
      "        if (!(lastPlayer_30.send(jackpot_30)))",
      "        revert();",
      "      lastPlayer_30 = msg.sender;",
      "      jackpot_30    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  mapping(address => uint) balances_15"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "433-438",
    "vulnerableCode": [
      "mapping(address => uint) balances_8;",
      "    function withdraw_balances_8 () public {",
      "       (bool success,) = msg.sender.call.value(balances_8[msg.sender ])(\"\");",
      "       if (success)",
      "          balances_8[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  mapping(address => uint) balances_15"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "444-450",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_39;",
      "function claimReward_39() public {        ",
      "        require(redeemableEther_39[msg.sender] > 0);",
      "        uint transferValue_39 = redeemableEther_39[msg.sender];",
      "        msg.sender.transfer(transferValue_39);   ",
      "        redeemableEther_39[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  mapping(address => uint) balances_15"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "456-460",
    "vulnerableCode": [
      "mapping(address => uint) balances_36;",
      "    function withdraw_balances_36 () public {",
      "       if (msg.sender.send(balances_36[msg.sender ]))",
      "          balances_36[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  mapping(address => uint) balances_15"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "473-480",
    "vulnerableCode": [
      "uint256 counter_35 =0;",
      "function callcheck_35() public{",
      "        require(counter_35<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_35 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  mapping(address => uint) balances_15"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "502-509",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_33;",
      "function withdrawBalance_33() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_33[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_33[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  mapping(address => uint) balances_15"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "289-289",
    "vulnerableCode": [
      "_customerAddress.transfer(_dividends);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.21;\n2: \n3: \n4: contract DailyDivs {\n5:     \n6: \n7: \n8:     \n9:     modifier"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "216-218",
    "vulnerableCode": [
      "if (txn.destination.call.value(txn.value)(txn.data)){"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity 0.4.15;\n2: \n3: \n4: \n5: \n6: contract MultiSigWallet {\n7: \n8:     uint constant pu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "415-415",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F5D is modularShort {\n4:     using SafeMath for *;\n5:  "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "484-484",
    "vulnerableCode": [
      "(bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F5D is modularShort {\n4:     using SafeMath for *;\n5:  "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "499-499",
    "vulnerableCode": [
      "(bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F5D is modularShort {\n4:     using SafeMath for *;\n5:  "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "515-515",
    "vulnerableCode": [
      "(bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F5D is modularShort {\n4:     using SafeMath for *;\n5:  "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1254-1254",
    "vulnerableCode": [
      "if (!address(coin_base).call.value(_com)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F5D is modularShort {\n4:     using SafeMath for *;\n5:  "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1286-1286",
    "vulnerableCode": [
      "coin_base.transfer(_p3d.sub(_potAmount));"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F5D is modularShort {\n4:     using SafeMath for *;\n5:  "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "48-57",
    "vulnerableCode": [
      "    mapping(address => uint) public lockTime_test1;",
      "",
      "    function increaseLockTime_test1(uint _secondsToIncrease) public {",
      "            lockTime_test1[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "    function withdraw_test1() public {",
      "            require(now > lockTime_test1[msg.sender]);    ",
      "            uint transferValue_test1 = 10;           ",
      "            msg.sender.transfer(transferValue_test1);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 publ"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "63-70",
    "vulnerableCode": [
      "    mapping(address => uint) balances_test3;",
      "",
      "    function transfer_test3(address _to, uint _value) public returns (bool) {",
      "        require(balances_test3[msg.sender] - _value >= 0);  ",
      "        balances_test3[msg.sender] -= _value;  ",
      "        balances_test3[_to] += _value;  ",
      "        return true;",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 publ"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "82-89",
    "vulnerableCode": [
      "    mapping(address => uint) balances_test4;",
      "",
      "    function transfer_test4(address _to, uint _value) public returns (bool) {",
      "        require(balances_test4[msg.sender] - _value >= 0);  ",
      "        balances_test4[msg.sender] -= _value;  ",
      "        balances_test4[_to] += _value;  ",
      "        return true;",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 publ"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "150-159",
    "vulnerableCode": [
      "    mapping(address => uint) public lockTime_test2;",
      "",
      "    function increaseLockTime_test2(uint _secondsToIncrease) public {",
      "            lockTime_test2[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "    function withdraw_test2() public {",
      "            require(now > lockTime_test2[msg.sender]);    ",
      "            uint transferValue_test2 = 10;           ",
      "            msg.sender.transfer(transferValue_test2);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 publ"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "47-47",
    "vulnerableCode": [
      "if (tx.destination.call.value(tx.value)(tx.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract MultiSigWalletWithDailyLimit is MultiSigWallet {\n2: \n3:     event DailyLimitChange(uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "22-23",
    "vulnerableCode": [
      "            msg.sender.call.value(_am);",
      "            Bal[msg.sender]-=_am;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract SIMPLE_PIGGY_BANK\n2: {\n3:     address creator = msg.sender;\n4:     \n5:     mapping (add"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "494-494",
    "vulnerableCode": [
      "require(block.timestamp > crowdSaleEndTime);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.19;\n2: \n3: \n4:  \n5: contract Ownable {\n6:   address public owner"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "107-107",
    "vulnerableCode": [
      "_bankroller.call.value(_amount)(_sig);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.23;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: interface IRegistry "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "123-123",
    "vulnerableCode": [
      "_tr.call.value(_profits)();"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.23;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: interface IRegistry "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "33-33",
    "vulnerableCode": [
      "require(block.timestamp >= releaseTime);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract MOEToken is ERC20 {\n2: \n3:     using SafeMath for uint256;\n4: \n5:     addres"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "2-4",
    "vulnerableCode": [
      "uint8 public total = 0;",
      "total += value;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract SimpleAdder {\n2:  uint8 public total = 0;\n3:  function add(uint8 value) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "88-91",
    "vulnerableCode": [
      "            if(_addr.call.value(_wei)())",
      "            {",
      "                Holders[_addr]-=_wei;",
      "            }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.19;\n2: \n3: contract Ownable\n4: {\n5:     address newOwner;\n6:     address ow"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "46-46",
    "vulnerableCode": [
      "  uint256 paymentValueIssue3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 public t"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "48-48",
    "vulnerableCode": [
      "  uint256 paymentValueIssue4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 public t"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "54-58",
    "vulnerableCode": [
      "  address winnerTimeStamp7;",
      "function playTimeStamp7(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winnerTimeStamp7 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 public t"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "60-64",
    "vulnerableCode": [
      "  address winnerTimeStamp23;",
      "function playTimeStamp23(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winnerTimeStamp23 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 public t"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "66-69",
    "vulnerableCode": [
      "  address winnerTimeStamp14;",
      "function playTimeStamp14(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerTimeStamp14 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 public t"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "71-74",
    "vulnerableCode": [
      "  address winnerTimeStamp30;",
      "function playTimeStamp30(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerTimeStamp30 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 public t"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "94-98",
    "vulnerableCode": [
      "address winnerTimeStamp27;",
      "function playTimeStamp27(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winnerTimeStamp27 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 public t"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "107-111",
    "vulnerableCode": [
      "address winnerTimeStamp31;",
      "function playTimeStamp31(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winnerTimeStamp31 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 public t"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "131-131",
    "vulnerableCode": [
      "uint256 paymentValueIssue5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 public t"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "138-138",
    "vulnerableCode": [
      "uint256 paymentValueIssue1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 public t"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "143-143",
    "vulnerableCode": [
      "uint256 paymentValueIssue2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 public t"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "63-70",
    "vulnerableCode": [
      "  bool callcount_6 = true;",
      "function userbalances_6() public{",
      "        require(callcount_6);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcount_6 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "72-79",
    "vulnerableCode": [
      "  address payable lastPlayer_16;",
      "      uint jackpot_16;",
      "      function buyTicket_16() public{",
      "        if (!(lastPlayer_16.send(jackpot_16)))",
      "        revert();",
      "      lastPlayer_16 = msg.sender;",
      "      jackpot_16    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "81-86",
    "vulnerableCode": [
      "  mapping(address => uint) balances_24;",
      "function withdrawFunds_24 (uint256 _weiToWithdraw) public {",
      "        require(balances_24[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_24[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "89-95",
    "vulnerableCode": [
      "  mapping(address => uint) userBalance_5;",
      "function withdrawBalance_5() public{",
      "        if( ! (msg.sender.send(userBalance_5[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalance_5[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "97-101",
    "vulnerableCode": [
      "  mapping(address => uint) balances_15;",
      "    function withdraw_balances_15 () public {",
      "       if (msg.sender.send(balances_15[msg.sender ]))",
      "          balances_15[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "104-111",
    "vulnerableCode": [
      "  uint256 counter_28 =0;",
      "function callcheck_28() public{",
      "        require(counter_28<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_28 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "135-142",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_26;",
      "function withdrawBalance_26() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_26[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_26[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "148-155",
    "vulnerableCode": [
      "bool callcount_20 = true;",
      "function userbalances_20() public{",
      "        require(callcount_20);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcount_20 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "166-172",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_32;",
      "function claimReward_32() public {        ",
      "        require(redeemableEther_32[msg.sender] > 0);",
      "        uint transferValue_32 = redeemableEther_32[msg.sender];",
      "        msg.sender.transfer(transferValue_32);   ",
      "        redeemableEther_32[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "186-191",
    "vulnerableCode": [
      "mapping(address => uint) balances_38;",
      "function withdrawFunds_38 (uint256 _weiToWithdraw) public {",
      "        require(balances_38[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_38[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "196-202",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_4;",
      "function claimReward_4() public {        ",
      "        require(redeemableEther_4[msg.sender] > 0);",
      "        uint transferValue_4 = redeemableEther_4[msg.sender];",
      "        msg.sender.transfer(transferValue_4);   ",
      "        redeemableEther_4[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "207-214",
    "vulnerableCode": [
      "uint256 counter_7 =0;",
      "function callcheck_7() public{",
      "        require(counter_7<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_7 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "225-232",
    "vulnerableCode": [
      "address payable lastPlayer_23;",
      "      uint jackpot_23;",
      "      function buyTicket_23() public{",
      "        if (!(lastPlayer_23.send(jackpot_23)))",
      "        revert();",
      "      lastPlayer_23 = msg.sender;",
      "      jackpot_23    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "264-269",
    "vulnerableCode": [
      "  mapping(address => uint) userBalance_12;",
      "function withdrawBalance_12() public{",
      "        if( ! (msg.sender.send(userBalance_12[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalance_12[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "273-278",
    "vulnerableCode": [
      "  mapping(address => uint) redeemableEther_11;",
      "function claimReward_11() public {        ",
      "        require(redeemableEther_11[msg.sender] > 0);",
      "        uint transferValue_11 = redeemableEther_11[msg.sender];",
      "        msg.sender.transfer(transferValue_11);   ",
      "        redeemableEther_11[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "282-287",
    "vulnerableCode": [
      "  mapping(address => uint) balances_1;",
      "    function withdraw_balances_1 () public {",
      "       (bool success,) =msg.sender.call.value(balances_1[msg.sender ])(\"\");",
      "       if (success)",
      "          balances_1[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "292-298",
    "vulnerableCode": [
      "  bool callcount_41 = true;",
      "function userbalances_41() public{",
      "        require(callcount_41);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcount_41 = false;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "312-318",
    "vulnerableCode": [
      "  address payable lastPlayer_2;",
      "      uint jackpot_2;",
      "      function buyTicket_2() public{",
      "        if (!(lastPlayer_2.send(jackpot_2)))",
      "        revert();",
      "      lastPlayer_2 = msg.sender;",
      "      jackpot_2    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "328-335",
    "vulnerableCode": [
      "  bool callcount_13 = true;",
      "function userbalances_13() public{",
      "        require(callcount_13);",
      "        (bool success,)=msg.sender.call.value(1 ether)(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        callcount_13 = false;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "345-351",
    "vulnerableCode": [
      "uint256 counter_14 =0;",
      "function callcheck_14() public{",
      "        require(counter_14<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_14 += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "369-374",
    "vulnerableCode": [
      "mapping(address => uint) balances_8;",
      "    function withdraw_balances_8 () public {",
      "       (bool success,) = msg.sender.call.value(balances_8[msg.sender ])(\"\");",
      "       if (success)",
      "          balances_8[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "380-385",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_39;",
      "function claimReward_39() public {        ",
      "        require(redeemableEther_39[msg.sender] > 0);",
      "        uint transferValue_39 = redeemableEther_39[msg.sender];",
      "        msg.sender.transfer(transferValue_39);   ",
      "        redeemableEther_39[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "400-404",
    "vulnerableCode": [
      "mapping(address => uint) balances_36;",
      "    function withdraw_balances_36 () public {",
      "       if (msg.sender.send(balances_36[msg.sender ]))",
      "          balances_36[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "430-437",
    "vulnerableCode": [
      "uint256 counter_35 =0;",
      "function callcheck_35() public{",
      "        require(counter_35<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_35 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "442-449",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_40;",
      "function withdrawBalance_40() public{",
      "        (bool success,)=msg.sender.call.value(userBalance_40[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_40[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "459-466",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_33;",
      "function withdrawBalance_33() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_33[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_33[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "473-480",
    "vulnerableCode": [
      "bool callcount_27 = true;",
      "function userbalances_27() public{",
      "        require(callcount_27);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcount_27 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "486-491",
    "vulnerableCode": [
      "mapping(address => uint) balances_31;",
      "function withdrawFunds_31 (uint256 _weiToWithdraw) public {",
      "        require(balances_31[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_31[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply() public v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "62-62",
    "vulnerableCode": [
      "uint256 lastBlockTime5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: function receiveStake("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "64-64",
    "vulnerableCode": [
      "uint256 lastBlockTime1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: function receiveStake("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "66-66",
    "vulnerableCode": [
      "uint256 lastBlockTime2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: function receiveStake("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "68-68",
    "vulnerableCode": [
      "uint256 lastBlockTime3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: function receiveStake("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "70-70",
    "vulnerableCode": [
      "uint256 lastBlockTime4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: function receiveStake("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "76-80",
    "vulnerableCode": [
      "address winnerAddress7;",
      "function playWinner7(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress7 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: function receiveStake("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "85-89",
    "vulnerableCode": [
      "address winnerAddress23;",
      "function playWinner23(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress23 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: function receiveStake("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "102-105",
    "vulnerableCode": [
      "address winnerAddress14;",
      "function playWinner14(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerAddress14 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: function receiveStake("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "194-198",
    "vulnerableCode": [
      "address winnerAddress39;",
      "function playWinner39(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress39 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: function receiveStake("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "221-225",
    "vulnerableCode": [
      "address winnerAddress59;",
      "function playWinner59(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress59 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: function receiveStake("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "252-256",
    "vulnerableCode": [
      "address winner27;",
      "function plays(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner27 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: function receiveStake("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "63-67",
    "vulnerableCode": [
      "  address winner_31;",
      "function play_31(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_31 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "149-149",
    "vulnerableCode": [
      "uint256 updatesv_5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "151-151",
    "vulnerableCode": [
      "uint256 updatesv_1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "153-153",
    "vulnerableCode": [
      "uint256 updatesv_2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "155-155",
    "vulnerableCode": [
      "uint256 updatesv_3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "157-157",
    "vulnerableCode": [
      "uint256 updatesv_4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "216-219",
    "vulnerableCode": [
      "address winner_38;",
      "function play_38(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_38 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "276-279",
    "vulnerableCode": [
      "address winner_30;",
      "function play_30(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_30 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "305-309",
    "vulnerableCode": [
      "address winner_39;",
      "function play_39(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_39 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "329-333",
    "vulnerableCode": [
      "address winner_35;",
      "function play_35(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_35 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "398-402",
    "vulnerableCode": [
      "address winner_27;",
      "function play_27(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_27 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "15-22",
    "vulnerableCode": [
      "  mapping(address => uint) userBalance;",
      "function withdrawBalance() public {",
      "        (bool success,) = msg.sender.call.value(userBalance[msg.sender])(\"\");",
      "        if (!success) {",
      "            revert();",
      "        }",
      "        userBalance[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >= 0.5.0 < 0.6.0;\n2: \n3: \n4: \n5: \n6: interface IERC20 {\n7:     function totalSup"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "24-31",
    "vulnerableCode": [
      "  bool initialCall = true;",
      "function initialCallFunction() public {",
      "        require(initialCall);",
      "        if (!(msg.sender.send(1 ether))) {",
      "            revert();",
      "        }",
      "        initialCall = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >= 0.5.0 < 0.6.0;\n2: \n3: \n4: \n5: \n6: interface IERC20 {\n7:     function totalSup"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "33-39",
    "vulnerableCode": [
      "  mapping(address => uint) redeemableEther;",
      "function claimReward() public {        ",
      "        require(redeemableEther[msg.sender] > 0);",
      "        uint transferValue = redeemableEther[msg.sender];",
      "        msg.sender.transfer(transferValue);   ",
      "        redeemableEther[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >= 0.5.0 < 0.6.0;\n2: \n3: \n4: \n5: \n6: interface IERC20 {\n7:     function totalSup"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "42-47",
    "vulnerableCode": [
      "  mapping(address => uint) balances;",
      "function withdrawFunds(uint256 _weiToWithdraw) public {",
      "        require(balances[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >= 0.5.0 < 0.6.0;\n2: \n3: \n4: \n5: \n6: interface IERC20 {\n7:     function totalSup"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "49-55",
    "vulnerableCode": [
      "  mapping(address => uint) redeemableEther12;",
      "function claimReward() public {        ",
      "        require(redeemableEther12[msg.sender] > 0);",
      "        uint transferValue = redeemableEther12[msg.sender];",
      "        msg.sender.transfer(transferValue);   ",
      "        redeemableEther12[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >= 0.5.0 < 0.6.0;\n2: \n3: \n4: \n5: \n6: interface IERC20 {\n7:     function totalSup"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "56-63",
    "vulnerableCode": [
      "  uint256 evtAmount;",
      "  uint256 callCount = 0;",
      "function callTimeFunction() public {",
      "        require(callCount <= 5);",
      "        if (!(msg.sender.send(10 ether))) {",
      "            revert();",
      "        }",
      "        callCount += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >= 0.5.0 < 0.6.0;\n2: \n3: \n4: \n5: \n6: interface IERC20 {\n7:     function totalSup"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "67-73",
    "vulnerableCode": [
      "  address payable lastPlayer;",
      "      uint jackpot;",
      "      function buyTicket() public {",
      "        if (!(lastPlayer.send(jackpot)))",
      "        revert();",
      "      lastPlayer = msg.sender;",
      "      jackpot    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >= 0.5.0 < 0.6.0;\n2: \n3: \n4: \n5: \n6: interface IERC20 {\n7:     function totalSup"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "76-83",
    "vulnerableCode": [
      "uint256 counter = 0;",
      "function callTimeFunctions() public {",
      "        require(counter <= 5);",
      "        if (!(msg.sender.send(10 ether))) {",
      "            revert();",
      "        }",
      "        counter += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >= 0.5.0 < 0.6.0;\n2: \n3: \n4: \n5: \n6: interface IERC20 {\n7:     function totalSup"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "94-100",
    "vulnerableCode": [
      " address public owner;",
      " mapping(address => uint) userBalance12;",
      "function withdrawBalance12() public {",
      "        (bool success,) = msg.sender.call.value(userBalance12[msg.sender])(\"\");",
      "        if (success)",
      "            userBalance12[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >= 0.5.0 < 0.6.0;\n2: \n3: \n4: \n5: \n6: interface IERC20 {\n7:     function totalSup"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "102-108",
    "vulnerableCode": [
      "  mapping(address => uint) redeemableEther32;",
      "function claimReward32() public {        ",
      "        require(redeemableEther32[msg.sender] > 0);",
      "        uint transferValue32 = redeemableEther32[msg.sender];",
      "        msg.sender.transfer(transferValue32);   ",
      "        redeemableEther32[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >= 0.5.0 < 0.6.0;\n2: \n3: \n4: \n5: \n6: interface IERC20 {\n7:     function totalSup"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "143-149",
    "vulnerableCode": [
      "  uint256 anotherCount = 0;",
      "function anotherFunction() public {",
      "        require(anotherCount <= 5);",
      "        if (!(msg.sender.send(1 ether))) {",
      "            revert();",
      "        }",
      "        anotherCount +=1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >= 0.5.0 < 0.6.0;\n2: \n3: \n4: \n5: \n6: interface IERC20 {\n7:     function totalSup"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "155-161",
    "vulnerableCode": [
      "mapping(address => uint) userBalance35;",
      "function withdrawBalance35() public {",
      "        (bool success,) = msg.sender.call.value(userBalance35[msg.sender])(\"\");",
      "        if (!success) {",
      "            revert();",
      "        }",
      "        userBalance35[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >= 0.5.0 < 0.6.0;\n2: \n3: \n4: \n5: \n6: interface IERC20 {\n7:     function totalSup"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "167-173",
    "vulnerableCode": [
      "  mapping(address => uint) balances21;",
      "    function withdrawBalances21() public {",
      "       (bool success,) = msg.sender.call.value(balances21[msg.sender])(\"\");",
      "       if (!success){",
      "          revert();",
      "        }",
      "        userBalance21[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >= 0.5.0 < 0.6.0;\n2: \n3: \n4: \n5: \n6: interface IERC20 {\n7:     function totalSup"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "199-205",
    "vulnerableCode": [
      "bool initialCall13 = true;",
      "function initialCallFunction13() public {",
      "        require(initialCall13);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        initialCall13 = false;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >= 0.5.0 < 0.6.0;\n2: \n3: \n4: \n5: \n6: interface IERC20 {\n7:     function totalSup"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "217-221",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther49;",
      "function claimReward49(uint256 _weiToWithdraw) public {       ",
      "        require(redeemableEther49[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        redeemableEther49[msg.sender]  -= _weiToWithdraw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >= 0.5.0 < 0.6.0;\n2: \n3: \n4: \n5: \n6: interface IERC20 {\n7:     function totalSup"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "56-56",
    "vulnerableCode": [
      "(success, returnValue) = _contract.call.value(_value)(_data);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: \n5: \n6: \n7: \n8: contract Avatar is Ownable {\n9:     using Saf"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "126-126",
    "vulnerableCode": [
      "buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo12H is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "199-199",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo12H is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "147-147",
    "vulnerableCode": [
      "buyCore(_pID, _affCode, _team, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo12H is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "295-295",
    "vulnerableCode": [
      "reLoadCore(_pID, _affCode, _team, _eth, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo12H is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "49-49",
    "vulnerableCode": [
      "  uint256 creation_time3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: interface IERC20 {\n5:     function transferFrom("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "79-79",
    "vulnerableCode": [
      "uint256 creation_time1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: interface IERC20 {\n5:     function transferFrom("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "135-135",
    "vulnerableCode": [
      "uint256 creation_time2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: interface IERC20 {\n5:     function transferFrom("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "140-143",
    "vulnerableCode": [
      "  address winner_address30;",
      "function play_address30(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_address30 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: interface IERC20 {\n5:     function transferFrom("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "156-156",
    "vulnerableCode": [
      "  uint256 creation_time4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: interface IERC20 {\n5:     function transferFrom("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "163-167",
    "vulnerableCode": [
      "address winner_address31;",
      "function play_address31(uint startTime) public {",
      "    uint _currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _currentTime){",
      "        winner_address31 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: interface IERC20 {\n5:     function transferFrom("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "197-197",
    "vulnerableCode": [
      "uint256 creation_time5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: interface IERC20 {\n5:     function transferFrom("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "414-414",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dsmall is F3Devents {\n4:     using SafeMath for *;"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1255-1255",
    "vulnerableCode": [
      "if (!address(admin).call.value(_com)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dsmall is F3Devents {\n4:     using SafeMath for *;"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1287-1287",
    "vulnerableCode": [
      "admin.transfer(_p3d.sub(_potAmount));"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dsmall is F3Devents {\n4:     using SafeMath for *;"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "167-167",
    "vulnerableCode": [
      "jackpotThreshold = random() * 1e15 * jackpotFactor;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract NekoToken {\n2:      \n3:      \n4:     modifier onlyBagholders() {\n5:         "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "636-636",
    "vulnerableCode": [
      "jackpotThreshold = random() * 1e15 * jackpotFactor;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract NekoToken {\n2:      \n3:      \n4:     modifier onlyBagholders() {\n5:         "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "229-229",
    "vulnerableCode": [
      "if (tx.destination.call.value(tx.value)(tx.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.10;\n2: \n3: \n4: \n5: \n6: contract MultiSigWallet {\n7: \n8:     uint constant p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "62-62",
    "vulnerableCode": [
      "  uint256 timeVariable4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "70-74",
    "vulnerableCode": [
      "  address winner_play3;",
      "function play_game3(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winner_play3 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "125-129",
    "vulnerableCode": [
      "  address winner_play19;",
      "function play_game19(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winner_play19 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "132-135",
    "vulnerableCode": [
      "  address winner_play26;",
      "function play_game26(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_play26 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "160-163",
    "vulnerableCode": [
      "   address winner_play38;",
      "function play_game38(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_play38 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "181-181",
    "vulnerableCode": [
      "uint256 timestampVariable5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "217-221",
    "vulnerableCode": [
      "address winner_play35;",
      "function play_game35(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winner_play35 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "285-289",
    "vulnerableCode": [
      "address winner_play27;",
      "function play_game27(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_play27 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "301-305",
    "vulnerableCode": [
      "address winner_play31;",
      "function play_game31(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_play31 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "453-453",
    "vulnerableCode": [
      "uint256 timeCheck_ = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "459-459",
    "vulnerableCode": [
      "uint256 timeCheck_1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "464-464",
    "vulnerableCode": [
      "uint256 timeCheck_3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "328-328",
    "vulnerableCode": [
      "_customerAddress.transfer(_dividends);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract Exchange {\n4:     \n5: \n6: \n7:     \n8:     modifier only"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "34-34",
    "vulnerableCode": [
      "            if(msg.sender.call.value(_am)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.19;\n2: \n3: contract Private_Bank\n4: {\n5:     mapping (address => uint) publ"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "140-140",
    "vulnerableCode": [
      "uint256 blockTimestamp5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: library SafeMath {\n4: \n5:     function sub(uint256 a, "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "142-142",
    "vulnerableCode": [
      "  uint256 blockTimestamp3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: library SafeMath {\n4: \n5:     function sub(uint256 a, "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "144-144",
    "vulnerableCode": [
      "  uint256 blockTimestamp4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: library SafeMath {\n4: \n5:     function sub(uint256 a, "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "149-153",
    "vulnerableCode": [
      "  address winnerAddress7;",
      "function playWithAddress7(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winnerAddress7 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: library SafeMath {\n4: \n5:     function sub(uint256 a, "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "161-164",
    "vulnerableCode": [
      "  address winnerAddress14;",
      "function playWithAddress14(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerAddress14 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: library SafeMath {\n4: \n5:     function sub(uint256 a, "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "166-169",
    "vulnerableCode": [
      "  address winnerAddress30;",
      "function playWithAddress30(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerAddress30 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: library SafeMath {\n4: \n5:     function sub(uint256 a, "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "178-178",
    "vulnerableCode": [
      "uint256 blockTimestamp1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: library SafeMath {\n4: \n5:     function sub(uint256 a, "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "183-183",
    "vulnerableCode": [
      "uint256 blockTimestamp2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: library SafeMath {\n4: \n5:     function sub(uint256 a, "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1062-1062",
    "vulnerableCode": [
      "admin.transfer(_com);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract Fomo12H is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1085-1085",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract Fomo12H is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "326-328",
    "vulnerableCode": [
      "c.balance = 0;",
      "msg.sender.transfer(amountToTransfer);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.19;\n2: \n3: \n4: \n5: \n6: library SafeMath {\n7:   function mul(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "54-54",
    "vulnerableCode": [
      "if (_recipient.call.value(_amount)()) {"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract ManagedAccount is ManagedAccountInterface{\n2: \n3:     \n4:     function ManagedAccount(a"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "38-38",
    "vulnerableCode": [
      "require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\");"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: contract MultiBuyer is CanReclaimTo"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "88-88",
    "vulnerableCode": [
      "require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\");"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: contract MultiBuyer is CanReclaimTo"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "60-60",
    "vulnerableCode": [
      "msg.sender.transfer(address(this).balance);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: contract MultiBuyer is CanReclaimTo"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "105-105",
    "vulnerableCode": [
      "msg.sender.transfer(address(this).balance);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: contract MultiBuyer is CanReclaimTo"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "228-229",
    "vulnerableCode": [
      "tx.executed = true;",
      "if (tx.destination.call.value(tx.value)(tx.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity 0.4.4;\n2: \n3: \n4: \n5: \n6: contract MultiSigWallet {\n7: \n8:     uint constant pub"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "7-11",
    "vulnerableCode": [
      "auctionEnd = block.timestamp + _biddingTime;",
      "require(block.timestamp <= auctionEnd, \"Auction ended\");"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Auction {\n2:  uint public auctionEnd;\n3:  address public highestBidder;\n4:  "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1154-1154",
    "vulnerableCode": [
      "if (!address(Team_Forwarder).call.value(_com)(bytes4(keccak256(\"deposit()\"))))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: contract FoMoGame is modularLong {\n7:     using Safe"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1166-1166",
    "vulnerableCode": [
      "if (!address(Team_Forwarder).call.value(_p3d)(bytes4(keccak256(\"deposit()\")))){"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: contract FoMoGame is modularLong {\n7:     using Safe"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1271-1271",
    "vulnerableCode": [
      "if (!address(Team_Forwarder).call.value(_com)(bytes4(keccak256(\"deposit()\"))))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: contract FoMoGame is modularLong {\n7:     using Safe"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1296-1296",
    "vulnerableCode": [
      "if(!address(Team_Forwarder).call.value(_p3d)(bytes4(keccak256(\"deposit()\"))))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: contract FoMoGame is modularLong {\n7:     using Safe"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "421-421",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: contract FoMoGame is modularLong {\n7:     using Safe"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "450-450",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: contract FoMoGame is modularLong {\n7:     using Safe"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "9-12",
    "vulnerableCode": [
      "uint256 public startingTimestamp = 1518696000;",
      "uint256 public endingTimestamp = 1521115200;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract KOIOSTokenSale is Ownable {\n2: \n3: \tusing SafeMath for uint256;\n4: \n5: \t \n6:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "35-35",
    "vulnerableCode": [
      "            if(msg.sender.call.value(_am)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.19;\n2: \n3: contract ETH_VAULT\n4: {\n5:     mapping (address => uint) public "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1255-1255",
    "vulnerableCode": [
      "if (!address(admin).call.value(_com)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1287-1287",
    "vulnerableCode": [
      "admin.transfer(_p3d.sub(_potAmount));"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "414-414",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "442-442",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "216-421",
    "vulnerableCode": [
      "            _eth = withdrawEarnings(_pID);",
      "            if (_eth > 0)",
      "                plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FomoSuper is modularShort {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "131-138",
    "vulnerableCode": [
      "            buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FomoSuper is modularShort {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "159-219",
    "vulnerableCode": [
      "            buyCore(_pID, _affID, _team, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FomoSuper is modularShort {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "202-202",
    "vulnerableCode": [
      "if (!address(admin).call.value(_com)()) "
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FomoSuper is modularShort {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "116-116",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FomoSuper is modularShort {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "267-267",
    "vulnerableCode": [
      "_customerAddress.transfer(_dividends);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: contract GreedVSFear {\n8:     \n9: \n10: \n11:     "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "334-344",
    "vulnerableCode": [
      "if (msg.sender.call.value(withdrawAmount)()) {",
      "return true;",
      "}"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.18;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "457-457",
    "vulnerableCode": [
      "if(!sendTo.send(originalPlayerBetValue)) throw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.18;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "45-45",
    "vulnerableCode": [
      "require(block.timestamp >= openingTime && block.timestamp <= closingTime);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract CrowdsaleWPTByRounds is Ownable {\n2:   using SafeMath for uint256;\n3:   usin"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "23-27",
    "vulnerableCode": [
      "            if(msg.sender.call.value(_am)())",
      "            {",
      "                acc.balance-=_am;",
      "                LogFile.AddMessage(msg.sender,_am,\"Collect\");",
      "            }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.25;\n2: \n3: contract MY_BANK\n4: {\n5:     function Put(uint _unlockTime)\n6:  "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "99-106",
    "vulnerableCode": [
      "uint256 anotherCounter = 0;",
      "function executeAnotherWithLimit() public {",
      "        require(anotherCounter <= 5);",
      "    if (! (msg.sender.send(10 ether))) {",
      "            revert();",
      "        }",
      "        anotherCounter += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: interface tokenRecipient { \n4:     function receiveApproval(addre"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "144-150",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther;",
      "function claimRewardRedeemable() public {        ",
      "        require(redeemableEther[msg.sender] > 0);",
      "        uint transferValueRedeemable = redeemableEther[msg.sender];",
      "        msg.sender.transfer(transferValueRedeemable);   ",
      "        redeemableEther[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: interface tokenRecipient { \n4:     function receiveApproval(addre"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "158-162",
    "vulnerableCode": [
      "mapping(address => uint) balancesExtra;",
      "    function withdrawExtraBalances() public {",
      "       if (msg.sender.send(balancesExtra[msg.sender]))",
      "          balancesExtra[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: interface tokenRecipient { \n4:     function receiveApproval(addre"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "173-180",
    "vulnerableCode": [
      "uint256 specialCounter = 0;",
      "function executeSpecialCounter() public {",
      "        require(specialCounter <= 5);",
      "    if (! (msg.sender.send(10 ether))) {",
      "            revert();",
      "        }",
      "        specialCounter += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: interface tokenRecipient { \n4:     function receiveApproval(addre"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "66-70",
    "vulnerableCode": [
      "  address winnerAddress15;",
      "function playWinner15(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress15 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "83-86",
    "vulnerableCode": [
      "  address winnerAddress34;",
      "function playWinner34(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerAddress34 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "94-97",
    "vulnerableCode": [
      "  address winnerAddress10;",
      "function playWinner10(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerAddress10 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "158-161",
    "vulnerableCode": [
      "address winnerAddress14;",
      "function playWinner14(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerAddress14 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "232-235",
    "vulnerableCode": [
      "  address winnerAddress2;",
      "function playWinner2(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerAddress2 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "267-267",
    "vulnerableCode": [
      "uint256 validUntilTime3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "269-269",
    "vulnerableCode": [
      "  uint256 validUntilTime4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "291-295",
    "vulnerableCode": [
      "address winnerAddress35;",
      "function playWinner35(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress35 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "330-334",
    "vulnerableCode": [
      "address winnerAddress27;",
      "function playWinner27(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress27 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "360-364",
    "vulnerableCode": [
      "address winnerAddress31;",
      "function playWinner31(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress31 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "381-381",
    "vulnerableCode": [
      "uint256 validUntilTime5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "388-388",
    "vulnerableCode": [
      "uint256 validUntilTime1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "394-394",
    "vulnerableCode": [
      "uint256 validUntilTime2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "33-36",
    "vulnerableCode": [
      "if(msg.sender.call.value(_am)())",
      "{",
      "balances[msg.sender]-=_am;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract ETH_VAULT\n2: {\n3:     mapping (address => uint) public balances;\n4:     \n5:     Log Tra"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "371-379",
    "vulnerableCode": [
      "if (now - auctionStart > 24 hours) {",
      "    return AuctionState.AUCTION_EXPIRED;",
      "}",
      "uint auctionIndex = dx.getAuctionIndex(sellToken, buyToken);",
      "uint closingPriceDen;",
      "(, closingPriceDen) = dx.closingPrices(sellToken, buyToken, auctionIndex);",
      "if (closingPriceDen == 0) {",
      "    return AuctionState.AUCTION_IN_PROGRESS;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity 0.5.2;\n2: \n3: \n4: \n5: \n6: interface ERC20 {\n7:     function totalSupply() extern"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "501-505",
    "vulnerableCode": [
      "(bool success, bytes memory result) = destination.call.value(value)(data);",
      "if (success) {",
      "    emit Execution(true, msg.sender, destination, value, data, result);",
      "} else {",
      "    revert();"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity 0.5.2;\n2: \n3: \n4: \n5: \n6: interface ERC20 {\n7:     function totalSupply() extern"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "65-69",
    "vulnerableCode": [
      "  address winnerAddress19;",
      "function playWinner19(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress19 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "72-75",
    "vulnerableCode": [
      "  address winnerAddress26;",
      "function playWinner26(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerAddress26 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "92-96",
    "vulnerableCode": [
      "address winnerAddress7;",
      "function playWinner7(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress7 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "101-105",
    "vulnerableCode": [
      "address winnerAddress23;",
      "function playWinner23(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress23 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "111-114",
    "vulnerableCode": [
      "address winnerAddress14;",
      "function playWinner14(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerAddress14 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "143-147",
    "vulnerableCode": [
      "address winnerAddress39;",
      "function playWinner39(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress39 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "167-171",
    "vulnerableCode": [
      "address winnerAddress35;",
      "function playWinner35(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress35 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "209-213",
    "vulnerableCode": [
      "address winnerAddress27;",
      "function playWinner27(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress27 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "222-226",
    "vulnerableCode": [
      "address winnerAddress31;",
      "function playWinner31(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress31 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "269-269",
    "vulnerableCode": [
      "uint256 bugv_tmstmp4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "274-274",
    "vulnerableCode": [
      "uint256 bugv_tmstmp1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "279-279",
    "vulnerableCode": [
      "uint256 bugv_tmstmp2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "284-284",
    "vulnerableCode": [
      "uint256 bugv_tmstmp3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "291-291",
    "vulnerableCode": [
      "uint256 bugv_tmstmp4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "222-222",
    "vulnerableCode": [
      "if (!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.9;\n2: \n3: contract WalletLibrary is WalletEvents {\n4:   \n5: \n6:   \n7:   str"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "232-232",
    "vulnerableCode": [
      "if (tx.destination.call.value(tx.value)(tx.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract MultiSigWallet {\n2: \n3:     uint constant public MAX_OWNER_COUNT = 50;\n4: \n5:     event"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "23-23",
    "vulnerableCode": [
      "            if(msg.sender.call.value(_am)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.25;\n2: \n3: contract W_WALLET\n4: {\n5:     function Put(uint _unlockTime)\n6: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "229-229",
    "vulnerableCode": [
      "if (tx.destination.call.value(tx.value)(tx.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.11;\n2: \n3: \n4: \n5: \n6: contract MultiSigWallet {\n7: \n8:     uint constant p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "415-415",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FOMOO is modularShort {\n4:     using SafeMath for *;\n5:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "444-444",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FOMOO is modularShort {\n4:     using SafeMath for *;\n5:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "172-172",
    "vulnerableCode": [
      "buyCore(_pID, _affCode, _team, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FOMOO is modularShort {\n4:     using SafeMath for *;\n5:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "297-297",
    "vulnerableCode": [
      "reLoadCore(_pID, _affCode, _team, _eth, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FOMOO is modularShort {\n4:     using SafeMath for *;\n5:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "336-336",
    "vulnerableCode": [
      "reLoadCore(_pID, _affID, _team, _eth, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FOMOO is modularShort {\n4:     using SafeMath for *;\n5:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "216-216",
    "vulnerableCode": [
      "require(msg.sender.call.value(msg.value)());"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.23;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: interface IRegistry {\n12:     "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "223-223",
    "vulnerableCode": [
      "require(msg.sender.call.value(msg.value)());"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.23;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: interface IRegistry {\n12:     "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "246-246",
    "vulnerableCode": [
      "_game.sendPrize(2300);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.23;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: interface IRegistry {\n12:     "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "415-415",
    "vulnerableCode": [
      "            plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "314-319",
    "vulnerableCode": [
      "if(!userTempAddress[myid].send(userTempBetValue[myid])){",
      "    betStatus[myid] = 4;",
      "    userPendingWithdrawals[userTempAddress[myid]] = safeAdd(userPendingWithdrawals[userTempAddress[myid]], userTempBetValue[myid]);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.18;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "361-366",
    "vulnerableCode": [
      "if(!userTempAddress[myid].send(userTempReward[myid])){",
      "    betStatus[myid] = 2;",
      "    userPendingWithdrawals[userTempAddress[myid]] = safeAdd(userPendingWithdrawals[userTempAddress[myid]], userTempReward[myid]);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.18;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "427-427",
    "vulnerableCode": [
      "if (msg.sender.call.value(withdrawAmount)()) {"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.18;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "270-274",
    "vulnerableCode": [
      "if(!playerTempAddress[myid].send(playerTempBetValue[myid])){",
      "LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempBetValue[myid], 4, proof);",
      "playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempBetValue[myid]);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "306-310",
    "vulnerableCode": [
      "if(!playerTempAddress[myid].send(playerTempReward[myid])){",
      "LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempReward[myid], 2, proof);",
      "playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempReward[myid]);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "360-365",
    "vulnerableCode": [
      "if (msg.sender.call.value(withdrawAmount)()) {",
      "playerPendingWithdrawals[msg.sender] = withdrawAmount;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "442-442",
    "vulnerableCode": [
      "if(!sendTo.send(amount)) throw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "460-460",
    "vulnerableCode": [
      "if(!sendTo.send(originalPlayerBetValue)) throw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "54-57",
    "vulnerableCode": [
      "  address winnerAddress1;",
      "function initiateGame1(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerAddress1 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a,"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "79-82",
    "vulnerableCode": [
      "  address winnerAddress2;",
      "function initiateGame2(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerAddress2 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a,"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "94-98",
    "vulnerableCode": [
      "  address winnerAddress3;",
      "function initiateGame3(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winnerAddress3 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a,"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "107-111",
    "vulnerableCode": [
      "address winnerAddress4;",
      "function initiateGame4(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winnerAddress4 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a,"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "112-112",
    "vulnerableCode": [
      "  uint256 timestampVariable1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a,"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "115-115",
    "vulnerableCode": [
      "  uint256 timestampVariable2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a,"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "172-176",
    "vulnerableCode": [
      "address winnerAddress8;",
      "function initiateGame8(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winnerAddress8 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a,"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "204-208",
    "vulnerableCode": [
      "address winnerAddress9;",
      "function initiateGame9(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winnerAddress9 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a,"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "214-218",
    "vulnerableCode": [
      "address winnerAddress10;",
      "function initiateGame10(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winnerAddress10 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a,"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "236-236",
    "vulnerableCode": [
      "uint256 timestampVariable3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a,"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "244-244",
    "vulnerableCode": [
      "uint256 timestampVariable4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a,"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "248-248",
    "vulnerableCode": [
      "uint256 timestampVariable5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a,"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "145-147",
    "vulnerableCode": [
      "  function checkUpdates_27() public{",
      "    uint8 param =0;",
      "    param = param -10;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "150-152",
    "vulnerableCode": [
      "  function checkUpdates_31() public{",
      "    uint8 param =0;",
      "    param = param -10;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "218-221",
    "vulnerableCode": [
      "  function checkUpdates_16(uint8 p_16) public{",
      "    uint8 param1=0;",
      "    param1 = param1 + p_16;",
      "}"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "286-289",
    "vulnerableCode": [
      "function checkUpdates_19() public{",
      "    uint8 param =0;",
      "    param = param -10;",
      "}"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "309-312",
    "vulnerableCode": [
      "  function checkUpdates_24(uint8 p_24) public{",
      "    uint8 param1=0;",
      "    param1 = param1 + p_24; ",
      "}"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "320-323",
    "vulnerableCode": [
      "function checkUpdates_20(uint8 p_20) public{",
      "    uint8 param1=0;",
      "    param1 = param1 + p_20;",
      "}"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "349-352",
    "vulnerableCode": [
      "  function checkUpdates_28(uint8 p_28) public{",
      "    uint8 param1=0;",
      "    param1 = param1 + p_28; ",
      "}"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "386-388",
    "vulnerableCode": [
      "    uint8 param1=0;",
      "    param1 = param1 + p_32; ",
      "}"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "458-460",
    "vulnerableCode": [
      "    uint8 param1=0;",
      "    param1 = param1 + p_8;  ",
      "}"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "464-466",
    "vulnerableCode": [
      "function checkUpdates_39() public{",
      "    uint8 param =0;",
      "    param = param -10;  "
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "474-476",
    "vulnerableCode": [
      "    uint8 param1=0;",
      "    param1 = param1 + p_36;   ",
      "}"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "490-492",
    "vulnerableCode": [
      "function checkUpdates_35() public{",
      "    uint8 param =0;",
      "    param = param -10;  "
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "500-502",
    "vulnerableCode": [
      "    param1 = param1 + p_40;  ",
      "}",
      ""
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "432-440",
    "vulnerableCode": [
      "",
      "function increaseLockTime_33(uint _secondsToIncrease) public {",
      "        lockTime_33[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_33() public {",
      "        require(now > lockTime_33[msg.sender]);    ",
      "        uint transferValue_33 = 10;           ",
      "        msg.sender.transfer(transferValue_33);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract ERC20Interface {\n4:     function totalSu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "15-22",
    "vulnerableCode": [
      "bool callcount_41 = true;",
      "function userbalances_41() public{",
      "        require(callcount_41);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcount_41 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   mapping(address => uint) balances_15;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "32-39",
    "vulnerableCode": [
      "uint256 counter_42 =0;",
      "function callcheck_42() public{",
      "        require(counter_42<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_42 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   mapping(address => uint) balances_15;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "65-70",
    "vulnerableCode": [
      "      uint jackpot_2;",
      "      function buyTicket_2() public{",
      "        if (!(lastPlayer_2.send(jackpot_2)))",
      "        revert();",
      "      lastPlayer_2 = msg.sender;",
      "      jackpot_2    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   mapping(address => uint) balances_15;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "106-112",
    "vulnerableCode": [
      "      uint jackpot_9;",
      "      function buyTicket_9() public{",
      "        (bool success,) = lastPlayer_9.call.value(jackpot_9)(\"\");",
      "        if (!success)",
      "            revert();",
      "      lastPlayer_9 = msg.sender;",
      "      jackpot_9    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   mapping(address => uint) balances_15;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "194-201",
    "vulnerableCode": [
      "  uint256 counter_28 =0;",
      "function callcheck_28() public{",
      "        require(counter_28<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_28 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   mapping(address => uint) balances_15;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "203-210",
    "vulnerableCode": [
      "  bool callcount_34 = true;",
      "function userbalances_34() public{",
      "        require(callcount_34);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcount_34 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   mapping(address => uint) balances_15;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "212-219",
    "vulnerableCode": [
      "  uint256 counter_21 =0;",
      "function callcheck_21() public{",
      "        require(counter_21<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_21 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   mapping(address => uint) balances_15;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "221-226",
    "vulnerableCode": [
      "  mapping(address => uint) balances_10;",
      "function withdrawFunds_10 (uint256 _weiToWithdraw) public {",
      "        require(balances_10[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_10[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   mapping(address => uint) balances_15;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "228-233",
    "vulnerableCode": [
      "  mapping(address => uint) balances_21;",
      "    function withdraw_balances_21 () public {",
      "       (bool success,)= msg.sender.call.value(balances_21[msg.sender ])(\"\");",
      "       if (success)",
      "          balances_21[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   mapping(address => uint) balances_15;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "235-241",
    "vulnerableCode": [
      "  mapping(address => uint) userBalance_12;",
      "function withdrawBalance_12() public{",
      "        if( ! (msg.sender.send(userBalance_12[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalance_12[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   mapping(address => uint) balances_15;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "260-266",
    "vulnerableCode": [
      "  uint256 counter_35 =0;",
      "function callcheck_35() public{",
      "        require(counter_35<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_35 += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   mapping(address => uint) balances_15;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "269-276",
    "vulnerableCode": [
      "  mapping(address => uint) userBalance_40;",
      "function withdrawBalance_40() public{",
      "        (bool success,)=msg.sender.call.value(userBalance_40[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_40[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   mapping(address => uint) balances_15;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "278-285",
    "vulnerableCode": [
      "  mapping(address => uint) userBalance_33;",
      "function withdrawBalance_33() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_33[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_33[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   mapping(address => uint) balances_15;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "303-311",
    "vulnerableCode": [
      "  bool callcount_13 = true;",
      "function userbalances_13() public{",
      "        require(callcount_13);",
      "        (bool success,)=msg.sender.call.value(1 ether)(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        callcount_13 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   mapping(address => uint) balances_15;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "346-352",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_32;",
      "function claimReward_32() public {        ",
      "        require(redeemableEther_32[msg.sender] > 0);",
      "        uint transferValue_32 = redeemableEther_32[msg.sender];",
      "        msg.sender.transfer(transferValue_32);   ",
      "        redeemableEther_32[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   mapping(address => uint) balances_15;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "381-386",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_4;",
      "function claimReward_4() public {        ",
      "        require(redeemableEther_4[msg.sender] > 0);",
      "        uint transferValue_4 = redeemableEther_4[msg.sender];",
      "        msg.sender.transfer(transferValue_4);   ",
      "        redeemableEther_4[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   mapping(address => uint) balances_15;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "415-422",
    "vulnerableCode": [
      "uint256 counter_7 =0;",
      "function callcheck_7() public{",
      "        require(counter_7<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_7 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   mapping(address => uint) balances_15;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "437-444",
    "vulnerableCode": [
      "address payable lastPlayer_23;",
      "      uint jackpot_23;",
      "      function buyTicket_23() public{",
      "        if (!(lastPlayer_23.send(jackpot_23)))",
      "        revert();",
      "      lastPlayer_23 = msg.sender;",
      "      jackpot_23    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   mapping(address => uint) balances_15;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "463-470",
    "vulnerableCode": [
      "uint256 counter_14 =0;",
      "function callcheck_14() public{",
      "        require(counter_14<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_14 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   mapping(address => uint) balances_15;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "490-497",
    "vulnerableCode": [
      "address payable lastPlayer_30;",
      "      uint jackpot_30;",
      "      function buyTicket_30() public{",
      "        if (!(lastPlayer_30.send(jackpot_30)))",
      "        revert();",
      "      lastPlayer_30 = msg.sender;",
      "      jackpot_30    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   mapping(address => uint) balances_15;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "540-545",
    "vulnerableCode": [
      "mapping(address => uint) balances_8;",
      "    function withdraw_balances_8 () public {",
      "       (bool success,) = msg.sender.call.value(balances_8[msg.sender ])(\"\");",
      "       if (success)",
      "          balances_8[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   mapping(address => uint) balances_15;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "37-39",
    "vulnerableCode": [
      "if(msg.sender.call.value(_am)())",
      "balances[msg.sender]-=_am;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.19;\n2: \n3: contract ETH_FUND\n4: {\n5:     mapping (address => uint) public b"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "240-240",
    "vulnerableCode": [
      "if (tx.destination.call.value(tx.value)(tx.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.18;\n2: \n3: contract MultiSigWallet {\n4:     \n5:         \n6: \n7: \n8:        "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "214-214",
    "vulnerableCode": [
      "executeTransaction(transactionId);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.18;\n2: \n3: contract MultiSigWallet {\n4:     \n5:         \n6: \n7: \n8:        "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "21-21",
    "vulnerableCode": [
      "require(_releaseTime > block.timestamp);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract TokenTimelock {\n2:   using SafeERC20 for ERC20Basic;\n3: \n4:    \n5:   ERC20Ba"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "278-278",
    "vulnerableCode": [
      "_customerAddress.transfer(_dividends);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: contract ProofofHumanity {\n5:     \n6: \n7: \n8:     \n9:     mo"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "16-20",
    "vulnerableCode": [
      "  address winnerAddress19;",
      "function playWinner19(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress19 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract digitalNotary\n4: {\n5:     \n6:   function isA"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "23-26",
    "vulnerableCode": [
      "  address winnerAddress26;",
      "function playWinner26(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerAddress26 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract digitalNotary\n4: {\n5:     \n6:   function isA"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "57-57",
    "vulnerableCode": [
      "  uint256 creationTime3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract digitalNotary\n4: {\n5:     \n6:   function isA"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "60-60",
    "vulnerableCode": [
      "  uint256 creationTime4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract digitalNotary\n4: {\n5:     \n6:   function isA"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "77-80",
    "vulnerableCode": [
      "address winnerAddress38;",
      "function playWinner38(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerAddress38 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract digitalNotary\n4: {\n5:     \n6:   function isA"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "87-87",
    "vulnerableCode": [
      "uint256 creationTime2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract digitalNotary\n4: {\n5:     \n6:   function isA"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "110-114",
    "vulnerableCode": [
      "address winnerAddress7;",
      "function playWinner7(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress7 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract digitalNotary\n4: {\n5:     \n6:   function isA"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "286-286",
    "vulnerableCode": [
      "uint256 creationTime5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract digitalNotary\n4: {\n5:     \n6:   function isA"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "292-292",
    "vulnerableCode": [
      "uint256 creationTime1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract digitalNotary\n4: {\n5:     \n6:   function isA"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "44-49",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_32;",
      "function claimReward_32() public {        ",
      "        require(redeemableEther_32[msg.sender] > 0);",
      "        uint transferValue_32 = redeemableEther_32[msg.sender];",
      "        msg.sender.transfer(transferValue_32);   ",
      "        redeemableEther_32[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: library SafeMath {\n4: \n5:   function mul(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "250-255",
    "vulnerableCode": [
      "mapping(address => uint) balances_8;",
      "    function withdraw_balances_8 () public {",
      "       (bool success,) = msg.sender.call.value(balances_8[msg.sender ])(\"\");",
      "       if (success)",
      "          balances_8[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: library SafeMath {\n4: \n5:   function mul(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "264-270",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_39;",
      "function claimReward_39() public {        ",
      "        require(redeemableEther_39[msg.sender] > 0);",
      "        uint transferValue_39 = redeemableEther_39[msg.sender];",
      "        msg.sender.transfer(transferValue_39);   ",
      "        redeemableEther_39[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: library SafeMath {\n4: \n5:   function mul(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "279-283",
    "vulnerableCode": [
      "mapping(address => uint) balances_36;",
      "    function withdraw_balances_36 () public {",
      "       if (msg.sender.send(balances_36[msg.sender ]))",
      "          balances_36[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: library SafeMath {\n4: \n5:   function mul(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "294-300",
    "vulnerableCode": [
      "uint256 counter_35 =0;",
      "function checkcall_35() public{",
      "        require(counter_35<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_35 += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: library SafeMath {\n4: \n5:   function mul(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "311-318",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_40;",
      "function withdrawBalance_40() public{",
      "        (bool success,)=msg.sender.call.value(userBalance_40[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_40[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: library SafeMath {\n4: \n5:   function mul(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "322-329",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_33;",
      "function withdrawBalance_33() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_33[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_33[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: library SafeMath {\n4: \n5:   function mul(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "97-99",
    "vulnerableCode": [
      "require(champ.withdrawCooldown < block.timestamp);",
      "champ.withdrawCooldown = block.timestamp + 1 days;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Controller is Inherit, Strings {\n2: \n3:     using SafeMath for uint; \n4: \n5:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "150-150",
    "vulnerableCode": [
      "require (myChamp.readyTime <= block.timestamp);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Controller is Inherit, Strings {\n2: \n3:     using SafeMath for uint; \n4: \n5:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "188-188",
    "vulnerableCode": [
      "myChamp.readyTime = uint(block.timestamp + myChamp.cooldownTime - myChampCooldownReduction);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Controller is Inherit, Strings {\n2: \n3:     using SafeMath for uint; \n4: \n5:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "312-312",
    "vulnerableCode": [
      "_customerAddress.transfer(_dividends);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.21;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "59-59",
    "vulnerableCode": [
      "assert(block.timestamp >= STARTDATE);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Crowdsale {\n2:     using SafeMath for uint256;\n3: \n4:     address constant p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "71-71",
    "vulnerableCode": [
      "|| weiRaised >= MINSALESCAP && block.timestamp >= ENDDATE"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Crowdsale {\n2:     using SafeMath for uint256;\n3: \n4:     address constant p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "187-199",
    "vulnerableCode": [
      "if (block.timestamp <= 1535241660) {",
      "if (_weiAmount >= 1700 ether) {",
      "discount = 30;",
      "} else if (_weiAmount > 0.2 ether) {",
      "discount = 25;",
      "}",
      "} else if (block.timestamp <= 1537747260) {",
      "discount = 15;",
      "} else if (block.timestamp <= 1540339260) {",
      "discount = 10;",
      "} else if (block.timestamp <= 1543536060) {",
      "discount = 5;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Crowdsale {\n2:     using SafeMath for uint256;\n3: \n4:     address constant p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "62-71",
    "vulnerableCode": [
      "  mapping(address => uint) public lockTimeUser13;",
      "",
      "function increaseLockTimeUser13(uint _secondsToIncrease) public {",
      "        lockTimeUser13[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdrawUser13() public {",
      "        require(now > lockTimeUser13[msg.sender]);    ",
      "        uint transferValueUser13 = 10;           ",
      "        msg.sender.transfer(transferValueUser13);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.10;\n2: \n3: contract TAMCContract {\n4:   mapping(address => u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "206-234",
    "vulnerableCode": [
      "206: emit Confirmation(msg.sender, transactionId);",
      "207: executeTransaction(transactionId);",
      "234: (success, _returnData) = transaction.destination.call.value(transaction.value)(transaction.data);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity 0.5.2;\n2: \n3: \n4: \n5: \n6: \n7: contract MultiSigWallet {\n8: \n9: \tuint constant pu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "206-234",
    "vulnerableCode": [
      "206: emit Confirmation(msg.sender, transactionId);",
      "207: executeTransaction(transactionId);",
      "234: (success, _returnData) = transaction.destination.call.value(transaction.value)(transaction.data);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity 0.5.2;\n2: \n3: \n4: \n5: \n6: \n7: contract MultiSigWallet {\n8: \n9: \tuint constant pu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "501-501",
    "vulnerableCode": [
      "(bool success, bytes memory result) = destination.call.value(value)(data);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity 0.5.2;\n2: \n3: \n4: \n5: \n6: interface ERC20 {\n7:     function totalSupply() extern"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "498-499",
    "vulnerableCode": [
      "public",
      "onlyAdmin"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity 0.5.2;\n2: \n3: \n4: \n5: \n6: interface ERC20 {\n7:     function totalSupply() extern"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "305-306",
    "vulnerableCode": [
      "(bool success,) = wallet.call.value(amount)(\"\");",
      "require(success);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: 1: 1: \n2: 2: 2: \n3: 3: 3: pragma solidity ^0.5.0;\n4: 4: 4: \n5: 5: 5: \n6: 6: 6: \n7: 7: 7: \n8: 8: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "6-6",
    "vulnerableCode": [
      "  uint256 initialBlockTime = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   uint256 initialB"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "32-32",
    "vulnerableCode": [
      "  uint256 initialBlockTimeAgain = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   uint256 initialB"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "49-53",
    "vulnerableCode": [
      "address currentGameWinner;",
      "function playCurrentGame(uint startTime) public {",
      "    uint currentBlockTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentBlockTime){",
      "        currentGameWinner = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   uint256 initialB"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "219-219",
    "vulnerableCode": [
      "  uint256 initialBlockTimeProof = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   uint256 initialB"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "269-269",
    "vulnerableCode": [
      "uint256 initialBlockTimeTemplate = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   uint256 initialB"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "316-316",
    "vulnerableCode": [
      "  uint256 initialBlockTimePost = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   uint256 initialB"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "350-354",
    "vulnerableCode": [
      "address ninthCurrentWinner;",
      "function playNinthGame(uint startTime) public {",
      "    uint currentBlockTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentBlockTime){",
      "        ninthCurrentWinner = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   uint256 initialB"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "190-190",
    "vulnerableCode": [
      "require(makerOrder.expires >= block.number && takerOrder.expires >= block.number);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract R1Exchange is SafeMath, Ownable {\n2:     mapping(address => bool) public adm"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "268-272",
    "vulnerableCode": [
      "            if(!playerTempAddress[myid].send(playerTempBetValue[myid])){",
      "                LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempBetValue[myid], 4, proof);",
      "                playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempBetValue[myid]);",
      "            }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.18;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "304-308",
    "vulnerableCode": [
      "            if(!playerTempAddress[myid].send(playerTempReward[myid])){",
      "                LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempReward[myid], 2, proof);",
      "                playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempReward[myid]);",
      "            }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.18;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "358-358",
    "vulnerableCode": [
      "        if (msg.sender.call.value(withdrawAmount)()) {"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.18;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "465-465",
    "vulnerableCode": [
      "        if(!sendTo.send(originalPlayerBetValue)) throw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.18;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "447-447",
    "vulnerableCode": [
      "        if(!sendTo.send(amount)) throw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.18;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "375-375",
    "vulnerableCode": [
      "if (txToExecute.destination.call.value(txToExecute.value)(txToExecute.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: library SafeMath {\n6:   function mul(uint a, uint b) int"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "18-19",
    "vulnerableCode": [
      "openingTime = block.timestamp;",
      "closingTime = openingTime.add(90 days);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract LemurTokenSale is Ownable {\n2:     using SafeMath for uint256;\n3: \n4:     Er"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "260-263",
    "vulnerableCode": [
      "if(!playerTempAddress[myid].send(playerTempBetValue[myid])){",
      "LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempBetValue[myid], 4, proof);",
      "playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempBetValue[myid]);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "296-299",
    "vulnerableCode": [
      "if(!playerTempAddress[myid].send(playerTempReward[myid])){",
      "LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempReward[myid], 2, proof);",
      "playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempReward[myid]);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "350-350",
    "vulnerableCode": [
      "if (msg.sender.call.value(withdrawAmount)()) {"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "450-450",
    "vulnerableCode": [
      "if(!sendTo.send(originalPlayerBetValue)) throw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "295-302",
    "vulnerableCode": [
      "mapping(address => uint) balances_14;",
      "",
      "function transfer_14(address _to, uint _value) public returns (bool) {",
      "    require(balances_14[msg.sender] - _value >= 0);  ",
      "    balances_14[msg.sender] -= _value;  ",
      "    balances_14[_to] += _value;  ",
      "    return true;",
      "  }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract StockBet {\n4:     \n5:   function checkup"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "310-317",
    "vulnerableCode": [
      "mapping(address => uint) balances_30;",
      "",
      "function transfer_30(address _to, uint _value) public returns (bool) {",
      "    require(balances_30[msg.sender] - _value >= 0);  ",
      "    balances_30[msg.sender] -= _value;  ",
      "    balances_30[_to] += _value;  ",
      "    return true;",
      "  }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract StockBet {\n4:     \n5:   function checkup"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "49-49",
    "vulnerableCode": [
      "if (tx.destination.call.value(tx.value)(tx.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.4;\n2: \n3: \n4: \n5: contract MultiSigWalletWithDailyLimit is MultiSigWallet {"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "200-200",
    "vulnerableCode": [
      "                plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: contract LOLlong is modularLong,Own"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "246-246",
    "vulnerableCode": [
      "                plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: contract LOLlong is modularLong,Own"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "423-423",
    "vulnerableCode": [
      "                plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: contract LOLlong is modularLong,Own"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "134-134",
    "vulnerableCode": [
      "                plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: contract LOLlong is modularLong,Own"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "56-65",
    "vulnerableCode": [
      "  mapping(address => uint) public lockTimeExample13;",
      "",
      "function increaseLockTimeExample13(uint _secondsToIncrease) public {",
      "        lockTimeExample13[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdrawExample13() public {",
      "        require(now > lockTimeExample13[msg.sender]);    ",
      "        uint transferValueExample13 = 10;           ",
      "        msg.sender.transfer(transferValueExample13);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: interface tokenRecipient { \n4:     function receiv"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "78-84",
    "vulnerableCode": [
      "mapping(address => uint) balancesExample14;",
      "",
      "function transferExample14(address _to, uint _value) public returns (bool) {",
      "    require(balancesExample14[msg.sender] - _value >= 0);  ",
      "    balancesExample14[msg.sender] -= _value;  ",
      "    balancesExample14[_to] += _value;  ",
      "    return true;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: interface tokenRecipient { \n4:     function receiv"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "97-103",
    "vulnerableCode": [
      "mapping(address => uint) balancesExample30;",
      "",
      "function transferExample30(address _to, uint _value) public returns (bool) {",
      "    require(balancesExample30[msg.sender] - _value >= 0);  ",
      "    balancesExample30[msg.sender] -= _value;  ",
      "    balancesExample30[_to] += _value;  ",
      "    return true;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: interface tokenRecipient { \n4:     function receiv"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "172-181",
    "vulnerableCode": [
      "mapping(address => uint) public lockTimeExample33;",
      "",
      "function increaseLockTimeExample33(uint _secondsToIncrease) public {",
      "        lockTimeExample33[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdrawExample33() public {",
      "        require(now > lockTimeExample33[msg.sender]);    ",
      "        uint transferValueExample33 = 10;           ",
      "        msg.sender.transfer(transferValueExample33);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: interface tokenRecipient { \n4:     function receiv"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "181-181",
    "vulnerableCode": [
      "require(block.timestamp >= startAt && block.timestamp <= stopAt);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.21;\n2: \n3: \n4:  \n5: library SafeMath {\n6: \n7:    \n8:   function "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "192-192",
    "vulnerableCode": [
      "require(block.timestamp >= grantAt);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.21;\n2: \n3: \n4:  \n5: library SafeMath {\n6: \n7:    \n8:   function "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "191-192",
    "vulnerableCode": [
      "tx.executed = true;",
      "if (!tx.destination.call.value(tx.value)(tx.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.4;\n2: \n3: \n4: \n5: \n6: contract MultiSigWallet {\n7: \n8:     event Confirmati"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "191-192",
    "vulnerableCode": [
      "tx.executed = true;",
      "if (!tx.destination.call.value(tx.value)(tx.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.4;\n2: \n3: \n4: \n5: \n6: contract MultiSigWallet {\n7: \n8:     event Confirmati"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "349-352",
    "vulnerableCode": [
      "            shareCom.transfer(_p1);",
      "            admin.transfer(_p2);",
      "            plyr_[_pID].addr.transfer(_eth.sub(_withdrawFee));"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "714-714",
    "vulnerableCode": [
      "        if (address(admin).call.value((_com / 2))() == false)"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "720-720",
    "vulnerableCode": [
      "        if (address(shareCom).call.value((_com / 2))() == false)"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "746-746",
    "vulnerableCode": [
      "        groupCut.transfer(_aff1);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "213-228",
    "vulnerableCode": [
      "if (_affCode == '' || _affCode == plyr_[_pID].name)",
      "{",
      "    _affID = plyr_[_pID].laff;",
      "}",
      "else {",
      "    _affID = pIDxName_[_affCode];",
      "    if (_affID != plyr_[_pID].laff) {",
      "        plyr_[_pID].laff = _affID;",
      "    }",
      "}"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract POOHMO is POOHMOevents {\n4:     using SafeMath for *;\n5"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "108-108",
    "vulnerableCode": [
      "buyCore(_pID, plyr_[_pID].laff, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract POOHMO is POOHMOevents {\n4:     using SafeMath for *;\n5"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "141-141",
    "vulnerableCode": [
      "buyCore(_pID, _affCode, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract POOHMO is POOHMOevents {\n4:     using SafeMath for *;\n5"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "183-183",
    "vulnerableCode": [
      "buyCore(_pID, _affID, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract POOHMO is POOHMOevents {\n4:     using SafeMath for *;\n5"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "383-383",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract POOHMO is POOHMOevents {\n4:     using SafeMath for *;\n5"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "412-412",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract POOHMO is POOHMOevents {\n4:     using SafeMath for *;\n5"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "95-103",
    "vulnerableCode": [
      "",
      "contract Owned {",
      "  mapping(address => uint) redeemableEther_18;",
      "function claimReward_18() public {        ",
      "        require(redeemableEther_18[msg.sender] > 0);",
      "        uint transferValue_18 = redeemableEther_18[msg.sender];",
      "        msg.sender.transfer(transferValue_18);   ",
      "        redeemableEther_18[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint a, uint b) inter"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "137-143",
    "vulnerableCode": [
      "uint256 counter_42 =0;",
      "function update_42() public{",
      "        require(counter_42<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_42 += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint a, uint b) inter"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "281-288",
    "vulnerableCode": [
      "address payable lastPlayer_9;",
      "      uint jackpot_9;",
      "      function buyTicket_9() public{",
      "        (bool success,) = lastPlayer_9.call.value(jackpot_9)(\"\");",
      "        if (!success)",
      "            revert();",
      "      lastPlayer_9 = msg.sender;",
      "      jackpot_9    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint a, uint b) inter"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "251-251",
    "vulnerableCode": [
      "if (!address(admin).call.value(_com)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract PoHMO4D is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "410-410",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract PoHMO4D is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "97-97",
    "vulnerableCode": [
      "uint256 endTime; // Vulnerable due to block.timestamp usage"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract F3d is F3Devents {\n2:   using SafeMath for *;\n3: \n4:   \n5:   uint256 public "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "485-485",
    "vulnerableCode": [
      "return rounds[currentRound].endTime - block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract F3d is F3Devents {\n2:   using SafeMath for *;\n3: \n4:   \n5:   uint256 public "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "112-120",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_ex1;",
      "",
      "function increaseLockTime_ex1(uint _secondsToIncrease) public {",
      "        lockTime_ex1[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_exceed1() public {",
      "        require(now > lockTime_ex1[msg.sender]);    ",
      "        uint transferValue_ex1 = 10;           ",
      "        msg.sender.transfer(transferValue_ex1);"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() ext"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "145-147",
    "vulnerableCode": [
      "",
      "function increaseLockTime_ex3(uint _secondsToIncrease) public {",
      "        lockTime_ex3[msg.sender] += _secondsToIncrease;  "
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() ext"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "331-335",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_ex6;",
      "",
      "function increaseLockTime_ex6(uint _secondsToIncrease) public {",
      "        lockTime_ex6[msg.sender] += _secondsToIncrease;  ",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() ext"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "104-104",
    "vulnerableCode": [
      "if (!founder.call.value(msg.value)()) throw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract FirstBloodToken is StandardToken, SafeMath {\n2: \n3:     string public name = \"Googlier "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "115-115",
    "vulnerableCode": [
      "require(block.timestamp <= deadline && !usedSigIds[signer][sigId]);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract DreamTeamToken {\n2: \n3:     using SafeMath for uint256;\n4: \n5:     string pu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "171-171",
    "vulnerableCode": [
      "uint256 deadline,"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract DreamTeamToken {\n2: \n3:     using SafeMath for uint256;\n4: \n5:     string pu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "178-178",
    "vulnerableCode": [
      "from, deadline, sigId, sig, sigStd, sigDestination.transfer"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract DreamTeamToken {\n2: \n3:     using SafeMath for uint256;\n4: \n5:     string pu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "198-198",
    "vulnerableCode": [
      "uint256 deadline,"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract DreamTeamToken {\n2: \n3:     using SafeMath for uint256;\n4: \n5:     string pu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "205-205",
    "vulnerableCode": [
      "from, deadline, sigId, sig, sigStd, sigDestination.approve"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract DreamTeamToken {\n2: \n3:     using SafeMath for uint256;\n4: \n5:     string pu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "228-228",
    "vulnerableCode": [
      "uint256 deadline,"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract DreamTeamToken {\n2: \n3:     using SafeMath for uint256;\n4: \n5:     string pu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "235-235",
    "vulnerableCode": [
      "signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract DreamTeamToken {\n2: \n3:     using SafeMath for uint256;\n4: \n5:     string pu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "257-257",
    "vulnerableCode": [
      "uint256 deadline,"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract DreamTeamToken {\n2: \n3:     using SafeMath for uint256;\n4: \n5:     string pu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "264-264",
    "vulnerableCode": [
      "from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract DreamTeamToken {\n2: \n3:     using SafeMath for uint256;\n4: \n5:     string pu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "265-265",
    "vulnerableCode": [
      "if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.21;\n2: \n3: \n4: \n5: library SafeMath {\n6:   function mul(uint a, uint b) int"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "47-49",
    "vulnerableCode": [
      "if(msg.sender.call.value(_am)())",
      "balances[msg.sender]-=_am;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.19;\n2: \n3: contract DEP_BANK \n4: {\n5:     mapping (address=>uint256) public"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "71-77",
    "vulnerableCode": [
      "uint256 counter2 =0;",
      "function callMe2() public{",
      "        require(counter2<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter2 += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) userBalanceMa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "257-263",
    "vulnerableCode": [
      "uint256 counter3 =0;",
      "function callMe3() public{",
      "        require(counter3<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter3 += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) userBalanceMa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "267-275",
    "vulnerableCode": [
      "contract ChannelWallet is Ownable",
      "{",
      "  bool notCalledFlag = true;",
      "function resetNotCalledFlag() public{",
      "        require(notCalledFlag);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        notCalledFlag = false;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) userBalanceMa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "279-285",
    "vulnerableCode": [
      "  bool notCalledFlag2 = true;",
      "function resetNotCalledFlag2() public{",
      "        require(notCalledFlag2);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        notCalledFlag2 = false;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) userBalanceMa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "295-302",
    "vulnerableCode": [
      "  bool notCalledFlag3 = true;",
      "function resetNotCalledFlag3() public{",
      "        require(notCalledFlag3);",
      "        (bool success,)=msg.sender.call.value(1 ether)(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        notCalledFlag3 = false;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) userBalanceMa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "310-316",
    "vulnerableCode": [
      "address payable lastPlayer4;",
      "      uint jackpot4;",
      "      function buyTicket4() public{",
      "        if (!(lastPlayer4.send(jackpot4)))",
      "        revert();",
      "      lastPlayer4 = msg.sender;",
      "      jackpot4    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) userBalanceMa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "323-329",
    "vulnerableCode": [
      "uint256 counter4 =0;",
      "function callMe4() public{",
      "        require(counter4<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter4 += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) userBalanceMa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "340-346",
    "vulnerableCode": [
      "address payable lastPlayer5;",
      "      uint jackpot5;",
      "      function buyTicket5() public{",
      "        if (!(lastPlayer5.send(jackpot5)))",
      "        revert();",
      "      lastPlayer5 = msg.sender;",
      "      jackpot5    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) userBalanceMa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "376-382",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEtherMap4;",
      "function claimReward5() public {        ",
      "        require(redeemableEtherMap4[msg.sender] > 0);",
      "        uint transferValue = redeemableEtherMap4[msg.sender];",
      "        msg.sender.transfer(transferValue);   ",
      "        redeemableEtherMap4[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) userBalanceMa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "228-228",
    "vulnerableCode": [
      "if (tx.destination.call.value(tx.value)(tx.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.4;\n2: \n3: \n4: \n5: contract MultiSigWallet {\n6: \n7:     uint constant public"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "234-241",
    "vulnerableCode": [
      "playerPendingWithdrawals[msg.sender] = 0;",
      "if (msg.sender.call.value(withdrawAmount)()) {",
      "    return true;",
      "} else {",
      "    playerPendingWithdrawals[msg.sender] = withdrawAmount;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: contract MyDice is DSSafeAddSub {\n6: \n7:     \n8: \n9: \n10:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "156-161",
    "vulnerableCode": [
      "if(!pendingBets[i].bettorAddress.send(reward)){",
      "    LogResult(pendingBets[i].betID, pendingBets[i].bettorAddress, underNumber, randResult, reward, 2, pendingBets[i].betSize,underNumber);",
      "    playerPendingWithdrawals[pendingBets[i].bettorAddress] = safeAdd(playerPendingWithdrawals[pendingBets[i].bettorAddress], reward);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: contract MyDice is DSSafeAddSub {\n6: \n7:     \n8: \n9: \n10:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "189-192",
    "vulnerableCode": [
      "if(!pendingBets[i].bettorAddress.send(1)){",
      "    playerPendingWithdrawals[pendingBets[i].bettorAddress] = safeAdd(playerPendingWithdrawals[pendingBets[i].bettorAddress], 1);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: contract MyDice is DSSafeAddSub {\n6: \n7:     \n8: \n9: \n10:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "240-242",
    "vulnerableCode": [
      "playerPendingWithdrawals[msg.sender] = withdrawAmount;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: contract MyDice is DSSafeAddSub {\n6: \n7:     \n8: \n9: \n10:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "12-18",
    "vulnerableCode": [
      "  mapping(address => uint) userBalanceWithdrawable;",
      "function withdrawUserBalance() public{",
      "        if( ! (msg.sender.send(userBalanceWithdrawable[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalanceWithdrawable[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "29-33",
    "vulnerableCode": [
      "  mapping(address => uint) balancesWithdrawReusable;",
      "    function withdrawReusableBalances() public {",
      "       if (msg.sender.send(balancesWithdrawReusable[msg.sender ]))",
      "          balancesWithdrawReusable[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "35-42",
    "vulnerableCode": [
      "  uint256 counter =0;",
      "function callme() public{",
      "        require(counter<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "44-51",
    "vulnerableCode": [
      "  mapping(address => uint) userBalance;",
      "function withdrawUserBalanceInfo() public{",
      "        (bool success,)=msg.sender.call.value(userBalance[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "53-60",
    "vulnerableCode": [
      "  mapping(address => uint) userBalanceCheck;",
      "function withdrawCheckUserBalance() public{",
      "        (bool success,)= msg.sender.call.value(userBalanceCheck[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalanceCheck[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "71-78",
    "vulnerableCode": [
      "uint256 counterTwo =0;",
      "function callmeTwo() public{",
      "        require(counterTwo<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counterTwo += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "84-91",
    "vulnerableCode": [
      "address payable lastPlayer;",
      "      uint jackpot;",
      "      function buyTicket() public{",
      "        if (!(lastPlayer.send(jackpot)))",
      "        revert();",
      "      lastPlayer = msg.sender;",
      "      jackpot    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "97-103",
    "vulnerableCode": [
      "mapping(address => uint) balancesUserWithdraw;",
      "function withdrawUserFunds(uint256 _weiToWithdraw) public {",
      "        require(balancesUserWithdraw[msg.sender] >= _weiToWithdraw);",
      "        (bool success,)=msg.sender.call.value(_weiToWithdraw)(\"\");",
      "        require(success);  ",
      "        balancesUserWithdraw[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "127-134",
    "vulnerableCode": [
      "address payable lastPlayerCheck;",
      "      uint jackpotCheck;",
      "      function buyTicketCheck() public{",
      "        if (!(lastPlayerCheck.send(jackpotCheck)))",
      "        revert();",
      "      lastPlayerCheck = msg.sender;",
      "      jackpotCheck    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "140-146",
    "vulnerableCode": [
      "mapping(address => uint) balancesUserCheck;",
      "function withdrawUserFundsCheck(uint256 _weiToWithdraw) public {",
      "        require(balancesUserCheck[msg.sender] >= _weiToWithdraw);",
      "    (bool success,)= msg.sender.call.value(_weiToWithdraw)(\"\");",
      "        require(success);  ",
      "        balancesUserCheck[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "152-160",
    "vulnerableCode": [
      "address payable lastPlayerTransfer;",
      "      uint jackpotTransfer;",
      "      function buyTicketTransfer() public{",
      "        (bool success,) = lastPlayerTransfer.call.value(jackpotTransfer)(\"\");",
      "        if (!success)",
      "            revert();",
      "      lastPlayerTransfer = msg.sender;",
      "      jackpotTransfer    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "166-172",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEtherBalancesTransfer;",
      "function claimRewardTransfer() public {        ",
      "        require(redeemableEtherBalancesTransfer[msg.sender] > 0);",
      "        uint transferValueTransfer = redeemableEtherBalancesTransfer[msg.sender];",
      "        msg.sender.transfer(transferValueTransfer);   ",
      "        redeemableEtherBalancesTransfer[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "178-184",
    "vulnerableCode": [
      "mapping(address => uint) userBalanceTransfer;",
      "function withdrawUserBalanceTransfer() public{",
      "        if( ! (msg.sender.send(userBalanceTransfer[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalanceTransfer[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "190-197",
    "vulnerableCode": [
      "mapping(address => uint) userBalanceWithdrawal;",
      "function withdrawUserBalanceWithdrawal() public{",
      "        (bool success,)= msg.sender.call.value(userBalanceWithdrawal[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalanceWithdrawal[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "203-210",
    "vulnerableCode": [
      "bool notCalled = true;",
      "function resetCalled() public{",
      "        require(notCalled);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        notCalled = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "218-224",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEtherBalancesCheck;",
      "function claimRewardCheck() public {        ",
      "        require(redeemableEtherBalancesCheck[msg.sender] > 0);",
      "        uint transferValueCheck = redeemableEtherBalancesCheck[msg.sender];",
      "        msg.sender.transfer(transferValueCheck);   ",
      "        redeemableEtherBalancesCheck[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "232-237",
    "vulnerableCode": [
      "mapping(address => uint) balancesUserWithdrawCheck;",
      "function withdrawUserFundsCheck(uint256 _weiToWithdraw) public {",
      "        require(balancesUserWithdrawCheck[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balancesUserWithdrawCheck[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "257-264",
    "vulnerableCode": [
      "uint256 counterUser =0;",
      "function callmeUser() public{",
      "        require(counterUser<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counterUser += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "269-274",
    "vulnerableCode": [
      "  mapping(address => uint) balancesAccount;",
      "    function withdrawAccountBalances() public {",
      "       (bool success,) =msg.sender.call.value(balancesAccount[msg.sender ])(\"\");",
      "       if (success)",
      "          balancesAccount[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "276-283",
    "vulnerableCode": [
      "  bool notCalledAccount = true;",
      "function resetAccountCalled() public{",
      "        require(notCalledAccount);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        notCalledAccount = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "286-293",
    "vulnerableCode": [
      "  bool notCalledMaster = true;",
      "function resetMasterCalled() public{",
      "        require(notCalledMaster);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        notCalledMaster = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "295-300",
    "vulnerableCode": [
      "  mapping(address => uint) balancesAccountNew;",
      "function withdrawFundsAccountNew(uint256 _weiToWithdraw) public {",
      "        require(balancesAccountNew[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balancesAccountNew[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "302-310",
    "vulnerableCode": [
      "  bool notCalledUpdate = true;",
      "function resetUpdateCalled() public{",
      "        require(notCalledUpdate);",
      "        (bool success,)=msg.sender.call.value(1 ether)(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        notCalledUpdate = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "317-324",
    "vulnerableCode": [
      "address payable lastPlayerAccount;",
      "      uint jackpotAccount;",
      "      function buyTicketAccount() public{",
      "        if (!(lastPlayerAccount.send(jackpotAccount)))",
      "        revert();",
      "      lastPlayerAccount = msg.sender;",
      "      jackpotAccount    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "330-337",
    "vulnerableCode": [
      "uint256 counterAccount =0;",
      "function callmeAccount() public{",
      "        require(counterAccount<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counterAccount += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "348-355",
    "vulnerableCode": [
      "address payable lastPlayerAccountUpdate;",
      "      uint jackpotAccountUpdate;",
      "      function buyTicketAccountUpdate() public{",
      "        if (!(lastPlayerAccountUpdate.send(jackpotAccountUpdate)))",
      "        revert();",
      "      lastPlayerAccountUpdate = msg.sender;",
      "      jackpotAccountUpdate    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   mapping(address => uint) balancesWithd"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "445-446",
    "vulnerableCode": [
      "if (!sendTo.send(originalPlayerBetValue)) throw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.0;\n2: \n3: \n4: \n5: \n6: \n7: \n8: contract withAccounts is withOwners {\n9:   ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "17-23",
    "vulnerableCode": [
      "  mapping(address => uint) redeemableEther_32;",
      "function claimReward_32() public {        ",
      "        require(redeemableEther_32[msg.sender] > 0);",
      "        uint transferValue_32 = redeemableEther_32[msg.sender];",
      "        msg.sender.transfer(transferValue_32);   ",
      "        redeemableEther_32[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function receiveAppro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "32-38",
    "vulnerableCode": [
      "  mapping(address => uint) redeemableEther_4;",
      "function claimReward_4() public {        ",
      "        require(redeemableEther_4[msg.sender] > 0);",
      "        uint transferValue_4 = redeemableEther_4[msg.sender];",
      "        msg.sender.transfer(transferValue_4);   ",
      "        redeemableEther_4[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function receiveAppro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "41-48",
    "vulnerableCode": [
      "  uint256 counter_7 =0;",
      "function callcheck_7() public{",
      "        require(counter_7<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_7 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function receiveAppro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "131-136",
    "vulnerableCode": [
      "mapping(address => uint) balances_8;",
      "    function withdraw_balances_8 () public {",
      "       (bool success,) = msg.sender.call.value(balances_8[msg.sender ])(\"\");",
      "       if (success)",
      "          balances_8[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function receiveAppro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "144-150",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_39;",
      "function claimReward_39() public {        ",
      "        require(redeemableEther_39[msg.sender] > 0);",
      "        uint transferValue_39 = redeemableEther_39[msg.sender];",
      "        msg.sender.transfer(transferValue_39);   ",
      "        redeemableEther_39[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function receiveAppro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "158-162",
    "vulnerableCode": [
      "mapping(address => uint) balances_36;",
      "    function withdraw_balances_36 () public {",
      "       if (msg.sender.send(balances_36[msg.sender ]))",
      "          balances_36[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function receiveAppro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "173-180",
    "vulnerableCode": [
      "uint256 counter_35 =0;",
      "function callcheck_35() public{",
      "        require(counter_35<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_35 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function receiveAppro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "189-196",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_40;",
      "function withdrawBalance_40() public{",
      "        (bool success,)=msg.sender.call.value(userBalance_40[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_40[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function receiveAppro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "207-214",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_33;",
      "function withdrawBalance_33() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_33[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_33[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function receiveAppro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "367-367",
    "vulnerableCode": [
      "            if (_eth > 0)",
      "                plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract LastUnicorn is modularLastUnicorn {\n4:     using SafeMa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "395-395",
    "vulnerableCode": [
      "            if (_eth > 0)",
      "                plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract LastUnicorn is modularLastUnicorn {\n4:     using SafeMa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1029-1030",
    "vulnerableCode": [
      "        if (!address(TeamUnicorn).call.value(_com)(bytes4(keccak256(\"deposit()\"))))",
      "        {  "
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract LastUnicorn is modularLastUnicorn {\n4:     using SafeMa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1138-1139",
    "vulnerableCode": [
      "        if (!address(TeamUnicorn).call.value(_com)(bytes4(keccak256(\"deposit()\"))))",
      "        {  "
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract LastUnicorn is modularLastUnicorn {\n4:     using SafeMa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "188-193",
    "vulnerableCode": [
      "if(!pendingBets[i].bettorAddress.send(1)){",
      "playerPendingWithdrawals[pendingBets[i].bettorAddress] = safeAdd(playerPendingWithdrawals[pendingBets[i].bettorAddress], 1);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: contract MyDice75 is DSSafeAddSub {\n6: \n7:     \n8: \n9: \n1"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "21-21",
    "vulnerableCode": [
      "require(_releaseTime > block.timestamp);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract TokenTimelock {\n2:   using SafeERC20 for ERC20Basic;\n3: \n4:    \n5:   ERC20Ba"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "29-34",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_25;",
      "function claimReward_25() public {        ",
      "        require(redeemableEther_25[msg.sender] > 0);",
      "        uint transferValue_25 = redeemableEther_25[msg.sender];",
      "        msg.sender.transfer(transferValue_25);   ",
      "        redeemableEther_25[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: address payable lastPlayer_9;\n6: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "53-57",
    "vulnerableCode": [
      "mapping(address => uint) balances_36;",
      "    function withdraw_balances_36 () public {",
      "       if (msg.sender.send(balances_36[msg.sender ]))",
      "          balances_36[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: address payable lastPlayer_9;\n6: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "68-75",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_40;",
      "function withdrawBalance_40() public{",
      "        (bool success,)=msg.sender.call.value(userBalance_40[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_40[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: address payable lastPlayer_9;\n6: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "77-84",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_33;",
      "function withdrawBalance_33() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_33[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_33[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: address payable lastPlayer_9;\n6: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "86-92",
    "vulnerableCode": [
      "bool callcount_27 = true;",
      "function userbalances_27() public{",
      "        require(callcount_27);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcount_27 = false;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: address payable lastPlayer_9;\n6: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "95-100",
    "vulnerableCode": [
      "mapping(address => uint) balances_31;",
      "function withdrawFunds_31 (uint256 _weiToWithdraw) public {",
      "        require(balances_31[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_31[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: address payable lastPlayer_9;\n6: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "128-135",
    "vulnerableCode": [
      "bool callcount_20 = true;",
      "function userbalances_20() public{",
      "        require(callcount_20);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcount_20 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: address payable lastPlayer_9;\n6: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "148-154",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_32;",
      "function claimReward_32() public {        ",
      "        require(redeemableEther_32[msg.sender] > 0);",
      "        uint transferValue_32 = redeemableEther_32[msg.sender];",
      "        msg.sender.transfer(transferValue_32);   ",
      "        redeemableEther_32[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: address payable lastPlayer_9;\n6: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "170-175",
    "vulnerableCode": [
      "mapping(address => uint) balances_38;",
      "function withdrawFunds_38 (uint256 _weiToWithdraw) public {",
      "        require(balances_38[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_38[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: address payable lastPlayer_9;\n6: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "209-215",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_4;",
      "function claimReward_4() public {        ",
      "        require(redeemableEther_4[msg.sender] > 0);",
      "        uint transferValue_4 = redeemableEther_4[msg.sender];",
      "        msg.sender.transfer(transferValue_4);   ",
      "        redeemableEther_4[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: address payable lastPlayer_9;\n6: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "260-266",
    "vulnerableCode": [
      "address payable lastPlayer_23;",
      "      uint jackpot_23;",
      "      function buyTicket_23() public{",
      "        if (!(lastPlayer_23.send(jackpot_23)))",
      "        revert();",
      "      lastPlayer_23 = msg.sender;",
      "      jackpot_23    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: address payable lastPlayer_9;\n6: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "272-279",
    "vulnerableCode": [
      "uint256 counter_14 =0;",
      "function checking_14() public{",
      "        require(counter_14<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_14 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: address payable lastPlayer_9;\n6: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "284-290",
    "vulnerableCode": [
      "address payable lastPlayer_30;",
      "      uint jackpot_30;",
      "      function buyTicket_30() public{",
      "        if (!(lastPlayer_30.send(jackpot_30)))",
      "        revert();",
      "      lastPlayer_30 = msg.sender;",
      "      jackpot_30    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: address payable lastPlayer_9;\n6: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "296-301",
    "vulnerableCode": [
      "mapping(address => uint) balances_8;",
      "    function withdraw_balances_8 () public {",
      "       (bool success,) = msg.sender.call.value(balances_8[msg.sender ])(\"\");",
      "       if (success)",
      "          balances_8[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: address payable lastPlayer_9;\n6: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "308-314",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_39;",
      "function claimReward_39() public {        ",
      "        require(redeemableEther_39[msg.sender] > 0);",
      "        uint transferValue_39 = redeemableEther_39[msg.sender];",
      "        msg.sender.transfer(transferValue_39);   ",
      "        redeemableEther_39[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: contract WhiteBetting {\n5: address payable lastPlayer_9;\n6: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "202-206",
    "vulnerableCode": [
      "cap = 0;",
      "bonusCap = 1000000000000000000000000;",
      "minInvestmentValue = 0.02 ether;",
      "ethRaised = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: library SafeMath {\n9:   \n10: \n11: \n12:   fun"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "29-29",
    "vulnerableCode": [
      "  uint256 checkvaluev_5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   address winner_2;\n6: functi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "31-31",
    "vulnerableCode": [
      "  uint256 checkvaluev_1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   address winner_2;\n6: functi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "58-62",
    "vulnerableCode": [
      "address winner_19;",
      "function play_19(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_19 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   address winner_2;\n6: functi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "123-126",
    "vulnerableCode": [
      "address winner_38;",
      "function play_38(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_38 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   address winner_2;\n6: functi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "146-150",
    "vulnerableCode": [
      "address winner_7;",
      "function play_7(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_7 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   address winner_2;\n6: functi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "156-160",
    "vulnerableCode": [
      "address winner_23;",
      "function play_23(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_23 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   address winner_2;\n6: functi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "168-171",
    "vulnerableCode": [
      "address winner_14;",
      "function play_14(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_14 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   address winner_2;\n6: functi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "179-182",
    "vulnerableCode": [
      "address winner_30;",
      "function play_30(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_30 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   address winner_2;\n6: functi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "204-208",
    "vulnerableCode": [
      "address winner_39;",
      "function play_39(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_39 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   address winner_2;\n6: functi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "213-217",
    "vulnerableCode": [
      "  address winner_3;",
      "function play_3(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_3 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   address winner_2;\n6: functi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "220-222",
    "vulnerableCode": [
      "  uint256 checkvaluev_2 = block.timestamp;",
      "  event SetAddress(string channelId, address _address);",
      "  uint256 checkvaluev_3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   address winner_2;\n6: functi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "222-224",
    "vulnerableCode": [
      "  uint256 checkvaluev_3 = block.timestamp;",
      "  event UpdateAddress(string from, string to);",
      "  uint256 checkvaluev_4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   address winner_2;\n6: functi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "224-225",
    "vulnerableCode": [
      "  uint256 checkvaluev_4 = block.timestamp;",
      "  event DeleteAddress(string account);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   address winner_2;\n6: functi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "245-249",
    "vulnerableCode": [
      "address winner_35;",
      "function play_35(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_35 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   address winner_2;\n6: functi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "293-297",
    "vulnerableCode": [
      "address winner_27;",
      "function play_27(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_27 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.8;\n2: \n3: contract Ownable\n4: {\n5:   address winner_2;\n6: functi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1206-1206",
    "vulnerableCode": [
      "if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256(\"deposit()\"))))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1223-1223",
    "vulnerableCode": [
      "if (_p3d > 0) Divies.deposit.value(_p3d)();"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1320-1320",
    "vulnerableCode": [
      "if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256(\"deposit()\"))))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1353-1353",
    "vulnerableCode": [
      "Divies.deposit.value(_p3d)();"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "469-469",
    "vulnerableCode": [
      "_eth = withdrawEarnings(_pID);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "502-502",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "224-225",
    "vulnerableCode": [
      "if (!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))",
      "throw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.9;\n2: \n3: contract WalletLibrary is WalletEvents {\n4:   \n5: \n6:   \n7:   str"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "30-30",
    "vulnerableCode": [
      "require(_startTime >= now);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Crowdsale {\n2: \n3: \n4:   using SafeMath for uint256;\n5: \n6:    \n7:   GambioT"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "31-31",
    "vulnerableCode": [
      "require(_endTime >= _startTime);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Crowdsale {\n2: \n3: \n4:   using SafeMath for uint256;\n5: \n6:    \n7:   GambioT"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "348-348",
    "vulnerableCode": [
      "require(p.recipient.call.value(p.amount)(transactionBytecode));"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.13;\n2: \n3: library SafeMath {\n4:   function mul(uint256 a, uint256 b) inter"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "222-222",
    "vulnerableCode": [
      "if (!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.9;\n2: \n3: contract WalletLibrary is WalletEvents {\n4:   \n5: \n6:   \n7:   str"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "409-414",
    "vulnerableCode": [
      "_eth = withdrawEarnings(_pID);",
      "if (_eth > 0)",
      "    plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F3DPLUS is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "333-335",
    "vulnerableCode": [
      "reLoadCore(_pID, _affCode, _team, _eth, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F3DPLUS is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "296-298",
    "vulnerableCode": [
      "distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F3DPLUS is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1116-1153",
    "vulnerableCode": [
      "admin.transfer(_com);",
      "round_[_rID].pot = _pot.add(_p3d);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1259-1260",
    "vulnerableCode": [
      "if (!address(admin).call.value(_com)()) {"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1308-1308",
    "vulnerableCode": [
      "round_[_rID].pot = round_[_rID].pot.add(msg.value);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "313-313",
    "vulnerableCode": [
      "_customerAddress.transfer(_dividends);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: 1: pragma solidity ^0.4.21;\n2: 2: \n3: 3: \n4: 4: \n5: 5: \n6: 6: \n7: 7: \n8: 8: \n9: 9: \n10: 10: \n11:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "668-668",
    "vulnerableCode": [
      "msg.sender.transfer(excess);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: 1: pragma solidity ^0.4.21;\n2: 2: \n3: 3: \n4: 4: \n5: 5: \n6: 6: \n7: 7: \n8: 8: \n9: 9: \n10: 10: \n11:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "71-71",
    "vulnerableCode": [
      "  uint256 currentBlockTime1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uin"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "73-73",
    "vulnerableCode": [
      "  uint256 currentBlockTime2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uin"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "89-93",
    "vulnerableCode": [
      "  address winner_address11;",
      "function play_address11(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winner_address11 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uin"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "100-100",
    "vulnerableCode": [
      "  uint256 currentBlockTime3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uin"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "106-110",
    "vulnerableCode": [
      "address winner_address23;",
      "function play_address23(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winner_address23 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uin"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "116-116",
    "vulnerableCode": [
      "uint256 currentBlockTime4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uin"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "121-124",
    "vulnerableCode": [
      "address winner_address14;",
      "function play_address14(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_address14 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uin"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "131-134",
    "vulnerableCode": [
      "address winner_address30;",
      "function play_address30(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_address30 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uin"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "141-144",
    "vulnerableCode": [
      "  address winner_address2;",
      "function play_address2(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_address2 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uin"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "154-158",
    "vulnerableCode": [
      "  address winner_address3;",
      "function play_address3(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winner_address3 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uin"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "191-191",
    "vulnerableCode": [
      ""
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uin"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "195-198",
    "vulnerableCode": [
      "address winner_address39;",
      "function play_address39(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uin"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "222-226",
    "vulnerableCode": [
      "address winner_address35;",
      "function play_address35(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winner_address35 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uin"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "260-264",
    "vulnerableCode": [
      "address winner_address27;",
      "function play_address27(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winner_address27 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uin"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "273-277",
    "vulnerableCode": [
      "address winner_address31;",
      "function play_address31(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winner_address31 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uin"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "291-291",
    "vulnerableCode": [
      "uint256 currentBlockTime5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uin"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "361-361",
    "vulnerableCode": [
      "uint256 _now = now;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract F3DPLUS is modularShort {\n2:     using SafeMath for *;\n3:     using NameFilt"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "482-482",
    "vulnerableCode": [
      "uint256 _now = now;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract F3DPLUS is modularShort {\n2:     using SafeMath for *;\n3:     using NameFilt"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "522-522",
    "vulnerableCode": [
      "if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract F3DPLUS is modularShort {\n2:     using SafeMath for *;\n3:     using NameFilt"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "631-631",
    "vulnerableCode": [
      "uint256 _now = now;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract F3DPLUS is modularShort {\n2:     using SafeMath for *;\n3:     using NameFilt"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "681-681",
    "vulnerableCode": [
      "uint256 _now = now;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract F3DPLUS is modularShort {\n2:     using SafeMath for *;\n3:     using NameFilt"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "738-738",
    "vulnerableCode": [
      "uint256 _now = now;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract F3DPLUS is modularShort {\n2:     using SafeMath for *;\n3:     using NameFilt"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1031-1031",
    "vulnerableCode": [
      "round_[_rID].strt = now;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract F3DPLUS is modularShort {\n2:     using SafeMath for *;\n3:     using NameFilt"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1032-1032",
    "vulnerableCode": [
      "round_[_rID].end = now.add(rndInit_).add(rndGap_);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract F3DPLUS is modularShort {\n2:     using SafeMath for *;\n3:     using NameFilt"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1280-1281",
    "vulnerableCode": [
      "round_[1].strt = now + rndExtra_ - rndGap_;",
      "round_[1].end = now + rndInit_ + rndExtra_;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract F3DPLUS is modularShort {\n2:     using SafeMath for *;\n3:     using NameFilt"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1126-1126",
    "vulnerableCode": [
      "emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract F3DPLUS is modularShort {\n2:     using SafeMath for *;\n3:     using NameFilt"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "191-191",
    "vulnerableCode": [
      "(change > 0 && address(dest) == ETH_TOKEN_ADDRESS) ? msg.sender.transfer(change) : dest.safeTransfer(msg.sender, change);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity 0.5.4;\n2: \n3: library SafeMath {\n4:     \n5: \n6: \n7:     function mul(uint256 a, "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "197-259",
    "vulnerableCode": [
      "if (!p.recipient.call.value(p.amount)(_transactionData))",
      "throw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract DAO is DAOInterface, Token, TokenCreation {\n2: \n3:     \n4:     modifier onlyTokenholder"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "359-359",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract DogScam is modularDogScam {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1131-1131",
    "vulnerableCode": [
      "if (!address(DogKingCorp).call.value(_com)(bytes4(keccak256(\"deposit()\"))))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract DogScam is modularDogScam {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "92-101",
    "vulnerableCode": [
      "  mapping(address => uint) public lockTime_33;",
      "",
      "function increaseLockTime_33(uint _secondsToIncrease) public {",
      "        lockTime_33[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_33() public {",
      "        require(now > lockTime_33[msg.sender]);    ",
      "        uint transferValue_33 = 10;           ",
      "        msg.sender.transfer(transferValue_33);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint a"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "282-285",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_25;",
      "",
      "function increaseLockTime_25(uint _secondsToIncrease) public {",
      "        lockTime_25[msg.sender] += _secondsToIncrease;  "
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint a"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "305-310",
    "vulnerableCode": [
      "mapping(address => uint) balances_26;",
      "",
      "function transfer_26(address _to, uint _value) public returns (bool) {",
      "    require(balances_26[msg.sender] - _value >= 0);  ",
      "    balances_26[msg.sender] -= _value;  ",
      "    balances_26[_to] += _value;  "
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint a"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "337-342",
    "vulnerableCode": [
      "mapping(address => uint) balances_38;",
      "",
      "function transfer_38(address _to, uint _value) public returns (bool) {",
      "    require(balances_38[msg.sender] - _value >= 0);  ",
      "    balances_38[msg.sender] -= _value;  ",
      "    balances_38[_to] += _value;  "
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint a"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "99-99",
    "vulnerableCode": [
      "if (!founder.call.value(msg.value)()) throw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract FirstBloodToken is StandardToken, SafeMath {\n2: \n3:     string public name = \"FirstBloo"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "41-48",
    "vulnerableCode": [
      "  uint256 counter_limit =0;",
      "function callme_limit() public{",
      "        require(counter_limit<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_limit += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function receiveAppro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "99-106",
    "vulnerableCode": [
      "uint256 counter_limit2 =0;",
      "function callme_limit2() public{",
      "        require(counter_limit2<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_limit2 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function receiveAppro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "173-180",
    "vulnerableCode": [
      "uint256 counter_limit3 =0;",
      "function callme_limit3() public{",
      "        require(counter_limit3<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_limit3 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function receiveAppro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "290-312",
    "vulnerableCode": [
      "        withdraw();",
      "    }",
      "    function withdraw()",
      "        onlyStronghands()",
      "        public",
      "    {",
      "        address _customerAddress = msg.sender;",
      "        uint256 _dividends = myDividends(false);",
      "        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);",
      "        _dividends += referralBalance_[_customerAddress];",
      "        referralBalance_[_customerAddress] = 0;",
      "        _customerAddress.transfer(_dividends);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.21;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "73-82",
    "vulnerableCode": [
      "  mapping(address => uint) public lockTime9;",
      "",
      "function increaseLockTime9(uint _secondsToIncrease) public {",
      "        lockTime9[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdrawFunds9() public {",
      "        require(now > lockTime9[msg.sender]);    ",
      "        uint transferValue9 = 10;           ",
      "        msg.sender.transfer(transferValue9);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "87-96",
    "vulnerableCode": [
      "  mapping(address => uint) public lockTime25;",
      "",
      "function increaseLockTime25(uint _secondsToIncrease) public {",
      "        lockTime25[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdrawFunds25() public {",
      "        require(now > lockTime25[msg.sender]);    ",
      "        uint transferValue25 = 10;           ",
      "        msg.sender.transfer(transferValue25);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "156-162",
    "vulnerableCode": [
      "mapping(address => uint) balances14;",
      "",
      "function transfer14(address _to, uint _value) public returns (bool) {",
      "    require(balances14[msg.sender] - _value >= 0);  ",
      "    balances14[msg.sender] -= _value;  ",
      "    balances14[_to] += _value;  ",
      "    return true;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "168-174",
    "vulnerableCode": [
      "mapping(address => uint) balances30;",
      "",
      "function transfer30(address _to, uint _value) public returns (bool) {",
      "    require(balances30[msg.sender] - _value >= 0);  ",
      "    balances30[msg.sender] -= _value;  ",
      "    balances30[_to] += _value;  ",
      "    return true;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "229-235",
    "vulnerableCode": [
      "  mapping(address => uint) balances26;",
      "",
      "function transfer26(address _to, uint _value) public returns (bool) {",
      "    require(balances26[msg.sender] - _value >= 0);  ",
      "    balances26[msg.sender] -= _value;  ",
      "    balances26[_to] += _value;  ",
      "    return true;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "252-255",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime33;",
      "",
      "function increaseLockTime33(uint _secondsToIncrease) public {",
      "        lockTime33[msg.sender] += _secondsToIncrease;  "
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "291-294",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime13;",
      "",
      "function increaseLockTime13(uint _secondsToIncrease) public {",
      "        lockTime13[msg.sender] += _secondsToIncrease;  "
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "20-21",
    "vulnerableCode": [
      "uint public preIcoPhaseCountdown;",
      "uint public icoPhaseCountdown;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract TokenSale {\n2:   using SafeMath for uint256;\n3:   \n4:   EthertoteToken publi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "32-33",
    "vulnerableCode": [
      "uint public openingTime = 1535385600;",
      "uint public closingTime = openingTime.add(7 days);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract TokenSale {\n2:   using SafeMath for uint256;\n3:   \n4:   EthertoteToken publi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "98-98",
    "vulnerableCode": [
      "postIcoPhaseCountdown = closingTime.add(14 days);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract TokenSale {\n2:   using SafeMath for uint256;\n3:   \n4:   EthertoteToken publi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "192-201",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_37;",
      "",
      "function increaseLockTime_37(uint _secondsToIncrease) public {",
      "        lockTime_37[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_37() public {",
      "        require(now > lockTime_37[msg.sender]);    ",
      "        uint transferValue_37 = 10;           ",
      "        msg.sender.transfer(transferValue_37);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  function checkbalance"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "261-266",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_25;",
      "",
      "function increaseLockTime_25(uint _secondsToIncrease) public {",
      "        lockTime_25[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_25() public {"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  function checkbalance"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "283-290",
    "vulnerableCode": [
      "mapping(address => uint) balances_26;",
      "",
      "function transfer_26(address _to, uint _value) public returns (bool) {",
      "    require(balances_26[msg.sender] - _value >= 0);  ",
      "    balances_26[msg.sender] -= _value;  ",
      "    balances_26[_to] += _value;  ",
      "    return true;",
      "  }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  function checkbalance"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "303-307",
    "vulnerableCode": [
      "  mapping(address => uint) public lockTime_13;",
      "",
      "function increaseLockTime_13(uint _secondsToIncrease) public {",
      "        lockTime_13[msg.sender] += _secondsToIncrease;  ",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  function checkbalance"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "343-349",
    "vulnerableCode": [
      "mapping(address => uint) balances_38;",
      "",
      "function transfer_38(address _to, uint _value) public returns (bool) {",
      "    require(balances_38[msg.sender] - _value >= 0);  ",
      "    balances_38[msg.sender] -= _value;  ",
      "    balances_38[_to] += _value;  ",
      "    return true;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  function checkbalance"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "467-476",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_33;",
      "",
      "function increaseLockTime_33(uint _secondsToIncrease) public {",
      "        lockTime_33[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_33() public {",
      "        require(now > lockTime_33[msg.sender]);    ",
      "        uint transferValue_33 = 10;           ",
      "        msg.sender.transfer(transferValue_33);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  function checkbalance"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "367-367",
    "vulnerableCode": [
      "                plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract RatScam is modularRatScam {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "181-181",
    "vulnerableCode": [
      "        buyCore(_pID, _affID, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract RatScam is modularRatScam {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "257-257",
    "vulnerableCode": [
      "        reLoadCore(_pID, _affID, _eth, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract RatScam is modularRatScam {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "365-365",
    "vulnerableCode": [
      "            core(_pID, _eth, _affID, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract RatScam is modularRatScam {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1038-1038",
    "vulnerableCode": [
      "         if (!address(RatKingCorp).call.value(_com)(bytes4(keccak256(\"deposit()\"))))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract RatScam is modularRatScam {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1138-1138",
    "vulnerableCode": [
      "         if (!address(RatKingCorp).call.value(_com)(bytes4(keccak256(\"deposit()\"))))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract RatScam is modularRatScam {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "472-474",
    "vulnerableCode": [
      "if(!fundAddress_.call.value(ethToPay).gas(400000) {",
      "totalEthFundReceived = SafeMath.sub(totalEthFundReceived, ethToPay);",
      "}"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.25;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "136-140",
    "vulnerableCode": [
      "  mapping(address => uint) public lockTimeQuaternary;",
      "",
      "function increaseLockTimeQuaternary(uint _secondsToIncrease) public {",
      "        lockTimeQuaternary[msg.sender] += _secondsToIncrease;  ",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Owned {\n4:   mapping(address => uint) ba"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "6-6",
    "vulnerableCode": [
      "drawTime = block.timestamp + _duration;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract TimeBoundLottery {\n2:  uint256 public drawTime;\n3:  address[] public partici"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "110-110",
    "vulnerableCode": [
      "        Shares(withName, \"MLNF\", 18, now)"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Fund is DSMath, DBC, Owned, Shares, FundInterface {\n2: \n3:     event OrderUp"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "149-149",
    "vulnerableCode": [
      "            timestamp: now"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Fund is DSMath, DBC, Owned, Shares, FundInterface {\n2: \n3:     event OrderUp"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "206-206",
    "vulnerableCode": [
      "            timestamp: now,"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Fund is DSMath, DBC, Owned, Shares, FundInterface {\n2: \n3:     event OrderUp"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "339-340",
    "vulnerableCode": [
      "        exchangesToOpenMakeOrders[ofExchange][ofSellAsset].expiresAt = add(now, ORDER_EXPIRATION_TIME);",
      "    }"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Fund is DSMath, DBC, Owned, Shares, FundInterface {\n2: \n3:     event OrderUp"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "438-438",
    "vulnerableCode": [
      "        uint timePassed = sub(now, atLastUnclaimedFeeAllocation.timestamp);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Fund is DSMath, DBC, Owned, Shares, FundInterface {\n2: \n3:     event OrderUp"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "597-597",
    "vulnerableCode": [
      "        emit Redeemed(msg.sender, now, shareQuantity);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Fund is DSMath, DBC, Owned, Shares, FundInterface {\n2: \n3:     event OrderUp"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "319-319",
    "vulnerableCode": [
      "if (walletTransaction.destination.call.value(walletTransaction.value)(walletTransaction.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.15;\n2: \n3: \n4: \n5: \n6: \n7: \n8: contract RNTMultiSigWallet {\n9:     \n10: \n11"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "15-19",
    "vulnerableCode": [
      "}mapping(address => uint) userBalances;",
      "    function withdrawUserBalances() public {",
      "       if (msg.sender.send(userBalances[msg.sender ]))",
      "          userBalances[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.21 <0.6.0;\n2: \n3: contract ProofOfExistence {\n4: \n5: enum BlockchainIdenti"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "41-48",
    "vulnerableCode": [
      "uint256 callCount =0;",
      "function callme() public{",
      "        require(callCount<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        callCount += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.21 <0.6.0;\n2: \n3: contract ProofOfExistence {\n4: \n5: enum BlockchainIdenti"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "68-75",
    "vulnerableCode": [
      "mapping(address => uint) userBalanceWithdrawable;",
      "function withdrawUserBalanceWithdrawable() public{",
      "        (bool success,)=msg.sender.call.value(userBalanceWithdrawable[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalanceWithdrawable[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.21 <0.6.0;\n2: \n3: contract ProofOfExistence {\n4: \n5: enum BlockchainIdenti"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "86-93",
    "vulnerableCode": [
      "mapping(address => uint) userBalanceStorage;",
      "function withdrawUserBalanceStorage() public{",
      "        (bool success,)= msg.sender.call.value(userBalanceStorage[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalanceStorage[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.21 <0.6.0;\n2: \n3: contract ProofOfExistence {\n4: \n5: enum BlockchainIdenti"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "101-108",
    "vulnerableCode": [
      "bool isNotProcessed = true;",
      "function processStatus() public{",
      "        require(isNotProcessed);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        isNotProcessed = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.21 <0.6.0;\n2: \n3: contract ProofOfExistence {\n4: \n5: enum BlockchainIdenti"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "148-156",
    "vulnerableCode": [
      "bool isAlreadyProcessed = true;",
      "function processStatusTwo() public{",
      "        require(isAlreadyProcessed);",
      "        (bool success,)=msg.sender.call.value(1 ether)(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        isAlreadyProcessed = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.21 <0.6.0;\n2: \n3: contract ProofOfExistence {\n4: \n5: enum BlockchainIdenti"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "45-51",
    "vulnerableCode": [
      "mapping(address => uint) userBalance;",
      "function withdrawBalance() public{",
      "        if( ! (msg.sender.send(userBalance[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalance[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, uint256 b) in"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "57-64",
    "vulnerableCode": [
      "bool notCalled = true;",
      "function firstCall() public{",
      "        require(notCalled);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        notCalled = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, uint256 b) in"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "74-80",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther;",
      "function claimReward() public {        ",
      "        require(redeemableEther[msg.sender] > 0);",
      "        uint transferValue = redeemableEther[msg.sender];",
      "        msg.sender.transfer(transferValue);   ",
      "        redeemableEther[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, uint256 b) in"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "90-96",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEtherClaim;",
      "function claimRewardToken() public {        ",
      "        require(redeemableEtherClaim[msg.sender] > 0);",
      "        uint transferValueToken = redeemableEtherClaim[msg.sender];",
      "        msg.sender.transfer(transferValueToken);   ",
      "        redeemableEtherClaim[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, uint256 b) in"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "98-103",
    "vulnerableCode": [
      "mapping(address => uint) balances;",
      "    function withdrawBalanceTokens () public {",
      "       (bool success,) =msg.sender.call.value(balances[msg.sender])(\"\");",
      "       if (success)",
      "          balances[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, uint256 b) in"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "105-112",
    "vulnerableCode": [
      "bool notCalledSecond = true;",
      "function secondCall() public{",
      "        require(notCalledSecond);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        notCalledSecond = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, uint256 b) in"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "114-121",
    "vulnerableCode": [
      "uint256 counterCallFirst =0;",
      "function firstCounterCall() public{",
      "        require(counterCallFirst<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counterCallFirst += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, uint256 b) in"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "133-139",
    "vulnerableCode": [
      "mapping(address => uint) balancesAfter;",
      "function withdrawFundsAfter (uint256 _weiToWithdraw) public {",
      "        require(balancesAfter[msg.sender] >= _weiToWithdraw);",
      "        (bool success,)=msg.sender.call.value(_weiToWithdraw)(\"\");",
      "        require(success);  ",
      "        balancesAfter[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, uint256 b) in"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "142-149",
    "vulnerableCode": [
      "bool notCalledThird = true;",
      "function thirdCall() public{",
      "        require(notCalledThird);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        notCalledThird = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, uint256 b) in"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "152-157",
    "vulnerableCode": [
      "mapping(address => uint) balancesFourth;",
      "function withdrawFundsFourth (uint256 _weiToWithdraw) public {",
      "        require(balancesFourth[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balancesFourth[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, uint256 b) in"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "160-168",
    "vulnerableCode": [
      "bool notCalledFifth = true;",
      "function fifthCall() public{",
      "        require(notCalledFifth);",
      "        (bool success,)=msg.sender.call.value(1 ether)(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        notCalledFifth = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, uint256 b) in"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "177-182",
    "vulnerableCode": [
      "mapping(address => uint) balancesSixth;",
      "function withdrawFundsSixth (uint256 _weiToWithdraw) public {",
      "        require(balancesSixth[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balancesSixth[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, uint256 b) in"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "190-196",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEtherClaimed;",
      "function claimRewardClaimed() public {        ",
      "        require(redeemableEtherClaimed[msg.sender] > 0);",
      "        uint transferValueClaimed = redeemableEtherClaimed[msg.sender];",
      "        msg.sender.transfer(transferValueClaimed);   ",
      "        redeemableEtherClaimed[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, uint256 b) in"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "202-209",
    "vulnerableCode": [
      "uint256 counter =0;",
      "function sixthCall() public{",
      "        require(counter<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, uint256 b) in"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "217-224",
    "vulnerableCode": [
      "address payable lastPlayerTwo;",
      "      uint jackpotTwo;",
      "      function buyTicketTwo() public{",
      "        if (!(lastPlayerTwo.send(jackpotTwo)))",
      "        revert();",
      "      lastPlayerTwo = msg.sender;",
      "      jackpotTwo    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, uint256 b) in"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "232-239",
    "vulnerableCode": [
      "uint256 counterFive =0;",
      "function fifthFunction() public{",
      "        require(counterFive<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counterFive += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, uint256 b) in"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "249-255",
    "vulnerableCode": [
      "address payable lastPlayerThree;",
      "      uint jackpotThree;",
      "      function buyTicketThree() public{",
      "        if (!(lastPlayerThree.send(jackpotThree)))",
      "        revert();",
      "      lastPlayerThree = msg.sender;",
      "      jackpotThree    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, uint256 b) in"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "274-279",
    "vulnerableCode": [
      "mapping(address => uint) balancesEight;",
      "    function withdrawBalancesEight () public {",
      "       (bool success,) = msg.sender.call.value(balancesEight[msg.sender])(\"\");",
      "       if (success)",
      "          balancesEight[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, uint256 b) in"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "288-294",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEtherClaimed;",
      "function claimRewardClaimed() public {        ",
      "        require(redeemableEtherClaimed[msg.sender] > 0);",
      "        uint transferValueClaimed = redeemableEtherClaimed[msg.sender];",
      "        msg.sender.transfer(transferValueClaimed);   ",
      "        redeemableEtherClaimed[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, uint256 b) in"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "305-309",
    "vulnerableCode": [
      "mapping(address => uint) balancesThirtySix;",
      "    function withdrawBalancesThirtySix () public {",
      "       if (msg.sender.send(balancesThirtySix[msg.sender]))",
      "          balancesThirtySix[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, uint256 b) in"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "318-325",
    "vulnerableCode": [
      "uint256 counterThirtyFive =0;",
      "function thirtyFiveCall() public{",
      "        require(counterThirtyFive<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counterThirtyFive += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, uint256 b) in"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "334-341",
    "vulnerableCode": [
      "mapping(address => uint) userBalance;",
      "function withdrawBalance() public{",
      "        (bool success,)=msg.sender.call.value(userBalance[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, uint256 b) in"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "346-355",
    "vulnerableCode": [
      "mapping(address => uint) userBalanceThirtyThree;",
      "function withdrawBalanceThirtyThree() public{",
      "",
      "  ",
      "        (bool success,)= msg.sender.call.value(userBalanceThirtyThree[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalanceThirtyThree[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, uint256 b) in"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "222-222",
    "vulnerableCode": [
      "if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.23;\n2: \n3: \n4: \n5: \n6: \n7: \n8: contract NamiMultiSigWallet {\n9: \n10:     ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "73-78",
    "vulnerableCode": [
      "  mapping(address => uint) balancesSecondary;",
      "function withdrawFundsSecondary(uint256 _weiToWithdraw) public {",
      "        require(balancesSecondary[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balancesSecondary[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: contract CareerOnToken {\n4:   bool isNotCalledPauseStatus = true;"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "119-126",
    "vulnerableCode": [
      "address payable lastPlayer;",
      "      uint jackpot;",
      "      function buyTicket() public{",
      "        if (!(lastPlayer.send(jackpot)))",
      "        revert();",
      "      lastPlayer = msg.sender;",
      "      jackpot = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: contract CareerOnToken {\n4:   bool isNotCalledPauseStatus = true;"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "148-155",
    "vulnerableCode": [
      "uint256 counterFunction = 0;",
      "function functionCall() public{",
      "        require(counterFunction <= 5);",
      "        if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counterFunction += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: contract CareerOnToken {\n4:   bool isNotCalledPauseStatus = true;"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "16-16",
    "vulnerableCode": [
      " uint256 balancesv_2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  function balances_28 () p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "22-26",
    "vulnerableCode": [
      "address winner_3;",
      "function play_3(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_3 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  function balances_28 () p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "32-32",
    "vulnerableCode": [
      "uint256 balancesv_5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  function balances_28 () p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "85-88",
    "vulnerableCode": [
      "  address winner_34;",
      "function play_34(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_34 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  function balances_28 () p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "96-99",
    "vulnerableCode": [
      "  address winner_10;",
      "function play_10(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_10 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  function balances_28 () p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "101-104",
    "vulnerableCode": [
      "  address winner_22;",
      "function play_22(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_22 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  function balances_28 () p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "170-174",
    "vulnerableCode": [
      "address winner_19;",
      "function play_19(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_19 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  function balances_28 () p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "205-208",
    "vulnerableCode": [
      "address winner_26;",
      "function play_26(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_26 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  function balances_28 () p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "240-243",
    "vulnerableCode": [
      "address winner_38;",
      "function play_38(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_38 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  function balances_28 () p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "249-251",
    "vulnerableCode": [
      "uint256 balancesv_1 = block.timestamp;",
      "    ",
      "  uint256 balancesv_3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  function balances_28 () p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "254-254",
    "vulnerableCode": [
      "  uint256 balancesv_4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  function balances_28 () p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "282-286",
    "vulnerableCode": [
      "address winner_7;",
      "function play_7(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_7 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  function balances_28 () p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "291-295",
    "vulnerableCode": [
      "address winner_23;",
      "function play_23(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_23 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  function balances_28 () p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "301-304",
    "vulnerableCode": [
      "address winner_14;",
      "function play_14(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_14 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  function balances_28 () p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "335-339",
    "vulnerableCode": [
      "address winner_39;",
      "function play_39(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_39 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  function balances_28 () p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "360-364",
    "vulnerableCode": [
      "address winner_35;",
      "function play_35(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_35 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  function balances_28 () p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "399-403",
    "vulnerableCode": [
      "address winner_27;",
      "function play_27(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_27 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  function balances_28 () p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "412-416",
    "vulnerableCode": [
      "address winner_31;",
      "function play_31(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_31 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract Ownable {\n5:  function balances_28 () p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "37-37",
    "vulnerableCode": [
      "require(block.timestamp < _timestamp);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract DisbursementHandler is DisbursementHandlerI, Ownable {\n2:     using SafeMath"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "53-53",
    "vulnerableCode": [
      "require(disbursement.timestamp < now && disbursement.value > 0);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract DisbursementHandler is DisbursementHandlerI, Ownable {\n2:     using SafeMath"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "83-83",
    "vulnerableCode": [
      "latestUnstakeTime[msg.sender] = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract OperatorStaking is DBC {\n2: \n3:      \n4: \n5:     event Staked(address indexe"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "93-93",
    "vulnerableCode": [
      "pre_cond(block.timestamp >= latestUnstakeTime[msg.sender] + withdrawalDelay)"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract OperatorStaking is DBC {\n2: \n3:      \n4: \n5:     event Staked(address indexe"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "6-13",
    "vulnerableCode": [
      "  mapping(address => uint) userBalance_40;",
      "function withdrawBalance_40() public{",
      "        (bool success,)=msg.sender.call.value(userBalance_40[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_40[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   mapping(address => uint) us"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "20-27",
    "vulnerableCode": [
      "bool callcount_41 = true;",
      "function userbalances_41() public{",
      "        require(callcount_41);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcount_41 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   mapping(address => uint) us"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "34-40",
    "vulnerableCode": [
      "  mapping(address => uint) userBalance_12;",
      "function withdrawBalance_12() public{",
      "        if( ! (msg.sender.send(userBalance_12[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalance_12[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   mapping(address => uint) us"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "42-48",
    "vulnerableCode": [
      "  mapping(address => uint) redeemableEther_11;",
      "function claimReward_11() public {        ",
      "        require(redeemableEther_11[msg.sender] > 0);",
      "        uint transferValue_11 = redeemableEther_11[msg.sender];",
      "        msg.sender.transfer(transferValue_11);   ",
      "        redeemableEther_11[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   mapping(address => uint) us"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "51-58",
    "vulnerableCode": [
      "  mapping(address => uint) userBalance_33;",
      "function withdrawBalance_33() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_33[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_33[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   mapping(address => uint) us"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "67-73",
    "vulnerableCode": [
      "uint256 counter_42 =0;",
      "function callcheck_42() public{",
      "        require(counter_42<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_42 += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   mapping(address => uint) us"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "80-87",
    "vulnerableCode": [
      "address payable lastPlayer_2;",
      "      uint jackpot_2;",
      "      function buyTicket_2() public{",
      "        if (!(lastPlayer_2.send(jackpot_2)))",
      "        revert();",
      "      lastPlayer_2 = msg.sender;",
      "      jackpot_2    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   mapping(address => uint) us"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "95-101",
    "vulnerableCode": [
      "mapping(address => uint) balances_17;",
      "function withdrawFunds_17 (uint256 _weiToWithdraw) public {",
      "        require(balances_17[msg.sender] >= _weiToWithdraw);",
      "        (bool success,)=msg.sender.call.value(_weiToWithdraw)(\"\");",
      "        require(success);  ",
      "        balances_17[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   mapping(address => uint) us"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "108-115",
    "vulnerableCode": [
      "address payable lastPlayer_37;",
      "      uint jackpot_37;",
      "      function buyTicket_37() public{",
      "        if (!(lastPlayer_37.send(jackpot_37)))",
      "        revert();",
      "      lastPlayer_37 = msg.sender;",
      "      jackpot_37    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   mapping(address => uint) us"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "134-142",
    "vulnerableCode": [
      "address payable lastPlayer_9;",
      "      uint jackpot_9;",
      "      function buyTicket_9() public{",
      "        (bool success,) = lastPlayer_9.call.value(jackpot_9)(\"\");",
      "        if (!success)",
      "            revert();",
      "      lastPlayer_9 = msg.sender;",
      "      jackpot_9    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   mapping(address => uint) us"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "147-152",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_25;",
      "function claimReward_25() public {        ",
      "        require(redeemableEther_25[msg.sender] > 0);",
      "        uint transferValue_25 = redeemableEther_25[msg.sender];",
      "        msg.sender.transfer(transferValue_25);   ",
      "        redeemableEther_25[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   mapping(address => uint) us"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "158-163",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_19;",
      "function withdrawBalance_19() public{",
      "        if( ! (msg.sender.send(userBalance_19[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalance_19[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   mapping(address => uint) us"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "169-175",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_26;",
      "function withdrawBalance_26() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_26[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_26[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   mapping(address => uint) us"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "184-190",
    "vulnerableCode": [
      "  bool callcount_27 = true;",
      "function userbalances_27() public{",
      "        require(callcount_27);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcount_27 = false;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   mapping(address => uint) us"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "193-197",
    "vulnerableCode": [
      "  mapping(address => uint) balances_31;",
      "function withdrawFunds_31 (uint256 _weiToWithdraw) public {",
      "        require(balances_31[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_31[msg.sender] -= _weiToWithdraw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   mapping(address => uint) us"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "205-211",
    "vulnerableCode": [
      "bool callcount_20 = true;",
      "function userbalances_20() public{",
      "        require(callcount_20);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcount_20 = false;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   mapping(address => uint) us"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "217-222",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_32;",
      "function claimReward_32() public {        ",
      "        require(redeemableEther_32[msg.sender] > 0);",
      "        uint transferValue_32 = redeemableEther_32[msg.sender];",
      "        msg.sender.transfer(transferValue_32);   ",
      "        redeemableEther_32[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   mapping(address => uint) us"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "274-280",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_4;",
      "function claimReward_4() public {        ",
      "        require(redeemableEther_4[msg.sender] > 0);",
      "        uint transferValue_4 = redeemableEther_4[msg.sender];",
      "        msg.sender.transfer(transferValue_4);   ",
      "        redeemableEther_4[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   mapping(address => uint) us"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "373-380",
    "vulnerableCode": [
      "  bool callcount_13 = true;",
      "function userbalances_13() public{",
      "        require(callcount_13);",
      "        (bool success,)=msg.sender.call.value(1 ether)(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        callcount_13 = false;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   mapping(address => uint) us"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "408-414",
    "vulnerableCode": [
      "address payable lastPlayer_30;",
      "      uint jackpot_30;",
      "      function buyTicket_30() public{",
      "        if (!(lastPlayer_30.send(jackpot_30)))",
      "        revert();",
      "      lastPlayer_30 = msg.sender;",
      "      jackpot_30    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   mapping(address => uint) us"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "423-427",
    "vulnerableCode": [
      "mapping(address => uint) balances_8;",
      "    function withdraw_balances_8 () public {",
      "       (bool success,) = msg.sender.call.value(balances_8[msg.sender ])(\"\");",
      "       if (success)",
      "          balances_8[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   mapping(address => uint) us"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "435-440",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_39;",
      "function claimReward_39() public {        ",
      "        require(redeemableEther_39[msg.sender] > 0);",
      "        uint transferValue_39 = redeemableEther_39[msg.sender];",
      "        msg.sender.transfer(transferValue_39);   ",
      "        redeemableEther_39[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   mapping(address => uint) us"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "448-451",
    "vulnerableCode": [
      "mapping(address => uint) balances_36;",
      "    function withdraw_balances_36 () public {",
      "       if (msg.sender.send(balances_36[msg.sender ]))",
      "          balances_36[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   mapping(address => uint) us"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "459-465",
    "vulnerableCode": [
      "uint256 counter_35 =0;",
      "function callcheck_35() public{",
      "        require(counter_35<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_35 += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   mapping(address => uint) us"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "414-414",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract Fomo3H is modularShort {\n4:     using SafeMath for *;\n5"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1283-1283",
    "vulnerableCode": [
      "admin.transfer(_p3d.sub(_potAmount));"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract Fomo3H is modularShort {\n4:     using SafeMath for *;\n5"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1483-1484",
    "vulnerableCode": [
      "admin.transfer(_com);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract Fomo3H is modularShort {\n4:     using SafeMath for *;\n5"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "119-125",
    "vulnerableCode": [
      "function genericCall(address _contract, bytes memory _data, uint256 _value)",
      "public",
      "onlyOwner",
      "returns(bool success, bytes memory returnValue) {",
      "    (success, returnValue) = _contract.call.value(_value)(_data);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8:     \n9: \n10: \n11:     funct"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "270-270",
    "vulnerableCode": [
      "_customerAddress.transfer(_dividends);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.21;\n2: \n3: \n4: contract ProofofHumanity {\n5:     \n6: \n7: \n8:     \n9:     mo"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "74-74",
    "vulnerableCode": [
      "  uint256 balancesv_1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.9;\n2:                                                          "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "76-76",
    "vulnerableCode": [
      "  uint256 balancesv_2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.9;\n2:                                                          "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "97-97",
    "vulnerableCode": [
      "  uint256 balancesv_3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.9;\n2:                                                          "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "103-107",
    "vulnerableCode": [
      "address winner_3;",
      "function play_3(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_3 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.9;\n2:                                                          "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "113-113",
    "vulnerableCode": [
      "uint256 balancesv_5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.9;\n2:                                                          "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "222-222",
    "vulnerableCode": [
      "  uint256 balancesv_4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.9;\n2:                                                          "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "268-271",
    "vulnerableCode": [
      "address winner_26;",
      "function play_26(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_26 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.9;\n2:                                                          "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "350-354",
    "vulnerableCode": [
      "address winner_7;",
      "function play_7(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_7 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.9;\n2:                                                          "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "359-363",
    "vulnerableCode": [
      "address winner_23;",
      "function play_23(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_23 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.9;\n2:                                                          "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "369-372",
    "vulnerableCode": [
      "address winner_14;",
      "function play_14(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_14 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.9;\n2:                                                          "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "379-382",
    "vulnerableCode": [
      "address winner_30;",
      "function play_30(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_30 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.9;\n2:                                                          "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "402-406",
    "vulnerableCode": [
      "address winner_39;",
      "function play_39(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_39 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.9;\n2:                                                          "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "441-445",
    "vulnerableCode": [
      "address winner_35;",
      "function play_35(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_35 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.9;\n2:                                                          "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "494-498",
    "vulnerableCode": [
      "address winner_31;",
      "function play_31(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_31 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.9;\n2:                                                          "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "53-58",
    "vulnerableCode": [
      "  mapping(address => uint) balancesMappingTwo;",
      "function withdrawFunds (uint256 _weiToWithdraw) public {",
      "        require(balancesMappingTwo[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balancesMappingTwo[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 public totalSupply;"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "60-68",
    "vulnerableCode": [
      "  bool isNotCalledVariable = true;",
      "function actionOnNotCalled() public{",
      "        require(isNotCalledVariable);",
      "        (bool success,)=msg.sender.call.value(1 ether)(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        isNotCalledVariable = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 public totalSupply;"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "74-81",
    "vulnerableCode": [
      "  mapping(address => uint) userBalanceOne;",
      "function withdrawUserBalanceOne() public{",
      "        (bool success,)= msg.sender.call.value(userBalanceOne[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalanceOne[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 public totalSupply;"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "83-90",
    "vulnerableCode": [
      "  bool isNotCalledVariableTwo = true;",
      "function actionOnNotCalledTwo() public{",
      "        require(isNotCalledVariableTwo);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        isNotCalledVariableTwo = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 public totalSupply;"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "92-98",
    "vulnerableCode": [
      "  mapping(address => uint) redeemableEtherMapping;",
      "function claimReward() public {        ",
      "        require(redeemableEtherMapping[msg.sender] > 0);",
      "        uint transferValue = redeemableEtherMapping[msg.sender];",
      "        msg.sender.transfer(transferValue);   ",
      "        redeemableEtherMapping[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 public totalSupply;"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "100-105",
    "vulnerableCode": [
      "  mapping(address => uint) balancesMappingThree;",
      "function withdrawFundsThree (uint256 _weiToWithdraw) public {",
      "        require(balancesMappingThree[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balancesMappingThree[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 public totalSupply;"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "107-113",
    "vulnerableCode": [
      "  mapping(address => uint) redeemableEtherMappingTwo;",
      "function claimRewardTwo() public {        ",
      "        require(redeemableEtherMappingTwo[msg.sender] > 0);",
      "        uint transferValue = redeemableEtherMappingTwo[msg.sender];",
      "        msg.sender.transfer(transferValue);   ",
      "        redeemableEtherMappingTwo[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 public totalSupply;"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "123-129",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEtherMappingThree;",
      "function claimRewardThree() public {        ",
      "        require(redeemableEtherMappingThree[msg.sender] > 0);",
      "        uint transferValue = redeemableEtherMappingThree[msg.sender];",
      "        msg.sender.transfer(transferValue);   ",
      "        redeemableEtherMappingThree[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 public totalSupply;"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "138-142",
    "vulnerableCode": [
      "mapping(address => uint) balancesMappingFour;",
      "    function withdrawBalancesFour () public {",
      "       if (msg.sender.send(balancesMappingFour[msg.sender]))",
      "          balancesMappingFour[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 public totalSupply;"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "155-162",
    "vulnerableCode": [
      "uint256 counterCallLimitThree = 0;",
      "function callFunctionWithLimitThree() public{",
      "        require(counterCallLimitThree <= 5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counterCallLimitThree += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 public totalSupply;"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "167-174",
    "vulnerableCode": [
      "mapping(address => uint) userBalanceTwo;",
      "function withdrawBalanceTwo() public{",
      "        (bool success,)=msg.sender.call.value(userBalanceTwo[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalanceTwo[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 public totalSupply;"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "181-188",
    "vulnerableCode": [
      "mapping(address => uint) userBalanceThree;",
      "function withdrawBalanceThree() public{",
      "        (bool success,)= msg.sender.call.value(userBalanceThree[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalanceThree[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 public totalSupply;"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "193-200",
    "vulnerableCode": [
      "bool isNotCalledVariableThree = true;",
      "function actionOnNotCalledThree() public{",
      "        require(isNotCalledVariableThree);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        isNotCalledVariableThree = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: contract EIP20Interface {\n3:     uint256 public totalSupply;"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "143-147",
    "vulnerableCode": [
      "  address winner_15;",
      "function play_15(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_15 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "174-177",
    "vulnerableCode": [
      "  address winner_22;",
      "function play_22(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_22 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "189-193",
    "vulnerableCode": [
      "  address winner_11;",
      "function play_11(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_11 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "229-229",
    "vulnerableCode": [
      "uint256 balancesv_3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "235-235",
    "vulnerableCode": [
      "uint256 balancesv_4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "241-245",
    "vulnerableCode": [
      "address winner_3;",
      "function play_3(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_3 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "279-283",
    "vulnerableCode": [
      "address winner_19;",
      "function play_19(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_19 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "312-315",
    "vulnerableCode": [
      "address winner_26;",
      "function play_26(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_26 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "389-392",
    "vulnerableCode": [
      "address winner_38;",
      "function play_38(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_38 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "510-513",
    "vulnerableCode": [
      "address winner_14;",
      "function play_14(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_14 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "537-540",
    "vulnerableCode": [
      "address winner_30;",
      "function play_30(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_30 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "568-572",
    "vulnerableCode": [
      "address winner_39;",
      "function play_39(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_39 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "674-678",
    "vulnerableCode": [
      "address winner_27;",
      "function play_27(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_27 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "700-704",
    "vulnerableCode": [
      "address winner_31;",
      "function play_31(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_31 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "766-766",
    "vulnerableCode": [
      "uint256 balancesv_5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "804-804",
    "vulnerableCode": [
      "uint256 balancesv_1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "816-816",
    "vulnerableCode": [
      "uint256 balancesv_2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "49-51",
    "vulnerableCode": [
      "if(_addr.call.value(_wei)())",
      "Holders[_addr]-=_wei;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.19;\n2: \n3: contract TokenBank is Token\n4: {\n5:     uint public MinDeposit;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "128-131",
    "vulnerableCode": [
      "  mapping(address => uint) balances_31;",
      "function withdrawFunds_31 (uint256 _weiToWithdraw) public {",
      "        require(balances_31[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  "
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.9;\n2:                                                                     "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "139-145",
    "vulnerableCode": [
      "uint256 counter_42 =0;",
      "function update_42() public{",
      "        require(counter_42<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_42 += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.9;\n2:                                                                     "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "233-237",
    "vulnerableCode": [
      "  mapping(address => uint) balances_24;",
      "function withdrawFunds_24 (uint256 _weiToWithdraw) public {",
      "        require(balances_24[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_24[msg.sender] -= _weiToWithdraw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.9;\n2:                                                                     "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "299-308",
    "vulnerableCode": [
      "        burnPercent = 10; ",
      "        _startNewMiningEpoch();",
      "",
      "",
      "    }",
      "address payable lastPlayer_37;",
      "      uint jackpot_37;",
      "      function buyTicket_37() public{",
      "        if (!(lastPlayer_37.send(jackpot_37)))",
      "        revert();"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.9;\n2:                                                                     "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "64-64",
    "vulnerableCode": [
      "require(block.timestamp < games[_gameId].gameDate);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract BaseGameLogic is BaseGame {\n2: \n3:      \n4:     uint public prizeFund = 0;\n5"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "48-48",
    "vulnerableCode": [
      "            if(msg.sender.call.value(_am)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.19;\n2: \n3: contract PERSONAL_BANK\n4: {\n5:     mapping (address=>uint256) pu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1004-1004",
    "vulnerableCode": [
      "if (!address(admin).call.value(_com)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3DFAST is modularShort {\n4:     using SafeMath for "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "607-607",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3DFAST is modularShort {\n4:     using SafeMath for "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "425-427",
    "vulnerableCode": [
      "playerFundsToWithdraw[msg.sender] = 0;",
      "if (msg.sender.call.value(amount)()) {"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "268-272",
    "vulnerableCode": [
      "if(!playerTempAddress[myid].send(playerTempBetValue[myid])){",
      "LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempBetValue[myid], 4, proof);",
      "playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempBetValue[myid]);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.18;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "304-308",
    "vulnerableCode": [
      "if(!playerTempAddress[myid].send(playerTempReward[myid])){",
      "LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempReward[myid], 2, proof);",
      "playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempReward[myid]);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.18;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "336-339",
    "vulnerableCode": [
      "if(!playerTempAddress[myid].send(1)){",
      "playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], 1);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.18;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "447-448",
    "vulnerableCode": [
      "if(!sendTo.send(amount)) throw;",
      "LogOwnerTransfer(sendTo, amount);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.18;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "465-465",
    "vulnerableCode": [
      "if(!sendTo.send(originalPlayerBetValue)) throw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.18;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "223-223",
    "vulnerableCode": [
      "uint256 timeoutTimestamp = block.timestamp.add(calculateBaseTimeout()).add(bonusTime);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.19;\n2: \n3: \n4:  \n5: library SafeMath {\n6: \n7:    \n8:   function "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "267-267",
    "vulnerableCode": [
      "function canStart() public view returns (bool) {"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.19;\n2: \n3: \n4:  \n5: library SafeMath {\n6: \n7:    \n8:   function "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "240-240",
    "vulnerableCode": [
      "function calculateBaseTimeout() public view returns(uint256) {"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.19;\n2: \n3: \n4:  \n5: library SafeMath {\n6: \n7:    \n8:   function "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "68-68",
    "vulnerableCode": [
      "balances[tokenWallet] = saleCap;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract ZXCToken is StandardToken, Ownable {\n2:     using SafeMath for uint256;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "32-33",
    "vulnerableCode": [
      "if (tx.destination.call.value(tx.value)(tx.data)) {",
      "    tx.executed = true;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.11;\n2: \n3: \n4: contract MultiSigWallet is MultiSig {\n5:     function MultiS"
  },
  {
    "reason": "Invalid vulnerableLines format: l1-l2",
    "vulnerableCode": [
      "if (tx.destination.call.value(tx.value)(tx.data)) {",
      "    tx.executed = true;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.11;\n2: \n3: \n4: contract MultiSigWallet is MultiSig {\n5:     function MultiS"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "31-33",
    "vulnerableCode": [
      "modifier notTimeLocked() {",
      "if (now < timelockEndTime && msg.sender != addressSCICO && msg.sender != addressSCEscrow) {",
      "error('notTimeLocked: Timelock still active. Function is yet unavailable.');"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Tokens is HardcodedWallets, ERC20, Haltable {\n2: \n3: \t \n4: \n5: \tmapping (add"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "237-239",
    "vulnerableCode": [
      "block.timestamp < crowdsales[_token].closingTime,",
      "\"Failed to buy token due to crowdsale is closed.\""
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract IcoRocketFuel is Ownable {\n2: \n3:     using SafeMath for uint256;\n4: \n5:    "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "348-350",
    "vulnerableCode": [
      "block.timestamp >= crowdsales[_token].closingTime),",
      "\"Failed to finalize due to crowdsale is opening.\""
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract IcoRocketFuel is Ownable {\n2: \n3:     using SafeMath for uint256;\n4: \n5:    "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "42-42",
    "vulnerableCode": [
      "userChargeTime[_addr][_times] = ShowTime();"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Lockable is Ownable, SafeMath {\n2: \n3:      \n4:     mapping (address => uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "199-201",
    "vulnerableCode": [
      "if(!winner.send(games[gameId].CurrentTotal)){",
      "games[currentGameId].CurrentTotal = games[currentGameId].CurrentTotal.add(gameAmt);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.22;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "230-232",
    "vulnerableCode": [
      "if(!_playerAddr.send(_gamePlayerBalance)){",
      "playerPendingWithdrawals[_playerAddr] = playerPendingWithdrawals[_playerAddr].add(_gamePlayerBalance);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.22;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "310-312",
    "vulnerableCode": [
      "if (msg.sender.call.value(withdrawAmount)()) {",
      "return true;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.22;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "35-37",
    "vulnerableCode": [
      "if(msg.sender.call.value(_am)())",
      "balances[msg.sender]-=_am;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.19;\n2: \n3: contract ETH_VAULT\n4: {\n5:     mapping (address => uint) public "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "104-104",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "10-17",
    "vulnerableCode": [
      "bool callcount_41 = true;",
      "function userbalances_41() public{",
      "        require(callcount_41);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcount_41 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(uint a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "22-29",
    "vulnerableCode": [
      "uint256 counter_42 =0;",
      "function callcheck_42() public{",
      "        require(counter_42<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_42 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(uint a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "34-41",
    "vulnerableCode": [
      "address payable lastPlayer_2;",
      "      uint jackpot_2;",
      "      function buyTicket_2() public{",
      "        if (!(lastPlayer_2.send(jackpot_2)))",
      "        revert();",
      "      lastPlayer_2 = msg.sender;",
      "      jackpot_2    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(uint a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "46-52",
    "vulnerableCode": [
      "mapping(address => uint) balances_17;",
      "function withdrawFunds_17 (uint256 _weiToWithdraw) public {",
      "        require(balances_17[msg.sender] >= _weiToWithdraw);",
      "        (bool success,)=msg.sender.call.value(_weiToWithdraw)(\"\");",
      "        require(success);  ",
      "        balances_17[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(uint a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "110-117",
    "vulnerableCode": [
      "  bool callcount_27 = true;",
      "function userbalances_27() public{",
      "        require(callcount_27);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcount_27 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(uint a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "143-150",
    "vulnerableCode": [
      "  bool callcount_34 = true;",
      "function userbalances_34() public{",
      "        require(callcount_34);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcount_34 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(uint a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "152-159",
    "vulnerableCode": [
      "  uint256 counter_21 =0;",
      "function callcheck_21() public{",
      "        require(counter_21<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_21 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(uint a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "162-170",
    "vulnerableCode": [
      "  bool callcount_13 = true;",
      "function userbalances_13() public{",
      "        require(callcount_13);",
      "        (bool success,)=msg.sender.call.value(1 ether)(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        callcount_13 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(uint a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "176-182",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_32;",
      "function claimReward_32() public {        ",
      "        require(redeemableEther_32[msg.sender] > 0);",
      "        uint transferValue_32 = redeemableEther_32[msg.sender];",
      "        msg.sender.transfer(transferValue_32);   ",
      "        redeemableEther_32[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(uint a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "192-197",
    "vulnerableCode": [
      "mapping(address => uint) balances_38;",
      "function withdrawFunds_38 (uint256 _weiToWithdraw) public {",
      "        require(balances_38[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_38[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(uint a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "204-210",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_4;",
      "function claimReward_4() public {        ",
      "        require(redeemableEther_4[msg.sender] > 0);",
      "        uint transferValue_4 = redeemableEther_4[msg.sender];",
      "        msg.sender.transfer(transferValue_4);   ",
      "        redeemableEther_4[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(uint a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "215-220",
    "vulnerableCode": [
      "  mapping(address => uint) balances_10;",
      "function withdrawFunds_10 (uint256 _weiToWithdraw) public {",
      "        require(balances_10[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_10[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(uint a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "222-227",
    "vulnerableCode": [
      "  mapping(address => uint) balances_21;",
      "    function withdraw_balances_21 () public {",
      "       (bool success,)= msg.sender.call.value(balances_21[msg.sender ])(\"\");",
      "       if (success)",
      "          balances_21[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(uint a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "229-235",
    "vulnerableCode": [
      "  mapping(address => uint) userBalance_12;",
      "function withdrawBalance_12() public{",
      "        if( ! (msg.sender.send(userBalance_12[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalance_12[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(uint a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "264-271",
    "vulnerableCode": [
      "uint256 counter_7 =0;",
      "function callcheck_7() public{",
      "        require(counter_7<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_7 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(uint a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "277-284",
    "vulnerableCode": [
      "address payable lastPlayer_23;",
      "      uint jackpot_23;",
      "      function buyTicket_23() public{",
      "        if (!(lastPlayer_23.send(jackpot_23)))",
      "        revert();",
      "      lastPlayer_23 = msg.sender;",
      "      jackpot_23    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(uint a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "290-297",
    "vulnerableCode": [
      "uint256 counter_14 =0;",
      "function callcheck_14() public{",
      "        require(counter_14<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_14 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(uint a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "306-313",
    "vulnerableCode": [
      "address payable lastPlayer_30;",
      "      uint jackpot_30;",
      "      function buyTicket_30() public{",
      "        if (!(lastPlayer_30.send(jackpot_30)))",
      "        revert();",
      "      lastPlayer_30 = msg.sender;",
      "      jackpot_30    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(uint a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "321-326",
    "vulnerableCode": [
      "mapping(address => uint) balances_8;",
      "    function withdraw_balances_8 () public {",
      "       (bool success,) = msg.sender.call.value(balances_8[msg.sender ])(\"\");",
      "       if (success)",
      "          balances_8[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(uint a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "336-342",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_39;",
      "function claimReward_39() public {        ",
      "        require(redeemableEther_39[msg.sender] > 0);",
      "        uint transferValue_39 = redeemableEther_39[msg.sender];",
      "        msg.sender.transfer(transferValue_39);   ",
      "        redeemableEther_39[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(uint a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "348-352",
    "vulnerableCode": [
      "mapping(address => uint) balances_36;",
      "    function withdraw_balances_36 () public {",
      "       if (msg.sender.send(balances_36[msg.sender ]))",
      "          balances_36[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(uint a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "361-368",
    "vulnerableCode": [
      "uint256 counter_35 =0;",
      "function callcheck_35() public{",
      "        require(counter_35<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_35 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(uint a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "374-381",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_40;",
      "function withdrawBalance_40() public{",
      "        (bool success,)=msg.sender.call.value(userBalance_40[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_40[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(uint a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "387-394",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_33;",
      "function withdrawBalance_33() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_33[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_33[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(uint a, uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "74-74",
    "vulnerableCode": [
      "if (msg.sender.call.value(weiGiven[msg.sender])()) {"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract TokenCreation is TokenCreationInterface, Token {\n2:     function TokenCreation(\n3:     "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "55-64",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_sec1;",
      "",
      "function increaseLockTime_sec1(uint _secondsToIncrease) public {",
      "        lockTime_sec1[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_balance1() public {",
      "        require(now > lockTime_sec1[msg.sender]);    ",
      "        uint transferValue_sec1 = 10;           ",
      "        msg.sender.transfer(transferValue_sec1);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:   function mul(uint256 a"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "83-92",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_sec17;",
      "",
      "function increaseLockTime_sec17(uint _secondsToIncrease) public {",
      "        lockTime_sec17[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_balance17() public {",
      "        require(now > lockTime_sec17[msg.sender]);    ",
      "        uint transferValue_sec17 = 10;           ",
      "        msg.sender.transfer(transferValue_sec17);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:   function mul(uint256 a"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "98-107",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_sec37;",
      "",
      "function increaseLockTime_sec37(uint _secondsToIncrease) public {",
      "        lockTime_sec37[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_balance37() public {",
      "        require(now > lockTime_sec37[msg.sender]);    ",
      "        uint transferValue_sec37 = 10;           ",
      "        msg.sender.transfer(transferValue_sec37);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:   function mul(uint256 a"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "125-134",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_sec9;",
      "",
      "function increaseLockTime_sec9(uint _secondsToIncrease) public {",
      "        lockTime_sec9[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_balance9() public {",
      "        require(now > lockTime_sec9[msg.sender]);    ",
      "        uint transferValue_sec9 = 10;           ",
      "        msg.sender.transfer(transferValue_sec9);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:   function mul(uint256 a"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "145-154",
    "vulnerableCode": [
      "",
      "function increaseLockTime_sec25(uint _secondsToIncrease) public {",
      "        lockTime_sec25[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_balance25() public {",
      "        require(now > lockTime_sec25[msg.sender]);    ",
      "        uint transferValue_sec25 = 10;           ",
      "        msg.sender.transfer(transferValue_sec25);",
      "    }",
      "    function joinFixed() onlyOwner public{"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:   function mul(uint256 a"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "168-175",
    "vulnerableCode": [
      "mapping(address => uint) balances_main26;",
      "",
      "function transfer_balance26(address _to, uint _value) public returns (bool) {",
      "    require(balances_main26[msg.sender] - _value >= 0);  ",
      "    balances_main26[msg.sender] -= _value;  ",
      "    balances_main26[_to] += _value;  ",
      "    return true;",
      "  }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:   function mul(uint256 a"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "199-206",
    "vulnerableCode": [
      "mapping(address => uint) balances_main38;",
      "",
      "function transfer_balance38(address _to, uint _value) public returns (bool) {",
      "    require(balances_main38[msg.sender] - _value >= 0);  ",
      "    balances_main38[msg.sender] -= _value;  ",
      "    balances_main38[_to] += _value;  ",
      "    return true;",
      "  }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:   function mul(uint256 a"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "239-246",
    "vulnerableCode": [
      "mapping(address => uint) balances_main14;",
      "",
      "function transfer_balance14(address _to, uint _value) public returns (bool) {",
      "    require(balances_main14[msg.sender] - _value >= 0);  ",
      "    balances_main14[msg.sender] -= _value;  ",
      "    balances_main14[_to] += _value;  ",
      "    return true;",
      "  }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:   function mul(uint256 a"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "252-259",
    "vulnerableCode": [
      "mapping(address => uint) balances_main30;",
      "",
      "function transfer_balance30(address _to, uint _value) public returns (bool) {",
      "    require(balances_main30[msg.sender] - _value >= 0);  ",
      "    balances_main30[msg.sender] -= _value;  ",
      "    balances_main30[_to] += _value;  ",
      "    return true;",
      "  }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:   function mul(uint256 a"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "343-352",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_sec13;",
      "",
      "function increaseLockTime_sec13(uint _secondsToIncrease) public {",
      "        lockTime_sec13[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_balance13() public {",
      "        require(now > lockTime_sec13[msg.sender]);    ",
      "        uint transferValue_sec13 = 10;           ",
      "        msg.sender.transfer(transferValue_sec13);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:   function mul(uint256 a"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "22-29",
    "vulnerableCode": [
      "  bool notCalled = true; // changed from not_called_re_ent27",
      "function performCheck() public{ // changed from bug_re_ent27",
      "        require(notCalled);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        notCalled = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Owned {\n4:   address payable lastPlayer; // changed fro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "249-253",
    "vulnerableCode": [
      "mapping(address => uint) balances5; // changed from balances_re_ent8",
      "    function withdrawFunds5() public { // changed from withdraw_balances_re_ent8",
      "       (bool success,) = msg.sender.call.value(balances5[msg.sender])(\"\");",
      "       if (success)",
      "          balances5[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Owned {\n4:   address payable lastPlayer; // changed fro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "259-265",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther4; // changed from redeemableEther_re_ent39",
      "function claimReward4() public { // changed from claimReward_re_ent39 ",
      "        require(redeemableEther4[msg.sender] > 0);",
      "        uint transferValue4 = redeemableEther4[msg.sender]; // changed from transferValue_re_ent39",
      "        msg.sender.transfer(transferValue4);   ",
      "        redeemableEther4[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Owned {\n4:   address payable lastPlayer; // changed fro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "270-274",
    "vulnerableCode": [
      "mapping(address => uint) balances6; // changed from balances_re_ent36",
      "    function withdrawFunds6() public { // changed from withdraw_balances_re_ent36",
      "       if (msg.sender.send(balances6[msg.sender ]))",
      "          balances6[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Owned {\n4:   address payable lastPlayer; // changed fro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "280-286",
    "vulnerableCode": [
      "uint256 counter3 =0; // changed from counter_re_ent35",
      "function checkCallCount3() public{ // changed from callme_re_ent35",
      "        require(counter3<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter3 += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Owned {\n4:   address payable lastPlayer; // changed fro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "292-298",
    "vulnerableCode": [
      "mapping(address => uint) userBalance4; // changed from userBalance_re_ent40",
      "function withdrawBalance4() public{ // changed from withdrawBalance_re_ent40",
      "        (bool success,)=msg.sender.call.value(userBalance4[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance4[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Owned {\n4:   address payable lastPlayer; // changed fro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "306-312",
    "vulnerableCode": [
      "mapping(address => uint) userBalance5; // changed from userBalance_re_ent33",
      "function withdrawBalance5() public{ // changed from withdrawBalance_re_ent33",
      "        (bool success,)= msg.sender.call.value(userBalance5[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance5[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Owned {\n4:   address payable lastPlayer; // changed fro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "33-33",
    "vulnerableCode": [
      "require(_start > block.timestamp);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract TokenVesting is StandardToken,Ownable {\n2:   using SafeMath for uint256;\n3: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "77-87",
    "vulnerableCode": [
      "require(now < chronus.starting_time + chronus.betting_duration);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Betting {\n2:     using SafeMath for uint256;  \n3: \n4:     address public own"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "178-182",
    "vulnerableCode": [
      "playerBalance[msg.sender] = playerBalance[msg.sender].add(_playerDiv);",
      "playerBalance[msg.sender] = 0;",
      "msg.sender.transfer(_amount);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "106-106",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: 1: pragma solidity ^0.4.24;\n2: 2: \n3: 3: \n4: 4: contract SnowStorm is modularShort {\n5: 5:     u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "233-233",
    "vulnerableCode": [
      "_affID = plyr_[_pID].laff;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: 1: pragma solidity ^0.4.24;\n2: 2: \n3: 3: \n4: 4: contract SnowStorm is modularShort {\n5: 5:     u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "351-351",
    "vulnerableCode": [
      "_eth = withdrawEarnings(_pID).sub(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: 1: pragma solidity ^0.4.24;\n2: 2: \n3: 3: \n4: 4: contract SnowStorm is modularShort {\n5: 5:     u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1250-1250",
    "vulnerableCode": [
      "if (!address(admin).call.value(_com)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: 1: pragma solidity ^0.4.24;\n2: 2: \n3: 3: \n4: 4: contract SnowStorm is modularShort {\n5: 5:     u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1146-1146",
    "vulnerableCode": [
      "action.redistribution.value(_p3d).gas(1000000)();"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: 1: pragma solidity ^0.4.24;\n2: 2: \n3: 3: \n4: 4: contract SnowStorm is modularShort {\n5: 5:     u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "50-51",
    "vulnerableCode": [
      "uint public openingTime = 1535990400;",
      "uint public closingTime = openingTime.add(7 days);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract TokenSale {\n2:   using SafeMath for uint256;\n3:   \n4:   EthertoteToken publi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "371-371",
    "vulnerableCode": [
      "if (!address(admin).call.value(_com)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F3DPLUS is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "224-224",
    "vulnerableCode": [
      "_eth = withdrawEarnings(_pID);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F3DPLUS is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "414-414",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F3DPLUS is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "443-443",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F3DPLUS is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "11-11",
    "vulnerableCode": [
      "uint256 public levelEndDate;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract CrowdSale is Ownable {\n2:   using SafeMath for uint256;\n3:    \n4: \n5:   Toke"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "25-25",
    "vulnerableCode": [
      "levelEndDate = block.timestamp + (1 * 7 days);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract CrowdSale is Ownable {\n2:   using SafeMath for uint256;\n3:    \n4: \n5:   Toke"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "249-251",
    "vulnerableCode": [
      "function reinvest()",
      "    onlyStronghands()",
      "    public"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract Exchange {\n4:     \n5: \n6: \n7:     \n8:     modifier only"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "58-62",
    "vulnerableCode": [
      "address winnerAddress3;",
      "function playPeriod3(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress3 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "83-87",
    "vulnerableCode": [
      "address winnerAddress7;",
      "function playPeriod7(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress7 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "92-96",
    "vulnerableCode": [
      "address winnerAddress23;",
      "function playPeriod23(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress23 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "101-104",
    "vulnerableCode": [
      "address winnerAddress14;",
      "function playPeriod14(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerAddress14 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "277-281",
    "vulnerableCode": [
      "address winnerAddress31;",
      "function playPeriod31(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress31 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "299-299",
    "vulnerableCode": [
      "uint256 timestampValue5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "306-306",
    "vulnerableCode": [
      "uint256 timestampValue1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "311-311",
    "vulnerableCode": [
      "uint256 timestampValue2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "320-320",
    "vulnerableCode": [
      "uint256 timestampValue3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "327-327",
    "vulnerableCode": [
      "uint256 timestampValue4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1255-1255",
    "vulnerableCode": [
      "if (!address(admin1).call.value(_com.sub(_com / 2))())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract NewChance is modularShort {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1265-1265",
    "vulnerableCode": [
      "if (!address(admin2).call.value(_com / 2)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract NewChance is modularShort {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "415-415",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract NewChance is modularShort {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "444-444",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract NewChance is modularShort {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "234-235",
    "vulnerableCode": [
      "txn.executed = true;",
      "if (txn.destination.call.value(txn.value)(txn.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity 0.4.18;\n2: \n3: \n4: \n5: \n6: contract MultiSigWallet {\n7: \n8:     \n9: \n10: \n11:   "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "56-65",
    "vulnerableCode": [
      "  mapping(address => uint) public lockTime_safe13;",
      "",
      "function increaseLockTime_safe13(uint _secondsToIncrease) public {",
      "        lockTime_safe13[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_safe13() public {",
      "        require(now > lockTime_safe13[msg.sender]);    ",
      "        uint transferValue_safe13 = 10;           ",
      "        msg.sender.transfer(transferValue_safe13);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     functi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "78-84",
    "vulnerableCode": [
      "mapping(address => uint) balances_lock14;",
      "",
      "function transfer_lock14(address _to, uint _value) public returns (bool) {",
      "    require(balances_lock14[msg.sender] - _value >= 0);  ",
      "    balances_lock14[msg.sender] -= _value;  ",
      "    balances_lock14[_to] += _value;  ",
      "    return true;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     functi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "97-103",
    "vulnerableCode": [
      "mapping(address => uint) balances_lock30;",
      "",
      "function transfer_lock30(address _to, uint _value) public returns (bool) {",
      "    require(balances_lock30[msg.sender] - _value >= 0);  ",
      "    balances_lock30[msg.sender] -= _value;  ",
      "    balances_lock30[_to] += _value;  ",
      "    return true;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     functi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "172-181",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_safe33;",
      "",
      "function increaseLockTime_safe33(uint _secondsToIncrease) public {",
      "        lockTime_safe33[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_safe33() public {",
      "        require(now > lockTime_safe33[msg.sender]);    ",
      "        uint transferValue_safe33 = 10;           ",
      "        msg.sender.transfer(transferValue_safe33);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     functi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1-1",
    "vulnerableCode": [
      "pragma solidity ^0.5.11;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "124-124",
    "vulnerableCode": [
      "    "
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "296-299",
    "vulnerableCode": [
      "address winner_18;",
      "function play_18(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_18 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "313-316",
    "vulnerableCode": [
      "address winner_6;",
      "function play_6(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_6 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "381-385",
    "vulnerableCode": [
      "address winner_15;",
      "function play_15(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_15 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "413-416",
    "vulnerableCode": [
      "address winner_34;",
      "function play_34(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_34 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "440-443",
    "vulnerableCode": [
      "address winner_10;",
      "function play_10(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_10 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "449-452",
    "vulnerableCode": [
      "address winner_22;",
      "function play_22(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_22 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "486-490",
    "vulnerableCode": [
      "address winner_11;",
      "function play_11(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_11 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "538-541",
    "vulnerableCode": [
      "address winner_2;",
      "function play_2(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_2 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "597-601",
    "vulnerableCode": [
      "address winner_3;",
      "function play_3(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_3 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "678-678",
    "vulnerableCode": [
      "  uint256 checkvaluev_5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "686-690",
    "vulnerableCode": [
      "address winner_19;",
      "function play_19(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_19 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "700-703",
    "vulnerableCode": [
      "address winner_26;",
      "function play_26(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_26 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "735-738",
    "vulnerableCode": [
      "address winner_38;",
      "function play_38(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_38 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "758-758",
    "vulnerableCode": [
      "  uint256 checkvaluev_1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "760-760",
    "vulnerableCode": [
      "  uint256 checkvaluev_2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "768-772",
    "vulnerableCode": [
      "address winner_7;",
      "function play_7(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_7 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "782-786",
    "vulnerableCode": [
      "address winner_23;",
      "function play_23(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_23 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "791-794",
    "vulnerableCode": [
      "address winner_14;",
      "function play_14(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_14 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "799-802",
    "vulnerableCode": [
      "address winner_30;",
      "function play_30(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_30 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "822-826",
    "vulnerableCode": [
      "address winner_39;",
      "function play_39(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_39 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "831-831",
    "vulnerableCode": [
      "  uint256 checkvaluev_3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "835-835",
    "vulnerableCode": [
      "  uint256 checkvaluev_4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "911-915",
    "vulnerableCode": [
      "address winner_27;",
      "function play_27(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_27 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "921-925",
    "vulnerableCode": [
      "address winner_31;",
      "function play_31(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_31 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "414-414",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F3DLink is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "443-443",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F3DLink is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1148-1148",
    "vulnerableCode": [
      "admin.transfer(_com);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F3DLink is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1253-1253",
    "vulnerableCode": [
      "if (!address(admin).call.value(_com)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F3DLink is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1285-1285",
    "vulnerableCode": [
      "admin.transfer(_p3d.sub(_potAmount));"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F3DLink is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "169-169",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "265-265",
    "vulnerableCode": [
      "address(admin).call.value(_com)()"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "286-286",
    "vulnerableCode": [
      "round_[_rID].pot = round_[_rID].pot.add(msg.value);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "421-421",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: contract FoMoGame is modularLong {\n7:     using Safe"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "450-450",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: contract FoMoGame is modularLong {\n7:     using Safe"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1283-1283",
    "vulnerableCode": [
      "if (!address(Team_Forwarder).call.value(_com)(bytes4(keccak256(\"deposit()\"))))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: contract FoMoGame is modularLong {\n7:     using Safe"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1294-1294",
    "vulnerableCode": [
      "if(!address(Team_Forwarder).call.value(_p3d)(bytes4(keccak256(\"deposit()\"))))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: contract FoMoGame is modularLong {\n7:     using Safe"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "68-75",
    "vulnerableCode": [
      "mapping(address => uint) userBalances3;",
      "function withdrawBalance3() public{",
      "        (bool success,)=msg.sender.call.value(userBalances3[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalances3[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.10;\n2: \n3: contract TAMCContract {\n4:   uint256 callCounter1 = 0;\n5: functi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "77-85",
    "vulnerableCode": [
      "  bool notCalled1 = true;",
      "function firstFunction() public{",
      "        require(notCalled1);",
      "        (bool success,)=msg.sender.call.value(1 ether)(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        notCalled1 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.10;\n2: \n3: contract TAMCContract {\n4:   uint256 callCounter1 = 0;\n5: functi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "88-91",
    "vulnerableCode": [
      "  mapping(address => uint) userBalances4;",
      "    function withdraw_userBalances4() public {",
      "       if (msg.sender.send(userBalances4[msg.sender]))",
      "          userBalances4[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.10;\n2: \n3: contract TAMCContract {\n4:   uint256 callCounter1 = 0;\n5: functi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "103-110",
    "vulnerableCode": [
      "mapping(address => uint) userBalances5;",
      "function withdrawBalance5() public{",
      "        (bool success,)= msg.sender.call.value(userBalances5[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalances5[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.10;\n2: \n3: contract TAMCContract {\n4:   uint256 callCounter1 = 0;\n5: functi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "233-233",
    "vulnerableCode": [
      "if (tx.destination.call.value(tx.value)(tx.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity 0.4.8;\n2: \n3: \n4: \n5: \n6: contract MultiSigWallet {\n7: \n8:     uint constant pub"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "274-276",
    "vulnerableCode": [
      "transactions[transactionId] = Transaction({",
      "destination: destination,",
      "value: value,}"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity 0.4.8;\n2: \n3: \n4: \n5: \n6: contract MultiSigWallet {\n7: \n8:     uint constant pub"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "260-260",
    "vulnerableCode": [
      "if(!playerTempAddress[myid].send(playerTempBetValue[myid])){"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "72-80",
    "vulnerableCode": [
      "  address payable lastPlayerThird;",
      "      uint jackpotThird;",
      "      function buyTicketThird() public{",
      "        (bool success,) = lastPlayerThird.call.value(jackpotThird)(\"\");",
      "        if (!success)",
      "            revert();",
      "      lastPlayerThird = msg.sender;",
      "      jackpotThird    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: library SafeMath {\n4: \n5:     function sub(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "82-88",
    "vulnerableCode": [
      "  mapping(address => uint) redeemableEtherSixth;",
      "function claimRewardSixth() public {        ",
      "        require(redeemableEtherSixth[msg.sender] > 0);",
      "        uint transferValueSixth = redeemableEtherSixth[msg.sender];",
      "        msg.sender.transfer(transferValueSixth);   ",
      "        redeemableEtherSixth[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: library SafeMath {\n4: \n5:     function sub(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "90-96",
    "vulnerableCode": [
      "  mapping(address => uint) userBalance;",
      "function withdrawBalance() public{",
      "        if( ! (msg.sender.send(userBalance[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalance[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: library SafeMath {\n4: \n5:     function sub(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "102-107",
    "vulnerableCode": [
      "mapping(address => uint) balancesEight;",
      "    function withdrawBalances() public {",
      "       (bool success,) = msg.sender.call.value(balancesEight[msg.sender])(\"\");",
      "       if (success)",
      "          balancesEight[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: library SafeMath {\n4: \n5:     function sub(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "115-121",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEtherThird;",
      "function claimRewardThird() public {        ",
      "        require(redeemableEtherThird[msg.sender] > 0);",
      "        uint transferValueThird = redeemableEtherThird[msg.sender];",
      "        msg.sender.transfer(transferValueThird);   ",
      "        redeemableEtherThird[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: library SafeMath {\n4: \n5:     function sub(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "130-133",
    "vulnerableCode": [
      "mapping(address => uint) balancesForty;",
      "    function withdrawBalancesForty() public {",
      "       if (msg.sender.send(balancesForty[msg.sender]))",
      "          balancesForty[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: library SafeMath {\n4: \n5:     function sub(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "141-147",
    "vulnerableCode": [
      "uint256 counterFifth = 0;",
      "function callmeFifth() public{",
      "        require(counterFifth <= 5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counterFifth += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: library SafeMath {\n4: \n5:     function sub(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "153-159",
    "vulnerableCode": [
      "mapping(address => uint) userBalanceForty;",
      "function withdrawBalanceForty() public{",
      "        (bool success,) = msg.sender.call.value(userBalanceForty[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalanceForty[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: library SafeMath {\n4: \n5:     function sub(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "162-166",
    "vulnerableCode": [
      "  mapping(address => uint) balancesThirtyOne;",
      "function withdrawFundsProposed (uint256 _weiToWithdraw) public {",
      "        require(balancesThirtyOne[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balancesThirtyOne[msg.sender] -= _weiToWithdraw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: library SafeMath {\n4: \n5:     function sub(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "169-176",
    "vulnerableCode": [
      "  bool notCalled = true;",
      "function notCalledFunction() public{",
      "        require(notCalled);",
      "        (bool success,) = msg.sender.call.value(1 ether)(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        notCalled = false;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: library SafeMath {\n4: \n5:     function sub(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "182-188",
    "vulnerableCode": [
      "  mapping(address => uint) userBalanceTwentySix;",
      "function withdrawBalanceTwentySix() public{",
      "        (bool success,) = msg.sender.call.value(userBalanceTwentySix[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalanceTwentySix[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: library SafeMath {\n4: \n5:     function sub(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "191-197",
    "vulnerableCode": [
      "  bool notCalledSecond = true;",
      "function notCalledSecondFunction() public{",
      "        require(notCalledSecond);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        notCalledSecond = false;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: library SafeMath {\n4: \n5:     function sub(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "200-206",
    "vulnerableCode": [
      "  mapping(address => uint) redeemableEtherTwentyFive;",
      "function claimRewardTwentyFive() public {        ",
      "        require(redeemableEtherTwentyFive[msg.sender] > 0);",
      "        uint transferValueTwentyFive = redeemableEtherTwentyFive[msg.sender];",
      "        msg.sender.transfer(transferValueTwentyFive);   ",
      "        redeemableEtherTwentyFive[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: library SafeMath {\n4: \n5:     function sub(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "208-212",
    "vulnerableCode": [
      "  mapping(address => uint) balancesThirtyEight;",
      "function withdrawFundsThirtyEight (uint256 _weiToWithdraw) public {",
      "        require(balancesThirtyEight[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balancesThirtyEight[msg.sender] -= _weiToWithdraw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: library SafeMath {\n4: \n5:     function sub(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "222-228",
    "vulnerableCode": [
      "mapping(address => uint) userBalanceThirtyThree;",
      "function withdrawBalanceThirtyThree() public{",
      "        (bool success,) = msg.sender.call.value(userBalanceThirtyThree[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalanceThirtyThree[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: library SafeMath {\n4: \n5:     function sub(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "9-9",
    "vulnerableCode": [
      "uint256 creationTime = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: function isTimestampVal"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "73-73",
    "vulnerableCode": [
      "  uint256 creationTime1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: function isTimestampVal"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "76-76",
    "vulnerableCode": [
      "  uint256 creationTime2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: function isTimestampVal"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "79-79",
    "vulnerableCode": [
      "  uint256 creationTime3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: function isTimestampVal"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "207-207",
    "vulnerableCode": [
      "  uint256 creationTime2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: function isTimestampVal"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "233-237",
    "vulnerableCode": [
      "address winnerAddress35;",
      "function playWinner35(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress35 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: function isTimestampVal"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "267-271",
    "vulnerableCode": [
      "address winnerAddress27;",
      "function playWinner27(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress27 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: function isTimestampVal"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "277-281",
    "vulnerableCode": [
      "address winnerAddress31;",
      "function playWinner31(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress31 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: function isTimestampVal"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "302-414",
    "vulnerableCode": [
      "if (_eth > 0)",
      "    plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3DLightning is modularShort {\n4:     using SafeMath"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "194-171",
    "vulnerableCode": [
      "buyCore(_pID, _affCode, _team, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3DLightning is modularShort {\n4:     using SafeMath"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "14-14",
    "vulnerableCode": [
      "require(_releaseTime > uint64(block.timestamp));"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract TokenTimelock {\n2:     using SafeERC20 for ERC20Basic;\n3: \n4:      \n5:     E"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "57-59",
    "vulnerableCode": [
      "            if(msg.sender.call.value(_am)())",
      "            {",
      "                acc.balance-=_am;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.19;\n2: \n3: contract PENNY_BY_PENNY  \n4: {\n5:     struct Holder   \n6:     {\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "367-367",
    "vulnerableCode": [
      "uint256 _now = now;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Duang8 is modularShort {\n2:     using SafeMath for *;\n3:     using NameFilte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "403-403",
    "vulnerableCode": [
      "_eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Duang8 is modularShort {\n2:     using SafeMath for *;\n3:     using NameFilte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "506-506",
    "vulnerableCode": [
      "uint256 _now = now;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Duang8 is modularShort {\n2:     using SafeMath for *;\n3:     using NameFilte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "509-511",
    "vulnerableCode": [
      "if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))){",
      "return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Duang8 is modularShort {\n2:     using SafeMath for *;\n3:     using NameFilte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "525-525",
    "vulnerableCode": [
      "uint256 _now = now;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Duang8 is modularShort {\n2:     using SafeMath for *;\n3:     using NameFilte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "546-546",
    "vulnerableCode": [
      "if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Duang8 is modularShort {\n2:     using SafeMath for *;\n3:     using NameFilte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "864-864",
    "vulnerableCode": [
      "uint256 _now = now;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Duang8 is modularShort {\n2:     using SafeMath for *;\n3:     using NameFilte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "886-886",
    "vulnerableCode": [
      "if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Duang8 is modularShort {\n2:     using SafeMath for *;\n3:     using NameFilte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1320-1320",
    "vulnerableCode": [
      "_eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Duang8 is modularShort {\n2:     using SafeMath for *;\n3:     using NameFilte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1361-1361",
    "vulnerableCode": [
      "round_[1].strt = now + rndExtra_ - rndGap_;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Duang8 is modularShort {\n2:     using SafeMath for *;\n3:     using NameFilte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1362-1362",
    "vulnerableCode": [
      "round_[1].end = now + rndInit_ + rndExtra_;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Duang8 is modularShort {\n2:     using SafeMath for *;\n3:     using NameFilte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1056-1056",
    "vulnerableCode": [
      "round_[_rID].strt = now;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Duang8 is modularShort {\n2:     using SafeMath for *;\n3:     using NameFilte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1057-1057",
    "vulnerableCode": [
      "round_[_rID].end = now.add(rndInit_).add(rndGap_);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Duang8 is modularShort {\n2:     using SafeMath for *;\n3:     using NameFilte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1113-1113",
    "vulnerableCode": [
      "(block.timestamp).add"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Duang8 is modularShort {\n2:     using SafeMath for *;\n3:     using NameFilte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1155-1155",
    "vulnerableCode": [
      "((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Duang8 is modularShort {\n2:     using SafeMath for *;\n3:     using NameFilte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "66-66",
    "vulnerableCode": [
      "  uint256 currentBlockTimestamp5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "82-82",
    "vulnerableCode": [
      "  uint256 currentBlockTimestamp1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "290-293",
    "vulnerableCode": [
      "address winnerAddress30;",
      "function playAddress30(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerAddress30 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "315-319",
    "vulnerableCode": [
      "address winnerAddress39;",
      "function playAddress39(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress39 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "339-343",
    "vulnerableCode": [
      "address winnerAddress35;",
      "function playAddress35(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress35 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "376-380",
    "vulnerableCode": [
      "address winnerAddress27;",
      "function playAddress27(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress27 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "387-391",
    "vulnerableCode": [
      "address winnerAddress31;",
      "function playAddress31(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress31 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "393-393",
    "vulnerableCode": [
      "  uint256 currentBlockTimestamp2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "395-395",
    "vulnerableCode": [
      "  uint256 currentBlockTimestamp3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "397-397",
    "vulnerableCode": [
      "  uint256 currentBlockTimestamp4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "233-233",
    "vulnerableCode": [
      "if (tx.destination.call.value(tx.value)(tx.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity \"0.4.25\";\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: contract MultiSigWallet {\n11: \n12:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "227-228",
    "vulnerableCode": [
      "transactionId = addTransaction(destination, value, data);",
      "confirmTransaction(transactionId);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: library SafeMath {\n7:   function mul(uint a, uint b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "264-266",
    "vulnerableCode": [
      "transactions[transactionId].executed = true;",
      "if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: library SafeMath {\n7:   function mul(uint a, uint b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "177-177",
    "vulnerableCode": [
      "_finalizePreviousRoll(_user, _stats);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.23;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: interface IRegistry {\n12:     "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "192-192",
    "vulnerableCode": [
      "_stats.totalWon += _user.r_payout;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.23;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: interface IRegistry {\n12:     "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "248-248",
    "vulnerableCode": [
      "require(msg.sender.call.value(_user.r_payout)());"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.23;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: interface IRegistry {\n12:     "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "260-260",
    "vulnerableCode": [
      "require(msg.sender.call.value(msg.value)());"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.23;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: interface IRegistry {\n12:     "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "3-11",
    "vulnerableCode": [
      "contract CareerOnToken {",
      "  bool isFunctionNotCalled27 = true;",
      "function exampleFunction27() public {",
      "        require(isFunctionNotCalled27);",
      "        if ( !(msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        isFunctionNotCalled27 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: contract CareerOnToken {\n4:   bool isFunctionNotCalled27 = true;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "13-18",
    "vulnerableCode": [
      "  mapping(address => uint) balances31;",
      "function withdrawFunds31 (uint256 _weiToWithdraw) public {",
      "        require(balances31[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances31[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: contract CareerOnToken {\n4:   bool isFunctionNotCalled27 = true;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "20-28",
    "vulnerableCode": [
      "  bool isFunctionNotCalled13 = true;",
      "function exampleFunction13() public {",
      "        require(isFunctionNotCalled13);",
      "        (bool success,) = msg.sender.call.value(1 ether)(\"\");",
      "        if ( ! success ){",
      "            revert();",
      "        }",
      "        isFunctionNotCalled13 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: contract CareerOnToken {\n4:   bool isFunctionNotCalled27 = true;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "31-39",
    "vulnerableCode": [
      "  address payable lastPlayer9;",
      "      uint jackpot9;",
      "      function buyTicket9() public {",
      "        (bool success,) = lastPlayer9.call.value(jackpot9)(\"\");",
      "        if (!success)",
      "            revert();",
      "      lastPlayer9 = msg.sender;",
      "      jackpot9    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: contract CareerOnToken {\n4:   bool isFunctionNotCalled27 = true;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "41-47",
    "vulnerableCode": [
      "  mapping(address => uint) redeemableEther25;",
      "function claimReward25() public {        ",
      "        require(redeemableEther25[msg.sender] > 0);",
      "        uint transferValue25 = redeemableEther25[msg.sender];",
      "        msg.sender.transfer(transferValue25);   ",
      "        redeemableEther25[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: contract CareerOnToken {\n4:   bool isFunctionNotCalled27 = true;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "49-55",
    "vulnerableCode": [
      "  mapping(address => uint) userBalance19;",
      "function withdrawBalance19() public {",
      "        if ( !(msg.sender.send(userBalance19[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalance19[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: contract CareerOnToken {\n4:   bool isFunctionNotCalled27 = true;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "57-64",
    "vulnerableCode": [
      "  mapping(address => uint) userBalance26;",
      "function withdrawBalance26() public {",
      "        (bool success,) = msg.sender.call.value(userBalance26[msg.sender])(\"\");",
      "        if ( ! success ){",
      "            revert();",
      "        }",
      "        userBalance26[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: contract CareerOnToken {\n4:   bool isFunctionNotCalled27 = true;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "66-73",
    "vulnerableCode": [
      "  bool isFunctionNotCalled20 = true;",
      "function exampleFunction20() public {",
      "        require(isFunctionNotCalled20);",
      "        if ( !(msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        isFunctionNotCalled20 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: contract CareerOnToken {\n4:   bool isFunctionNotCalled27 = true;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "76-82",
    "vulnerableCode": [
      "  mapping(address => uint) redeemableEther32;",
      "function claimReward32() public {        ",
      "        require(redeemableEther32[msg.sender] > 0);",
      "        uint transferValue32 = redeemableEther32[msg.sender];",
      "        msg.sender.transfer(transferValue32);   ",
      "        redeemableEther32[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: contract CareerOnToken {\n4:   bool isFunctionNotCalled27 = true;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "84-89",
    "vulnerableCode": [
      "  mapping(address => uint) balances38;",
      "function withdrawFunds38 (uint256 _weiToWithdraw) public {",
      "        require(balances38[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances38[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: contract CareerOnToken {\n4:   bool isFunctionNotCalled27 = true;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "92-98",
    "vulnerableCode": [
      "  mapping(address => uint) redeemableEther4;",
      "function claimReward4() public {        ",
      "        require(redeemableEther4[msg.sender] > 0);",
      "        uint transferValue4 = redeemableEther4[msg.sender];",
      "        msg.sender.transfer(transferValue4);   ",
      "        redeemableEther4[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: contract CareerOnToken {\n4:   bool isFunctionNotCalled27 = true;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "150-157",
    "vulnerableCode": [
      "address payable lastPlayer23;",
      "      uint jackpot23;",
      "      function buyTicket23() public {",
      "        if (!(lastPlayer23.send(jackpot23)))",
      "        revert();",
      "      lastPlayer23 = msg.sender;",
      "      jackpot23    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: contract CareerOnToken {\n4:   bool isFunctionNotCalled27 = true;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "182-189",
    "vulnerableCode": [
      "uint256 counter14 =0;",
      "function callme14() public {",
      "        require(counter14<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter14 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: contract CareerOnToken {\n4:   bool isFunctionNotCalled27 = true;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "198-205",
    "vulnerableCode": [
      "address payable lastPlayer30;",
      "      uint jackpot30;",
      "      function buyTicket30() public {",
      "        if (!(lastPlayer30.send(jackpot30)))",
      "        revert();",
      "      lastPlayer30 = msg.sender;",
      "      jackpot30    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: contract CareerOnToken {\n4:   bool isFunctionNotCalled27 = true;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "213-218",
    "vulnerableCode": [
      "mapping(address => uint) balances8;",
      "    function withdraw_balances8 () public {",
      "       (bool success,) = msg.sender.call.value(balances8[msg.sender])(\"\");",
      "       if (success)",
      "          balances8[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: contract CareerOnToken {\n4:   bool isFunctionNotCalled27 = true;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "223-229",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther39;",
      "function claimReward39() public {        ",
      "        require(redeemableEther39[msg.sender] > 0);",
      "        uint transferValue39 = redeemableEther39[msg.sender];",
      "        msg.sender.transfer(transferValue39);   ",
      "        redeemableEther39[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: contract CareerOnToken {\n4:   bool isFunctionNotCalled27 = true;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "238-242",
    "vulnerableCode": [
      "mapping(address => uint) balances36;",
      "    function withdraw_balances36 () public {",
      "       if (msg.sender.send(balances36[msg.sender]))",
      "          balances36[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: contract CareerOnToken {\n4:   bool isFunctionNotCalled27 = true;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "248-255",
    "vulnerableCode": [
      "uint256 counter35 =0;",
      "function callme35() public {",
      "        require(counter35<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter35 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: contract CareerOnToken {\n4:   bool isFunctionNotCalled27 = true;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "262-269",
    "vulnerableCode": [
      "mapping(address => uint) userBalance40;",
      "function withdrawBalance40() public {",
      "        (bool success,) = msg.sender.call.value(userBalance40[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance40[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: contract CareerOnToken {\n4:   bool isFunctionNotCalled27 = true;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "275-282",
    "vulnerableCode": [
      "mapping(address => uint) userBalance33;",
      "function withdrawBalance33() public {",
      "        (bool success,) = msg.sender.call.value(userBalance33[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance33[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: contract CareerOnToken {\n4:   bool isFunctionNotCalled27 = true;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "134-137",
    "vulnerableCode": [
      "totalCoinSupply = SafeMath.add(totalCoinSupply, amount);",
      "balances[owner] = SafeMath.add(balances[owner], amount);",
      "setEditedFalse(owner);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: library SafeMath {\n2:   uint constant public MAX_UINT256 =\n3:     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "91-94",
    "vulnerableCode": [
      "  address winner1;",
      "function playFunction1(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner1 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "111-114",
    "vulnerableCode": [
      "address winner2;",
      "function playFunction2(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner2 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "119-122",
    "vulnerableCode": [
      "address winner3;",
      "function playFunction3(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner3 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "143-147",
    "vulnerableCode": [
      "address winner4;",
      "function playFunction4(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner4 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "203-207",
    "vulnerableCode": [
      "address winner6;",
      "function playFunction6(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner6 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "216-220",
    "vulnerableCode": [
      "address winner7;",
      "function playFunction7(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner7 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "249-249",
    "vulnerableCode": [
      "uint256 previousBlockTime7 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "254-254",
    "vulnerableCode": [
      "uint256 previousBlockTime8 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "259-259",
    "vulnerableCode": [
      "uint256 previousBlockTime9 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "264-264",
    "vulnerableCode": [
      "uint256 previousBlockTime10 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "279-279",
    "vulnerableCode": [
      "uint256 previousBlockTime11 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "48-48",
    "vulnerableCode": [
      "            if(msg.sender.call.value(_am)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.19;\n2: \n3: contract DEP_BANK \n4: {\n5:     mapping (address=>uint256) public"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "219-222",
    "vulnerableCode": [
      "if (block.timestamp <= endDiscountTime) {",
      "require(_value == 0.64 ether);",
      "} else {",
      "require(_value == 0.99 ether);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract TTPresale is AccessService {\n2:     TTCInterface ttcToken;\n3:     WarTokenIn"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "249-252",
    "vulnerableCode": [
      "if (block.timestamp <= endDiscountTime) {",
      "require(_value == 0.585 ether);",
      "} else {",
      "require(_value == 0.90 ether);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract TTPresale is AccessService {\n2:     TTCInterface ttcToken;\n3:     WarTokenIn"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "375-375",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract GameOfSwords is modularLong {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "619-619",
    "vulnerableCode": [
      "if (!address(admin).call.value(_com)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract GameOfSwords is modularLong {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "230-230",
    "vulnerableCode": [
      "if (tx.destination.call.value(tx.value)(tx.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.15;\n2: \n3: \n4: \n5: \n6: \n7: contract MultiSigWallet {\n8: \n9:     uint consta"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "65-65",
    "vulnerableCode": [
      "require(_startTime >= block.timestamp);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract TokenOffering is StandardToken, Ownable, BurnableToken {\n2:   \n3:     bool p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "139-140",
    "vulnerableCode": [
      "bool fromIsAffiliate = affiliateList.inListAsOf(_from, block.timestamp);",
      "bool toIsAffiliate = affiliateList.inListAsOf(_to, block.timestamp);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract SecurityController is ISecurityController, Ownable {\n2:     ISecurityLedger "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "445-446",
    "vulnerableCode": [
      "if (!Token(token).transfer(msg.sender, amount)) throw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.10;\n2: \n3: contract CDEXv1 is SafeMath {\n4:   address public admin; \n5:   a"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "97-99",
    "vulnerableCode": [
      "require(block.timestamp >= releaseTime);",
      "require(fundingLowcapReached == true);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract ATTRToken is CappedToken, DetailedERC20 {\n2: \n3:   using SafeMath for uint25"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "33-33",
    "vulnerableCode": [
      "require(block.timestamp >= releaseTime);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract DQCoin is ERC20 {\n2: \n3:     using SafeMath for uint256;\n4: \n5:     address "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "227-228",
    "vulnerableCode": [
      "tx.executed = true;",
      "if (tx.destination.call.value(tx.value)(tx.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.11;\n2: \n3: \n4: \n5: \n6: contract MultiSigWallet {\n7: \n8:     uint constant p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1212-1212",
    "vulnerableCode": [
      "if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256(\"deposit()\"))))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1229-1229",
    "vulnerableCode": [
      "Divies.deposit.value(_p3d)();"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "476-477",
    "vulnerableCode": [
      "if (_eth > 0)",
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "45-54",
    "vulnerableCode": [
      "  mapping(address => uint) public lockTime1;",
      "",
      "function increaseLockTime1(uint _secondsToIncrease) public {",
      "        lockTime1[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdrawLockTime1() public {",
      "        require(now > lockTime1[msg.sender]);    ",
      "        uint transferValue1 = 10;           ",
      "        msg.sender.transfer(transferValue1);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   function rep"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "63-72",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime2;",
      "",
      "function increaseLockTime2(uint _secondsToIncrease) public {",
      "        lockTime2[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdrawLockTime2() public {",
      "        require(now > lockTime2[msg.sender]);    ",
      "        uint transferValue2 = 10;           ",
      "        msg.sender.transfer(transferValue2);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   function rep"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "78-84",
    "vulnerableCode": [
      "mapping(address => uint) tempBalances3;",
      "",
      "function transferTempBal3(address _to, uint _value) public returns (bool) {",
      "    require(tempBalances3[msg.sender] - _value >= 0);  ",
      "    tempBalances3[msg.sender] -= _value;  ",
      "    tempBalances3[_to] += _value;  ",
      "    return true;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   function rep"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "93-102",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime3;",
      "",
      "function increaseLockTime3(uint _secondsToIncrease) public {",
      "        lockTime3[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdrawLockTime3() public {",
      "        require(now > lockTime3[msg.sender]);    ",
      "        uint transferValue3 = 10;           ",
      "        msg.sender.transfer(transferValue3);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   function rep"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "109-118",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime4;",
      "",
      "function increaseLockTime4(uint _secondsToIncrease) public {",
      "        lockTime4[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdrawLockTime4() public {",
      "        require(now > lockTime4[msg.sender]);    ",
      "        uint transferValue4 = 10;           ",
      "        msg.sender.transfer(transferValue4);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   function rep"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "350-359",
    "vulnerableCode": [
      "  mapping(address => uint) public lockTime7;",
      "",
      "function increaseLockTime7(uint _secondsToIncrease) public {",
      "        lockTime7[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdrawLockTime7() public {",
      "        require(now > lockTime7[msg.sender]);    ",
      "        uint transferValue7 = 10;           ",
      "        msg.sender.transfer(transferValue7);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   function rep"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "265-266",
    "vulnerableCode": [
      "if (tx.destination.call.value(tx.value)(tx.data))",
      "Execution(transactionId);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.11;\n2: \n3: \n4: \n5: \n6: \n7: \n8: library SafeMath {\n9:   function mul(uint256"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "241-241",
    "vulnerableCode": [
      "executeTransaction(transactionId);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.11;\n2: \n3: \n4: \n5: \n6: \n7: \n8: library SafeMath {\n9:   function mul(uint256"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "325-325",
    "vulnerableCode": [
      "_customerAddress.transfer(_dividends);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.21;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "10-10",
    "vulnerableCode": [
      "require(block.timestamp >= openingTime && block.timestamp <= closingTime);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract TimedCrowdsale is Crowdsale {\n2:   using SafeMath for uint256;\n3: \n4:   uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "182-182",
    "vulnerableCode": [
      "_wasRefundSuccess = _prevMonarch.send(msg.value);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.23;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "254-256",
    "vulnerableCode": [
      "_paySuccessful = _winner.call.value(_prize)();",
      "_paySuccessful = _winner.call.value(_prize).gas(_gasLimit)();"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.23;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "289-289",
    "vulnerableCode": [
      "require(settings.collector.call.value(_feesSent)());"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.23;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "218-228",
    "vulnerableCode": [
      "if (tx.destination.call.value(tx.value)(tx.data))",
      "tx.executed = true;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.16;\n2: \n3: \n4: \n5: contract MultiSigWallet {\n6: \n7:     uint constant publi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "24-24",
    "vulnerableCode": [
      "modifier onlyWhileOpen { require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; }"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract BitSongCrowdsale is Ownable{\n2:   using SafeMath for uint256;\n3:   using Saf"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "113-115",
    "vulnerableCode": [
      "if (endAt_ > block.timestamp) {",
      "endAt = endAt_;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract BaseICO is Ownable, Whitelisted {\n2: \n3:      \n4:     enum State {\n5: \n6:   "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "342-350",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_9;",
      "",
      "function increaseLockTime_9(uint _secondsToIncrease) public {",
      "        lockTime_9[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_9() public {",
      "        require(now > lockTime_9[msg.sender]);    ",
      "        uint transferValue_9 = 10;           ",
      "        msg.sender.transfer(transferValue_9);"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "421-427",
    "vulnerableCode": [
      "mapping(address => uint) balances_26;",
      "",
      "function transfer_26(address _to, uint _value) public returns (bool) {",
      "    require(balances_26[msg.sender] - _value >= 0);  ",
      "    balances_26[msg.sender] -= _value;  ",
      "    balances_26[_to] += _value;  ",
      "    return true;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "614-620",
    "vulnerableCode": [
      "mapping(address => uint) balances_30;",
      "",
      "function transfer_30(address _to, uint _value) public returns (bool) {",
      "    require(balances_30[msg.sender] - _value >= 0);  ",
      "    balances_30[msg.sender] -= _value;  ",
      "    balances_30[_to] += _value;  ",
      "    return true;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "779-788",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_33;",
      "",
      "function increaseLockTime_33(uint _secondsToIncrease) public {",
      "        lockTime_33[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_33() public {",
      "        require(now > lockTime_33[msg.sender]);    ",
      "        uint transferValue_33 = 10;           ",
      "        msg.sender.transfer(transferValue_33);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "72-80",
    "vulnerableCode": [
      "  bool balance_checking_13 = true;",
      "function update_13() public{",
      "        require(balance_checking_13);",
      "        (bool success,)=msg.sender.call.value(1 ether)(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        balance_checking_13 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, uint256 valu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "83-90",
    "vulnerableCode": [
      "  bool balance_checking_41 = true;",
      "function update_41() public{",
      "        require(balance_checking_41);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        balance_checking_41 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, uint256 valu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "93-100",
    "vulnerableCode": [
      "  uint256 counter_42 =0;",
      "function checking_42() public{",
      "        require(counter_42<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_42 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, uint256 valu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "113-119",
    "vulnerableCode": [
      "  mapping(address => uint) balances_17;",
      "function withdrawFunds_17 (uint256 _weiToWithdraw) public {",
      "        require(balances_17[msg.sender] >= _weiToWithdraw);",
      "        (bool success,)=msg.sender.call.value(_weiToWithdraw)(\"\");",
      "        require(success);  ",
      "        balances_17[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, uint256 valu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "149-156",
    "vulnerableCode": [
      "uint256 counter_7 =0;",
      "function checking_7() public{",
      "        require(counter_7<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_7 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, uint256 valu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "169-175",
    "vulnerableCode": [
      "  mapping(address => uint) balances_3;",
      "function withdrawFunds_3 (uint256 _weiToWithdraw) public {",
      "        require(balances_3[msg.sender] >= _weiToWithdraw);",
      "    (bool success,)= msg.sender.call.value(_weiToWithdraw)(\"\");",
      "        require(success);  ",
      "        balances_3[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, uint256 valu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "178-185",
    "vulnerableCode": [
      "  address payable lastPlayer_9;",
      "      uint jackpot_9;",
      "      function buyTicket_9() public{",
      "        (bool success,) = lastPlayer_9.call.value(jackpot_9)(\"\");",
      "        if (!success)",
      "            revert();",
      "      lastPlayer_9 = msg.sender;",
      "      jackpot_9    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, uint256 valu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "198-204",
    "vulnerableCode": [
      "   mapping(address => uint) userBalance_19;",
      "function withdrawBalance_19() public{",
      "        if( ! (msg.sender.send(userBalance_19[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalance_19[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, uint256 valu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "227-233",
    "vulnerableCode": [
      "address payable lastPlayer_23;",
      "      uint jackpot_23;",
      "      function buyTicket_23() public{",
      "        if (!(lastPlayer_23.send(jackpot_23)))",
      "        revert();",
      "      lastPlayer_23 = msg.sender;",
      "      jackpot_23    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, uint256 valu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "258-264",
    "vulnerableCode": [
      "address payable lastPlayer_30;",
      "      uint jackpot_30;",
      "      function buyTicket_30() public{",
      "        if (!(lastPlayer_30.send(jackpot_30)))",
      "        revert();",
      "      lastPlayer_30 = msg.sender;",
      "      jackpot_30    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, uint256 valu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "277-282",
    "vulnerableCode": [
      "mapping(address => uint) balances_8;",
      "    function withdraw_balances_8 () public {",
      "       (bool success,) = msg.sender.call.value(balances_8[msg.sender ])(\"\");",
      "       if (success)",
      "          balances_8[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, uint256 valu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "305-311",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_39;",
      "function claimReward_39() public {        ",
      "        require(redeemableEther_39[msg.sender] > 0);",
      "        uint transferValue_39 = redeemableEther_39[msg.sender];",
      "        msg.sender.transfer(transferValue_39);   ",
      "        redeemableEther_39[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, uint256 valu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "485-491",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_40;",
      "function withdrawBalance_40() public{",
      "        (bool success,)=msg.sender.call.value(userBalance_40[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_40[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, uint256 valu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "519-526",
    "vulnerableCode": [
      "bool balance_checking_27 = true;",
      "function update_27() public{",
      "        require(balance_checking_27);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        balance_checking_27 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, uint256 valu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "531-536",
    "vulnerableCode": [
      "mapping(address => uint) balances_31;",
      "function withdrawFunds_31 (uint256 _weiToWithdraw) public {",
      "        require(balances_31[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_31[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract Token {\n4:   function transfer(address to, uint256 valu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "17-21",
    "vulnerableCode": [
      "address winnerAddress3;",
      "function trackWinner3(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress3 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "87-87",
    "vulnerableCode": [
      "  uint256 timestampUnit = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "89-89",
    "vulnerableCode": [
      "  uint256 timestampUnitAgain = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "109-112",
    "vulnerableCode": [
      "  address winnerAddress10;",
      "function trackWinner10(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerAddress10 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "115-115",
    "vulnerableCode": [
      "  uint256 lastTimestamp = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "279-283",
    "vulnerableCode": [
      "address winnerAddress27;",
      "function trackWinner27(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress27 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "292-296",
    "vulnerableCode": [
      "address winnerAddress31;",
      "function trackWinner31(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress31 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "309-309",
    "vulnerableCode": [
      "uint256 timestampVariable = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.00;\n2: \n3: \n4: \n5: contract SafeMath {\n6:     function safeAdd(u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "6-6",
    "vulnerableCode": [
      "  uint256 currentTimestamp = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   uint256 currentT"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "24-27",
    "vulnerableCode": [
      "  address winner_address2;",
      "function play_winner2(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_address2 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   uint256 currentT"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "34-34",
    "vulnerableCode": [
      "  uint256 initialTimestamp = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   uint256 currentT"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "61-65",
    "vulnerableCode": [
      "address winner_address19;",
      "function play_winner19(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winner_address19 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   uint256 currentT"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "72-75",
    "vulnerableCode": [
      "address winner_address26;",
      "function play_winner26(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_address26 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   uint256 currentT"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "109-112",
    "vulnerableCode": [
      "address winner_address38;",
      "function play_winner38(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_address38 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   uint256 currentT"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "130-134",
    "vulnerableCode": [
      "address winner_address7;",
      "function play_winner7(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winner_address7 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   uint256 currentT"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "142-142",
    "vulnerableCode": [
      "  uint256 initialTransactionTime = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   uint256 currentT"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "144-144",
    "vulnerableCode": [
      "  uint256 secondaryTransactionTime = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   uint256 currentT"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "151-155",
    "vulnerableCode": [
      "address winner_address23;",
      "function play_winner23(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winner_address23 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   uint256 currentT"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "160-163",
    "vulnerableCode": [
      "address winner_address14;",
      "function play_winner14(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_address14 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   uint256 currentT"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "190-193",
    "vulnerableCode": [
      "address winner_address30;",
      "function play_winner30(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_address30 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   uint256 currentT"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "267-271",
    "vulnerableCode": [
      "address winner_address39;",
      "function play_winner39(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winner_address39 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   uint256 currentT"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "289-293",
    "vulnerableCode": [
      "address winner_address35;",
      "function play_winner35(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winner_address35 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   uint256 currentT"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "305-305",
    "vulnerableCode": [
      "  uint256 secondaryTransactionTime = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: contract EventMetadata {\n5: \n6:   uint256 currentT"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "578-581",
    "vulnerableCode": [
      "if (destination.call.value(value)(data))",
      "emit Execution(destination,value,data);",
      "emit ExecutionFailure(destination,value,data);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.13;\n2: \n3: contract DutchAuction is Ownable, HasNoEther, HasNoTokens {\n4: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "219-219",
    "vulnerableCode": [
      "pre_cond(now < endTime)"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Competition is CompetitionInterface, DSMath, DBC, Owned {\n2: \n3:      \n4: \n5"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "357-366",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_29;",
      "",
      "function increaseLockTime_29(uint _secondsToIncrease) public {",
      "        lockTime_29[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_29() public {",
      "        require(now > lockTime_29[msg.sender]);    ",
      "        uint transferValue_29 = 10;           ",
      "        msg.sender.transfer(transferValue_29);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "468-474",
    "vulnerableCode": [
      "mapping(address => uint) balances_34;",
      "",
      "function transfer_34(address _to, uint _value) public returns (bool) {",
      "    require(balances_34[msg.sender] - _value >= 0);  ",
      "    balances_34[msg.sender] -= _value;  ",
      "    balances_34[_to] += _value;  ",
      "    return true;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "498-501",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_21;",
      "",
      "function increaseLockTime_21(uint _secondsToIncrease) public {",
      "        lockTime_21[msg.sender] += _secondsToIncrease;  "
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "620-629",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_1;",
      "",
      "function increaseLockTime_1(uint _secondsToIncrease) public {",
      "        lockTime_1[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_ovrflow1() public {",
      "        require(now > lockTime_1[msg.sender]);    ",
      "        uint transferValue_1 = 10;           ",
      "        msg.sender.transfer(transferValue_1);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "704-707",
    "vulnerableCode": [
      "",
      "function increaseLockTime_17(uint _secondsToIncrease) public {",
      "        lockTime_17[msg.sender] += _secondsToIncrease;  ",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "718-721",
    "vulnerableCode": [
      "",
      "    function isMinter(address account) public view returns (bool) {",
      "        return _minters.has(account);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "744-748",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_9;",
      "",
      "function increaseLockTime_9(uint _secondsToIncrease) public {",
      "        lockTime_9[msg.sender] += _secondsToIncrease;  ",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "759-768",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_25;",
      "",
      "function increaseLockTime_25(uint _secondsToIncrease) public {",
      "        lockTime_25[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_25() public {",
      "        require(now > lockTime_25[msg.sender]);    ",
      "        uint transferValue_25 = 10;           ",
      "        msg.sender.transfer(transferValue_25);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "783-792",
    "vulnerableCode": [
      "  mapping(address => uint) public lockTime_33;",
      "",
      "function increaseLockTime_33(uint _secondsToIncrease) public {",
      "        lockTime_33[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_33() public {",
      "        require(now > lockTime_33[msg.sender]);    ",
      "        uint transferValue_33 = 10;           ",
      "        msg.sender.transfer(transferValue_33);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "805-811",
    "vulnerableCode": [
      "mapping(address => uint) balances_26;",
      "",
      "function transfer_26(address _to, uint _value) public returns (bool) {",
      "    require(balances_26[msg.sender] - _value >= 0);  ",
      "    balances_26[msg.sender] -= _value;  ",
      "    balances_26[_to] += _value;  ",
      "    return true;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "838-844",
    "vulnerableCode": [
      "mapping(address => uint) balances_38;",
      "",
      "function transfer_38(address _to, uint _value) public returns (bool) {",
      "    require(balances_38[msg.sender] - _value >= 0);  ",
      "    balances_38[msg.sender] -= _value;  ",
      "    balances_38[_to] += _value;  ",
      "    return true;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "23-23",
    "vulnerableCode": [
      "            if(msg.sender.call.value(_am)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.25;\n2: \n3: contract X_WALLET\n4: {\n5:     function Put(uint _unlockTime)\n6: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1031-1031",
    "vulnerableCode": [
      "admin.transfer(_com.add(_p3d / 2));"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3DLight is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "444-444",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3DLight is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "413-413",
    "vulnerableCode": [
      "if (msg.sender.call.value(withdrawAmount)()) {"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.16;\n2: \n3: \n4: \n5: \n6: interface dAppBridge_I {\n7:     function getOwner() "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "357-384",
    "vulnerableCode": [
      "uint256 _rID = rID_;",
      "uint256 _now = now;",
      "uint256 _pID = pIDxAddr_[msg.sender];",
      "if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)",
      "POOHMOXDatasets.EventReturns memory _eventData_;",
      "round_[_rID].ended = true;",
      "_eth = withdrawEarnings(_pID);",
      "if (_eth > 0)",
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract POOHMOX is POOHMOXevents {\n4:     using SafeMath for *;"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "407-408",
    "vulnerableCode": [
      "if(!sendTo.send(originalPlayerBetValue)) throw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract POOHMOX is POOHMOXevents {\n4:     using SafeMath for *;"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "33-33",
    "vulnerableCode": [
      "  uint256 creationTime = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract TAMC {\n4:   address winnerAddress35;\n5: func"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "51-51",
    "vulnerableCode": [
      "uint256 latestBalanceCheck = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract TAMC {\n4:   address winnerAddress35;\n5: func"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "53-53",
    "vulnerableCode": [
      "  uint256 lastUpdate = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract TAMC {\n4:   address winnerAddress35;\n5: func"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "56-60",
    "vulnerableCode": [
      "  address winnerAddress31;",
      "function playGame31(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress31 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract TAMC {\n4:   address winnerAddress35;\n5: func"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "71-71",
    "vulnerableCode": [
      "uint256 approvalCheckTime = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract TAMC {\n4:   address winnerAddress35;\n5: func"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "86-86",
    "vulnerableCode": [
      "uint256 finalCheckTime = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract TAMC {\n4:   address winnerAddress35;\n5: func"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "373-375",
    "vulnerableCode": [
      "if (!address(admin1).call.value(_com.sub(_com / 2))()) {",
      "if (!address(admin2).call.value(_com / 2)()) {"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract NewChance is modularShort {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "404-404",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract NewChance is modularShort {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "444-444",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract NewChance is modularShort {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "85-89",
    "vulnerableCode": [
      "if (!(toAddress.call.value(value)(data))) {",
      "Transacted(msg.sender, otherSigner, operationHash, toAddress, value, data);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.14;\n2: \n3: \n4: \n5: \n6: \n7: contract WalletSimple {\n8:   \n9:   event Deposit"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "8-8",
    "vulnerableCode": [
      "require(block.timestamp >= openingTime && block.timestamp <= closingTime);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract TimedCrowdsale is Crowdsale {\n2:   using SafeMath for uint256;\n3: \n4:   uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "63-63",
    "vulnerableCode": [
      "uint256 proofCreationTime = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.21 <0.6.0;\n2: \n3: contract ProofOfExistence {\n4: \n5: enum Block"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "74-74",
    "vulnerableCode": [
      "uint256 proofCreationTime1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.21 <0.6.0;\n2: \n3: contract ProofOfExistence {\n4: \n5: enum Block"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "82-82",
    "vulnerableCode": [
      "uint256 proofCreationTime2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.21 <0.6.0;\n2: \n3: contract ProofOfExistence {\n4: \n5: enum Block"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "100-100",
    "vulnerableCode": [
      "uint256 proofCreationTime3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.21 <0.6.0;\n2: \n3: contract ProofOfExistence {\n4: \n5: enum Block"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "117-117",
    "vulnerableCode": [
      "uint256 proofCreationTime4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.21 <0.6.0;\n2: \n3: contract ProofOfExistence {\n4: \n5: enum Block"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1022-1026",
    "vulnerableCode": [
      "if (!address(MonkeyKingCorp).call.value(_com)(bytes4(keccak256(\"deposit()\"))))",
      "{",
      "    _gen = _gen.add(_com);",
      "    _com = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract MonkeyScam is modularMonkeyScam {\n4:     using SafeMath"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "359-359",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract MonkeyScam is modularMonkeyScam {\n4:     using SafeMath"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "8-12",
    "vulnerableCode": [
      "  address winner_23;",
      "function play_23(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_23 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function r"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "52-52",
    "vulnerableCode": [
      "  uint256 balancesv_2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function r"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "55-55",
    "vulnerableCode": [
      "  uint256 balancesv_3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function r"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "58-58",
    "vulnerableCode": [
      "  uint256 balancesv_4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function r"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "71-75",
    "vulnerableCode": [
      "address winner_35;",
      "function play_35(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_35 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function r"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "111-115",
    "vulnerableCode": [
      "address winner_27;",
      "function play_27(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_27 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function r"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "149-149",
    "vulnerableCode": [
      "uint256 balancesv_5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function r"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "160-160",
    "vulnerableCode": [
      "uint256 balancesv_1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function r"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "56-58",
    "vulnerableCode": [
      "if(msg.sender.call.value(_am)())",
      "acc.balance-=_am;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.19;\n2: \n3: contract PENNY_BY_PENNY  \n4: {\n5:     struct Holder   \n6:     {\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "414-414",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F3DPLUS is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "148-148",
    "vulnerableCode": [
      "admin.transfer(_com);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F3DPLUS is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1285-1285",
    "vulnerableCode": [
      "admin.transfer(_p3d.sub(_potAmount));"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F3DPLUS is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "663-669",
    "vulnerableCode": [
      "            admin.transfer(_com);",
      "            admin.transfer(_p3d.sub(_p3d / 2));",
      "            round_[_rID].pot = _pot.add(_p3d / 2);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "8-12",
    "vulnerableCode": [
      "  address winnerAddress23;",
      "function playWinner23(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress23 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function r"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "14-17",
    "vulnerableCode": [
      "  address winnerAddress14;",
      "function playWinner14(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerAddress14 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function r"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "19-22",
    "vulnerableCode": [
      "  address winnerAddress30;",
      "function playWinner30(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerAddress30 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function r"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "35-39",
    "vulnerableCode": [
      "  address winnerAddress39;",
      "function playWinner39(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress39 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function r"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "52-52",
    "vulnerableCode": [
      "  uint256 currentBlockTimestamp = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function r"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "55-55",
    "vulnerableCode": [
      "  uint256 currentBlockTimestampV2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function r"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "58-58",
    "vulnerableCode": [
      "  uint256 currentBlockTimestampV3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function r"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "71-75",
    "vulnerableCode": [
      "address winnerAddress35;",
      "function playWinner35(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress35 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function r"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "111-115",
    "vulnerableCode": [
      "address winnerAddress27;",
      "function playWinner27(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress27 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function r"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "123-127",
    "vulnerableCode": [
      "address winnerAddress31;",
      "function playWinner31(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress31 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function r"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "149-149",
    "vulnerableCode": [
      "uint256 currentBlockTimestampV5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function r"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "160-160",
    "vulnerableCode": [
      "uint256 currentBlockTimestampV1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     function r"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "61-61",
    "vulnerableCode": [
      "assert(block.timestamp >= STARTDATE);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.13;\n2: \n3: contract Crowdsale {\n4:     using SafeMath for uint25"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "189-199",
    "vulnerableCode": [
      "if (block.timestamp <= 1535241660) {",
      "    if (_weiAmount >= 1700 ether) {",
      "        discount = 30;",
      "    } else if (_weiAmount > 0.2 ether) {",
      "        discount = 25;",
      "    }",
      "} else if (block.timestamp <= 1537747260) {",
      "    discount = 15;",
      "} else if (block.timestamp <= 1540339260) {",
      "    discount = 10;",
      "} else if (block.timestamp <= 1543536060) {",
      "    discount = 5;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.13;\n2: \n3: contract Crowdsale {\n4:     using SafeMath for uint25"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "415-415",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract NewChance is modularShort {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "444-444",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract NewChance is modularShort {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "795-795",
    "vulnerableCode": [
      "plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract NewChance is modularShort {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1255-1255",
    "vulnerableCode": [
      "if (!address(admin1).call.value(_com.sub(_com / 2))())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract NewChance is modularShort {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1265-1265",
    "vulnerableCode": [
      "if (!address(admin2).call.value(_com / 2)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract NewChance is modularShort {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "53-53",
    "vulnerableCode": [
      "if (tx.destination.call.value(tx.value)(tx.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract MultiSigWalletWithDailyLimit is MultiSigWallet {\n2: \n3:     /*\n4:      *  Events\n5:    "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "162-169",
    "vulnerableCode": [
      "    mapping(address => uint) balances_14;",
      "",
      "    function transfer_14(address _to, uint _value) public returns (bool) {",
      "        require(balances_14[msg.sender] - _value >= 0);  ",
      "        balances_14[msg.sender] -= _value;  ",
      "        balances_14[_to] += _value;  ",
      "        return true;",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: contract CareerOnToken {\n4:     function alertComp"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "178-185",
    "vulnerableCode": [
      "    mapping(address => uint) balances_30;",
      "",
      "    function transfer_30(address _to, uint _value) public returns (bool) {",
      "        require(balances_30[msg.sender] - _value >= 0);  ",
      "        balances_30[msg.sender] -= _value;  ",
      "        balances_30[_to] += _value;  ",
      "        return true;",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: contract CareerOnToken {\n4:     function alertComp"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "11-12",
    "vulnerableCode": [
      "uint256 public startTime;",
      "uint256 public endTime;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract ICO is HardcodedWallets, Haltable {\n2: \t \n3: \n4: \t \n5: \tTokens public SCToke"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "196-238",
    "vulnerableCode": [
      "function refund() stopInEmergency {",
      "    if(getState() != State.Refunding) throw;",
      "    address investor = msg.sender;",
      "    if(balances[investor] == 0) throw;",
      "    uint amount = balances[investor];",
      "    delete balances[investor];",
      "    if(!(investor.call.value(amount)())) throw;",
      "    Refunded(investor, amount);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract PreICOProxyBuyer is Ownable, Haltable, SafeMath {\n2: \n3:   \n4:   uint public investorCo"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "261-261",
    "vulnerableCode": [
      "require(msg.sender.call.value(_user.r_payout)());"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.23;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: interface IRegistry "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "273-273",
    "vulnerableCode": [
      "require(msg.sender.call.value(msg.value)());"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.23;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: interface IRegistry "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "382-382",
    "vulnerableCode": [
      "                plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract POHMO is PoHEVENTS {\n4:     using SafeMath for *;\n5:   "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "411-411",
    "vulnerableCode": [
      "                plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract POHMO is PoHEVENTS {\n4:     using SafeMath for *;\n5:   "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1151-1151",
    "vulnerableCode": [
      "            POHToken.call.value(_PoH)(bytes4(keccak256(\"sendDividends()\")));"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract POHMO is PoHEVENTS {\n4:     using SafeMath for *;\n5:   "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "147-147",
    "vulnerableCode": [
      "require(block.timestamp > crowdSaleEndTime);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract GigToken is MintingERC20 {\n2:     SellableToken public crowdSale;  \n3:     S"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "221-234",
    "vulnerableCode": [
      "function executeTransaction(uint transactionId)",
      "public",
      "ownerExists(msg.sender)",
      "confirmed(transactionId, msg.sender)",
      "notExecuted(transactionId)",
      "{",
      "if (isConfirmed(transactionId)) {",
      "Transaction storage txn = transactions[transactionId];",
      "txn.executed = true;",
      "if (txn.destination.call.value(txn.value)(txn.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity 0.4.15;\n2: \n3: \n4: \n5: \n6: contract MultiSigWallet {\n7: \n8:     \n9: \n10: \n11:   "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "226-226",
    "vulnerableCode": [
      "if (tx.destination.call.value(tx.value)(tx.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.23;\n2: \n3: \n4: \n5: \n6: contract MultiSigWallet {\n7: \n8:     uint constant p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "43-49",
    "vulnerableCode": [
      "bool notCalledOnce = true;",
      "function checkOnce() public{",
      "        require(notCalledOnce);",
      "        if( ! (msg.sender.send(1 ether))) {",
      "            revert();",
      "        }",
      "        notCalledOnce = false;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:   function multiply(uint256 a, uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "143-143",
    "vulnerableCode": [
      "_affCode = plyr_[_pID].laff;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract FoMo3Dlong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "257-257",
    "vulnerableCode": [
      "_now = now;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract FoMo3Dlong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "521-521",
    "vulnerableCode": [
      "_now = now;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract FoMo3Dlong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "363-363",
    "vulnerableCode": [
      "uint256 _now = now;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract FoMo3Dlong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "484-484",
    "vulnerableCode": [
      "uint256 _now = now;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract FoMo3Dlong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "503-503",
    "vulnerableCode": [
      "uint256 _now = now;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract FoMo3Dlong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "632-632",
    "vulnerableCode": [
      "uint256 _now = now;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract FoMo3Dlong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "683-683",
    "vulnerableCode": [
      "uint256 _now = now;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract FoMo3Dlong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1060-1060",
    "vulnerableCode": [
      "uint256 _now = now;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract FoMo3Dlong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1285-1285",
    "vulnerableCode": [
      "round_[1].strt = now + rndExtra_ - rndGap_;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract FoMo3Dlong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1286-1286",
    "vulnerableCode": [
      "round_[1].end = now + rndInit_ + rndExtra_;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract FoMo3Dlong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1034-1035",
    "vulnerableCode": [
      "round_[_rID].strt = now;",
      "round_[_rID].end = now.add(rndInit_).add(rndGap_);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract FoMo3Dlong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1120-1120",
    "vulnerableCode": [
      "emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract FoMo3Dlong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1146-1146",
    "vulnerableCode": [
      "if (now > round_[_rID].end && round_[_rID].ended == true)"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract FoMo3Dlong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1234-1234",
    "vulnerableCode": [
      "_eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract FoMo3Dlong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "216-221",
    "vulnerableCode": [
      "        playerRandomResult[myid] = parseInt(result);",
      "        playerDieResult[myid] = uint(sha3(playerRandomResult[myid], proof)) % (100 - 1) + 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "348-348",
    "vulnerableCode": [
      "         if (msg.sender.call.value(withdrawAmount)()) {"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "326-326",
    "vulnerableCode": [
      "             if(!playerTempAddress[myid].send(1){"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "429-429",
    "vulnerableCode": [
      "         if(!sendTo.send(amount)) throw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "447-447",
    "vulnerableCode": [
      "         if(!sendTo.send(originalPlayerBetValue)) throw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "82-88",
    "vulnerableCode": [
      "  mapping(address => uint) userBalance_19;",
      "function withdrawBalance_19() public{",
      "        if( ! (msg.sender.send(userBalance_19[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalance_19[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract ERC20Interface {\n5:     function transferFrom(addr"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "90-97",
    "vulnerableCode": [
      "  mapping(address => uint) userBalance_26;",
      "function withdrawBalance_26() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_26[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_26[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract ERC20Interface {\n5:     function transferFrom(addr"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "99-106",
    "vulnerableCode": [
      "  bool checkcall_20 = true;",
      "function checking_20() public{",
      "        require(checkcall_20);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        checkcall_20 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract ERC20Interface {\n5:     function transferFrom(addr"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "108-114",
    "vulnerableCode": [
      "  mapping(address => uint) redeemableEther_32;",
      "function claimReward_32() public {        ",
      "        require(redeemableEther_32[msg.sender] > 0);",
      "        uint transferValue_32 = redeemableEther_32[msg.sender];",
      "        msg.sender.transfer(transferValue_32);   ",
      "        redeemableEther_32[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract ERC20Interface {\n5:     function transferFrom(addr"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "116-121",
    "vulnerableCode": [
      "  mapping(address => uint) balances_38;",
      "function withdrawFunds_38 (uint256 _weiToWithdraw) public {",
      "        require(balances_38[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_38[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract ERC20Interface {\n5:     function transferFrom(addr"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "145-152",
    "vulnerableCode": [
      "  bool checkcall_27 = true;",
      "function checking_27() public{",
      "        require(checkcall_27);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        checkcall_27 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract ERC20Interface {\n5:     function transferFrom(addr"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "154-159",
    "vulnerableCode": [
      "  mapping(address => uint) balances_31;",
      "function withdrawFunds_31 (uint256 _weiToWithdraw) public {",
      "        require(balances_31[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_31[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract ERC20Interface {\n5:     function transferFrom(addr"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "161-169",
    "vulnerableCode": [
      "  bool checkcall_13 = true;",
      "function checking_13() public{",
      "        require(checkcall_13);",
      "        (bool success,)=msg.sender.call.value(1 ether)(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        checkcall_13 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract ERC20Interface {\n5:     function transferFrom(addr"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "186-193",
    "vulnerableCode": [
      "address payable lastPlayer_30;",
      "      uint jackpot_30;",
      "      function buyTicket_30() public{",
      "        if (!(lastPlayer_30.send(jackpot_30)))",
      "        revert();",
      "      lastPlayer_30 = msg.sender;",
      "      jackpot_30    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract ERC20Interface {\n5:     function transferFrom(addr"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "221-226",
    "vulnerableCode": [
      "mapping(address => uint) balances_8;",
      "    function withdraw_balances_8 () public {",
      "       (bool success,) = msg.sender.call.value(balances_8[msg.sender ])(\"\");",
      "       if (success)",
      "          balances_8[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract ERC20Interface {\n5:     function transferFrom(addr"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "239-245",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_39;",
      "function claimReward_39() public {        ",
      "        require(redeemableEther_39[msg.sender] > 0);",
      "        uint transferValue_39 = redeemableEther_39[msg.sender];",
      "        msg.sender.transfer(transferValue_39);   ",
      "        redeemableEther_39[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract ERC20Interface {\n5:     function transferFrom(addr"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "253-257",
    "vulnerableCode": [
      "mapping(address => uint) balances_36;",
      "    function withdraw_balances_36 () public {",
      "       if (msg.sender.send(balances_36[msg.sender ]))",
      "          balances_36[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract ERC20Interface {\n5:     function transferFrom(addr"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "261-268",
    "vulnerableCode": [
      "uint256 counter_35 =0;",
      "function callcount_35() public{",
      "        require(counter_35<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_35 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract ERC20Interface {\n5:     function transferFrom(addr"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "272-279",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_40;",
      "function withdrawBalance_40() public{",
      "        (bool success,)=msg.sender.call.value(userBalance_40[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_40[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract ERC20Interface {\n5:     function transferFrom(addr"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "283-290",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_33;",
      "function withdrawBalance_33() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_33[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_33[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: contract ERC20Interface {\n5:     function transferFrom(addr"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "69-70",
    "vulnerableCode": [
      "owner.call.value(fees)();"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract LooneyLottery {\n2:   \n3:   modifier owneronly {\n4:     \n5:     if (msg.sender != owner)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "164-164",
    "vulnerableCode": [
      "msg.sender.call.value(overflow)();"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract LooneyLottery {\n2:   \n3:   modifier owneronly {\n4:     \n5:     if (msg.sender != owner)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "224-228",
    "vulnerableCode": [
      "if (txn.destination.call.value(txn.value)(txn.data))",
      "    emit Execution(transactionId);",
      "else {",
      "    emit ExecutionFailure(transactionId);",
      "    txn.executed = false;}"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: pragma solidity ^0.4.24;\n11: \n12: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "269-270",
    "vulnerableCode": [
      "txn.executed = true;",
      "if (txn.destination.call.value(txn.value)(txn.data))",
      "    emit Execution(transactionId);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: pragma solidity ^0.4.24;\n11: \n12: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "269-270",
    "vulnerableCode": [
      "txn.executed = false;",
      "    emit ExecutionFailure(transactionId);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: pragma solidity ^0.4.24;\n11: \n12: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "228-228",
    "vulnerableCode": [
      "txn.executed = false;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: pragma solidity ^0.4.24;\n11: \n12: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "444-446",
    "vulnerableCode": [
      "if(!bondFundAddress.call.value(_bondEthToPay).gas(400000)()) {",
      "totalEthFundRecieved = SafeMath.sub(totalEthFundRecieved, _bondEthToPay);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "450-452",
    "vulnerableCode": [
      "if(!altFundAddress.call.value(_altEthToPay).gas(400000)()) {",
      "totalEthFundRecieved = SafeMath.sub(totalEthFundRecieved, _altEthToPay);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "373-373",
    "vulnerableCode": [
      "require(tx.gasprice <= 0.05 szabo);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "386-386",
    "vulnerableCode": [
      "require(tx.gasprice <= 0.05 szabo);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "577-577",
    "vulnerableCode": [
      "if (tokenSupply_ > 0) {"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "969-969",
    "vulnerableCode": [
      "msg.sender.transfer(excess);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "441-441",
    "vulnerableCode": [
      "totalEthFundRecieved = SafeMath.add(totalEthFundRecieved, ethToPay);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "259-263",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime5;",
      "",
      "function increaseLockTime5(uint _secondsToIncrease) public {",
      "        lockTime5[msg.sender] += _secondsToIncrease;  ",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint25"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "96-103",
    "vulnerableCode": [
      "mapping(address => uint) userBalance;  // Renamed",
      "function withdrawUserBalance() public{  // Renamed",
      "        (bool success,)= msg.sender.call.value(userBalance[msg.sender])(\"\");  // Renamed",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance[msg.sender] = 0;  // Renamed",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "108-115",
    "vulnerableCode": [
      "bool isFunctionCalled = true;  // Renamed",
      "function activateFunctionCall() public {  // Renamed",
      "        require(isFunctionCalled);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        isFunctionCalled = false;  // Renamed",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "254-261",
    "vulnerableCode": [
      "uint256 callCounter3 = 0;  // Renamed",
      "function incrementCallCounter3() public {  // Renamed",
      "        require(callCounter3 <= 5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        callCounter3 += 1;  // Renamed",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "265-273",
    "vulnerableCode": [
      "  address payable lastPlayer4;  // Renamed",
      "      uint jackpot4;  // Renamed",
      "      function buyTicket4() public {  // Renamed",
      "        (bool success,) = lastPlayer4.call.value(jackpot4)(\"\");  // Renamed",
      "        if (!success)",
      "            revert();",
      "      lastPlayer4 = msg.sender;",
      "      jackpot4 = address(this).balance;  // Renamed",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "275-281",
    "vulnerableCode": [
      "  mapping(address => uint) redeemableBalances4;  // Renamed",
      "function claimReward4() public {        ",
      "        require(redeemableBalances4[msg.sender] > 0);",
      "        uint transferValue4 = redeemableBalances4[msg.sender];  // Renamed",
      "        msg.sender.transfer(transferValue4);   ",
      "        redeemableBalances4[msg.sender] = 0;  // Renamed",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "283-289",
    "vulnerableCode": [
      "  mapping(address => uint) userBalance2;  // Renamed",
      "function withdrawUserBalance2() public{  // Renamed",
      "        if( ! (msg.sender.send(userBalance2[msg.sender]) ) ){  // Renamed",
      "            revert();",
      "        }",
      "        userBalance2[msg.sender] = 0;  // Renamed",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "297-304",
    "vulnerableCode": [
      "mapping(address => uint) userBalance3;  // Renamed",
      "function withdrawUserBalance3() public{  // Renamed",
      "        (bool success,)=msg.sender.call.value(userBalance3[msg.sender])(\"\");  // Renamed",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance3[msg.sender] = 0;  // Renamed",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "309-316",
    "vulnerableCode": [
      "mapping(address => uint) userBalance4;  // Renamed",
      "function withdrawUserBalance4() public{  // Renamed",
      "        (bool success,)= msg.sender.call.value(userBalance4[msg.sender])(\"\");  // Renamed",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance4[msg.sender] = 0;  // Renamed",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "321-328",
    "vulnerableCode": [
      "bool isFunctionActive = true;  // Renamed",
      "function activateFunction() public{  // Renamed",
      "        require(isFunctionActive);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        isFunctionActive = false;  // Renamed",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "333-338",
    "vulnerableCode": [
      "mapping(address => uint) balances2;  // Renamed",
      "function withdrawFunds2 (uint256 _weiToWithdraw) public {  // Renamed",
      "        require(balances2[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances2[msg.sender] -= _weiToWithdraw;  // Renamed",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "345-353",
    "vulnerableCode": [
      "bool isFunctionActive2 = true;  // Renamed",
      "function activateFunction2() public{  // Renamed",
      "        require(isFunctionActive2);",
      "        (bool success,)=msg.sender.call.value(1 ether)(\"\");  // Renamed",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        isFunctionActive2 = false;  // Renamed",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1004-1008",
    "vulnerableCode": [
      "admin.transfer(_com);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1190-1190",
    "vulnerableCode": [
      "if (!address(TeamGoalbonanza).call.value(_com)(bytes4(keccak256(\"deposit()\"))))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract GoalbonanzaPlusLong is modularGoalbonanzaPlus {\n4:     "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1074-1074",
    "vulnerableCode": [
      "if (!address(TeamGoalbonanza).call.value(_com)(bytes4(keccak256(\"deposit()\"))))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract GoalbonanzaPlusLong is modularGoalbonanzaPlus {\n4:     "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "76-76",
    "vulnerableCode": [
      "if (!address(TeamGoalbonanza).call.value(_com)(bytes4(keccak256(\"deposit()\"))))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract GoalbonanzaPlusLong is modularGoalbonanzaPlus {\n4:     "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "267-267",
    "vulnerableCode": [
      "c.ethRefund = ethRefundAmount.length;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.19;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8:     \n9:   function mul(uin"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "90-90",
    "vulnerableCode": [
      "require(started == true && startTime <= block.timestamp);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: library SafeMath {\n4: \n5:   function mul(uint256 a, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "414-414",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1255-1255",
    "vulnerableCode": [
      "if (!address(admin).call.value(_com)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1287-1287",
    "vulnerableCode": [
      "admin.transfer(_p3d.sub(_potAmount));"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "191-191",
    "vulnerableCode": [
      "block.timestamp > (forceOffsetBooks[user_] + 28800)"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract XPAAssets is SafeMath, Authorization {\n2:     string public version = \"0.5.0"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "589-592",
    "vulnerableCode": [
      "admin.transfer(_com);",
      "admin.transfer(_p3d.sub(_p3d / 2));",
      "round_[_rID].pot = _pot.add(_p3d / 2);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FullFOMO is modularShort {\n4:     using SafeMath for *;"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "659-662",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);",
      "emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FullFOMO is modularShort {\n4:     using SafeMath for *;"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "57-62",
    "vulnerableCode": [
      "mapping(address => uint) balances_2;",
      "",
      "function transfer_2(address _to, uint _value) public returns (bool) {",
      "    require(balances_2[msg.sender] - _value >= 0);  ",
      "    balances_2[msg.sender] -= _value;  ",
      "    balances_2[_to] += _value;  "
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   function updates_24(uin"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "339-345",
    "vulnerableCode": [
      "mapping(address => uint) balances_38;",
      "",
      "function transfer_38(address _to, uint _value) public returns (bool) {",
      "    require(balances_38[msg.sender] - _value >= 0);  ",
      "    balances_38[msg.sender] -= _value;  ",
      "    balances_38[_to] += _value;  ",
      "    return true;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   function updates_24(uin"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "570-576",
    "vulnerableCode": [
      "mapping(address => uint) balances_2;",
      "",
      "function transfer_2(address _to, uint _value) public returns (bool) {",
      "    require(balances_2[msg.sender] - _value >= 0);  ",
      "    balances_2[msg.sender] -= _value;  ",
      "    balances_2[_to] += _value;  ",
      "    return true;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   function updates_24(uin"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "582-586",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_17;",
      "",
      "function increaseLockTime_17(uint _secondsToIncrease) public {",
      "        lockTime_17[msg.sender] += _secondsToIncrease;  ",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   function updates_24(uin"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "968",
    "vulnerableCode": [
      "        p.numberOfVotes = voteID +1;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   function updates_24(uin"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "972-979",
    "vulnerableCode": [
      "mapping(address => uint) balances_30;",
      "",
      "function transfer_30(address _to, uint _value) public returns (bool) {",
      "    require(balances_30[msg.sender] - _value >= 0);  ",
      "    balances_30[msg.sender] -= _value;  ",
      "    balances_30[_to] += _value;  ",
      "    return true;",
      "  }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   function updates_24(uin"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "39-40",
    "vulnerableCode": [
      "if(_to.call.value(_am)()==false)throw;",
      "investors[_to] -= _am;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Accrual_account\n2: {\n3:     address admin = msg.sender;\n4:    \n5:     uint targetAmount"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "229-229",
    "vulnerableCode": [
      "if (tx.destination.call.value(tx.value)(tx.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.17;\n2: \n3: \n4: \n5: \n6: contract MultiSigWallet {\n7: \n8:     uint constant p"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "24-28",
    "vulnerableCode": [
      "  mapping(address => uint) withdrawableBalances;",
      "function withdrawFunds (uint256 _weiToWithdraw) public {",
      "        require(withdrawableBalances[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        withdrawableBalances[msg.sender] -= _weiToWithdraw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.21 < 0.6.0;\n2: \n3: contract DocumentSigner {\n4:   mapping(address => uint)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "49-55",
    "vulnerableCode": [
      "uint256 counter =0;",
      "function callMe() public{",
      "        require(counter<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.21 < 0.6.0;\n2: \n3: contract DocumentSigner {\n4:   mapping(address => uint)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "65-71",
    "vulnerableCode": [
      "mapping(address => uint) userBalances;",
      "function withdrawUserBalance() public{",
      "        (bool success,)=msg.sender.call.value(userBalances[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalances[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.21 < 0.6.0;\n2: \n3: contract DocumentSigner {\n4:   mapping(address => uint)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "78-84",
    "vulnerableCode": [
      "mapping(address => uint) alternativeUserBalances;",
      "function withdrawAlternativeUserBalance() public{",
      "        (bool success,)= msg.sender.call.value(alternativeUserBalances[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        alternativeUserBalances[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.21 < 0.6.0;\n2: \n3: contract DocumentSigner {\n4:   mapping(address => uint)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "90-97",
    "vulnerableCode": [
      "bool anotherNotCalled = true;",
      "function callAnotherOnce() public{",
      "        require(anotherNotCalled);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        anotherNotCalled = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.21 < 0.6.0;\n2: \n3: contract DocumentSigner {\n4:   mapping(address => uint)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "383-383",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract BATMO is FOMOEvents {\n4:     using SafeMath for *;\n5:  "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "412-412",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract BATMO is FOMOEvents {\n4:     using SafeMath for *;\n5:  "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1047-1047",
    "vulnerableCode": [
      "address(ObokContract).call.value(_OBOK.sub((_OBOK / 3).mul(2)))(bytes4(keccak256(\"donateDivs()\")));"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract BATMO is FOMOEvents {\n4:     using SafeMath for *;\n5:  "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1153-1153",
    "vulnerableCode": [
      "address(ObokContract).call.value(_OBOK.sub(_potAmount))(bytes4(keccak256(\"donateDivs()\")));"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract BATMO is FOMOEvents {\n4:     using SafeMath for *;\n5:  "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "48-48",
    "vulnerableCode": [
      "            if(msg.sender.call.value(_am)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.19;\n2: \n3: contract BANK_SAFE\n4: {\n5:     mapping (address=>uint256) public"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1258-1258",
    "vulnerableCode": [
      "if (!address(admin).call.value(_com)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1233-1233",
    "vulnerableCode": [
      "address(admin).call.value(_com)()"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1065-1065",
    "vulnerableCode": [
      "buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "105-105",
    "vulnerableCode": [
      "require(_bankroller.call.value(_amount)(_sig));"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.23;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: interface IRegistry {\n12:     "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "121-121",
    "vulnerableCode": [
      "require(_tr.call.value(_profits)());"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.23;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: interface IRegistry {\n12:     "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "8-12",
    "vulnerableCode": [
      "  address winner_address23;",
      "function play_winner23(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_address23 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: interface tokenRecipient { \n4:     function receiveApp"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "14-17",
    "vulnerableCode": [
      "  address winner_address14;",
      "function play_winner14(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_address14 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: interface tokenRecipient { \n4:     function receiveApp"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "19-22",
    "vulnerableCode": [
      "  address winner_address30;",
      "function play_winner30(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_address30 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: interface tokenRecipient { \n4:     function receiveApp"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "35-39",
    "vulnerableCode": [
      "  address winner_address39;",
      "function play_winner39(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_address39 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: interface tokenRecipient { \n4:     function receiveApp"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "71-75",
    "vulnerableCode": [
      "address winner_address35;",
      "function play_winner35(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_address35 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: interface tokenRecipient { \n4:     function receiveApp"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "111-115",
    "vulnerableCode": [
      "address winner_address27;",
      "function play_winner27(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_address27 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: interface tokenRecipient { \n4:     function receiveApp"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "123-127",
    "vulnerableCode": [
      "address winner_address31;",
      "function play_winner31(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_address31 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: interface tokenRecipient { \n4:     function receiveApp"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1-1",
    "vulnerableCode": [
      "pragma solidity ^0.5.7;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.7;\n2: \n3: interface tokenRecipient { \n4:     function receiveApp"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "262-268",
    "vulnerableCode": [
      "mapping(address => uint) balancesMapping14;",
      "",
      "function transferMapping14(address _to, uint _value) public returns (bool) {",
      "    require(balancesMapping14[msg.sender] - _value >= 0);  ",
      "    balancesMapping14[msg.sender] -= _value;  ",
      "    balancesMapping14[_to] += _value;  ",
      "    return true;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11; \n2: \n3: \n4: \n5: library SafeMath {\t\n6:     function add("
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "108-115",
    "vulnerableCode": [
      "  bool callings_27 = true;",
      "function transfers_27() public{",
      "        require(callings_27);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callings_27 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: library SafeMath {\n4:     function multiply(uint256 a, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "167-174",
    "vulnerableCode": [
      "  bool params_13 = true;",
      "function Updates_13() public{",
      "        require(params_13);",
      "        (bool success,)=msg.sender.call.value(1 ether)(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        params_13 = false;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: library SafeMath {\n4:     function multiply(uint256 a, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "184-192",
    "vulnerableCode": [
      "  mapping(address => uint) userBalance_5;",
      "function withdrawBalance_5() public{",
      "",
      "",
      "        if( ! (msg.sender.send(userBalance_5[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalance_5[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: library SafeMath {\n4:     function multiply(uint256 a, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "220-226",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_25;",
      "function claimReward_25() public {        ",
      "",
      "        require(redeemableEther_25[msg.sender] > 0);",
      "        uint transferValue_25 = redeemableEther_25[msg.sender];",
      "        msg.sender.transfer(transferValue_25); ",
      "        redeemableEther_25[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: library SafeMath {\n4:     function multiply(uint256 a, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "285-289",
    "vulnerableCode": [
      "  mapping(address => uint) balances_15;",
      "    function withdraw_balances_15 () public {",
      "       if (msg.sender.send(balances_15[msg.sender ]))",
      "          balances_15[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: library SafeMath {\n4:     function multiply(uint256 a, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "297-304",
    "vulnerableCode": [
      "bool params_20 = true;",
      "function Updates_20() public{",
      "        require(params_20);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        params_20 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: library SafeMath {\n4:     function multiply(uint256 a, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "323-330",
    "vulnerableCode": [
      "  bool params_34 = true;",
      "function Updates_34() public{",
      "        require(params_34);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        params_34 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: library SafeMath {\n4:     function multiply(uint256 a, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "354-359",
    "vulnerableCode": [
      "  mapping(address => uint) balances_21;",
      "    function withdraw_balances_21 () public {",
      "       (bool success,)= msg.sender.call.value(balances_21[msg.sender ])(\"\");",
      "       if (success)",
      "          balances_21[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: library SafeMath {\n4:     function multiply(uint256 a, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "367-373",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_32;",
      "function claimReward_32() public {        ",
      "",
      "        require(redeemableEther_32[msg.sender] > 0);",
      "        uint transferValue_32 = redeemableEther_32[msg.sender];",
      "        msg.sender.transfer(transferValue_32);",
      "        redeemableEther_32[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: library SafeMath {\n4:     function multiply(uint256 a, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "381-387",
    "vulnerableCode": [
      "mapping(address => uint) balances_38;",
      "function withdrawFunds_38 (uint256 _weiToWithdraw) public {",
      "        require(balances_38[msg.sender] >= _weiToWithdraw);",
      "",
      "        require(msg.sender.send(_weiToWithdraw)); ",
      "        balances_38[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: library SafeMath {\n4:     function multiply(uint256 a, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "393-399",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_4;",
      "function claimReward_4() public {        ",
      "",
      "        require(redeemableEther_4[msg.sender] > 0);",
      "        uint transferValue_4 = redeemableEther_4[msg.sender];",
      "        msg.sender.transfer(transferValue_4); ",
      "        redeemableEther_4[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: library SafeMath {\n4:     function multiply(uint256 a, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "405-411",
    "vulnerableCode": [
      "uint256 counter_7 =0;",
      "function checkUpdates_7() public{",
      "        require(counter_7<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_7 += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: library SafeMath {\n4:     function multiply(uint256 a, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "417-423",
    "vulnerableCode": [
      "address payable lastPlayer_23;",
      "      uint jackpot_23;",
      "      function buyTicket_23() public{",
      "        if (!(lastPlayer_23.send(jackpot_23)))",
      "        revert();",
      "      lastPlayer_23 = msg.sender;",
      "      jackpot_23    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: library SafeMath {\n4:     function multiply(uint256 a, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "430-436",
    "vulnerableCode": [
      "uint256 counter_14 =0;",
      "function checkUpdates_14() public{",
      "        require(counter_14<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_14 += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: library SafeMath {\n4:     function multiply(uint256 a, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "442-448",
    "vulnerableCode": [
      "address payable lastPlayer_30;",
      "      uint jackpot_30;",
      "      function buyTicket_30() public{",
      "        if (!(lastPlayer_30.send(jackpot_30)))",
      "        revert();",
      "      lastPlayer_30 = msg.sender;",
      "      jackpot_30    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: library SafeMath {\n4:     function multiply(uint256 a, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "454-459",
    "vulnerableCode": [
      "mapping(address => uint) balances_8;",
      "    function withdraw_balances_8 () public {",
      "       (bool success,) = msg.sender.call.value(balances_8[msg.sender ])(\"\");",
      "       if (success)",
      "          balances_8[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: library SafeMath {\n4:     function multiply(uint256 a, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "476-480",
    "vulnerableCode": [
      "mapping(address => uint) balances_36;",
      "    function withdraw_balances_36 () public {",
      "       if (msg.sender.send(balances_36[msg.sender ]))",
      "          balances_36[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: library SafeMath {\n4:     function multiply(uint256 a, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "494-500",
    "vulnerableCode": [
      "uint256 counter_35 =0;",
      "function checkUpdates_35() public{",
      "        require(counter_35<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_35 += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: library SafeMath {\n4:     function multiply(uint256 a, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "506-515",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_40;",
      "function withdrawBalance_40() public{",
      "",
      "",
      "        (bool success,)=msg.sender.call.value(userBalance_40[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_40[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: library SafeMath {\n4:     function multiply(uint256 a, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "523-532",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_33;",
      "function withdrawBalance_33() public{",
      "",
      "",
      "        (bool success,)= msg.sender.call.value(userBalance_33[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_33[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: library SafeMath {\n4:     function multiply(uint256 a, u"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "478-478",
    "vulnerableCode": [
      "if ( status == Status.PLAYING && timenow() > dateStopBuy ) status = Status.PROCESSING;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.18;\n2: \n3:  \n4: \n5: library SafeMathLib {\n6: \n7:   function time"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "203-203",
    "vulnerableCode": [
      "    rx.tokenFallback( msg.sender, value, data );"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.21;\n2: \n3: \n4: interface tokenRecipient {\n5:   function receiveApproval( ad"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1258-1258",
    "vulnerableCode": [
      "if (!address(admin).call.value(_com)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3DPlus is modularPlus {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1308-1308",
    "vulnerableCode": [
      "emit F3Devents.onPotSwapDeposit(_rID, msg.value);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3DPlus is modularPlus {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "271-273",
    "vulnerableCode": [
      "_dividends += referralBalance_[_customerAddress];",
      "referralBalance_[_customerAddress] = 0;",
      "_customerAddress.transfer(_dividends);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.21;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "218-220",
    "vulnerableCode": [
      "uint256 _tokens = _amountOfTokens;",
      "uint256 _ethereum = tokensToEthereum_(_tokens);",
      "uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.21;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "22-24",
    "vulnerableCode": [
      "if(msg.sender.call.value(_am)())",
      "acc.balance-=_am;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.25;\n2: \n3: contract WWW_WALLET\n4: {\n5:     function Put(uint _unlockTime)\n6"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "23",
    "vulnerableCode": [
      "            if(msg.sender.call.value(_am)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.25;\n2: \n3: contract WALLET\n4: {\n5:     function Put(uint _unlockTime)\n6:   "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1-121",
    "vulnerableCode": [
      "pragma solidity ^0.5.11;",
      "",
      "",
      "interface IERC777 {",
      "    ",
      "    function name() external view returns (string memory);",
      "",
      "    ",
      "    function symbol() external view returns (string memory);",
      "",
      "    ",
      "    function granularity() external view returns (uint256);",
      "",
      "    ",
      "    function totalSupply() external view returns (uint256);",
      "",
      "    ",
      "    function balanceOf(address owner) external view returns (uint256);",
      "",
      "    ",
      "    function send(address recipient, uint256 amount, bytes calldata data) external;",
      "",
      "    ",
      "    function burn(uint256 amount, bytes calldata data) external;",
      "",
      "    ",
      "    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);",
      "",
      "    ",
      "    function authorizeOperator(address operator) external;",
      "",
      "    ",
      "    function revokeOperator(address operator) external;",
      "",
      "    ",
      "    function defaultOperators() external view returns (address[] memory);",
      "",
      "    ",
      "    function operatorSend(",
      "        address sender,",
      "        address recipient,",
      "        uint256 amount,",
      "        bytes calldata data,",
      "        bytes calldata operatorData",
      "    ) external;",
      "",
      "    ",
      "    function operatorBurn(",
      "        address account,",
      "        uint256 amount,",
      "        bytes calldata data,",
      "        bytes calldata operatorData",
      "    ) external;",
      "",
      "    event Sent(",
      "        address indexed operator,",
      "        address indexed from,",
      "        address indexed to,",
      "        uint256 amount,",
      "        bytes data,",
      "        bytes operatorData",
      "    );",
      "",
      "    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);",
      "",
      "    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);",
      "",
      "    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);",
      "",
      "    event RevokedOperator(address indexed operator, address indexed tokenHolder);",
      "}",
      "",
      "interface IERC777Recipient {",
      "    ",
      "    function tokensReceived(",
      "        address operator,",
      "        address from,",
      "        address to,",
      "        uint amount,",
      "        bytes calldata userData,",
      "        bytes calldata operatorData",
      "    ) external;",
      "}",
      "",
      "interface IERC777Sender {",
      "    ",
      "    function tokensToSend(",
      "        address operator,",
      "        address from,",
      "        address to,",
      "        uint amount,",
      "        bytes calldata userData,",
      "        bytes calldata operatorData",
      "    ) external;",
      "}",
      "",
      "interface IERC20 {",
      "    ",
      "    function totalSupply() external view returns (uint256);",
      "",
      "    ",
      "    function balanceOf(address account) external view returns (uint256);",
      "",
      "    ",
      "    function transfer(address recipient, uint256 amount) external returns (bool);",
      "",
      "    ",
      "    function allowance(address owner, address spender) external view returns (uint256);",
      "",
      "    ",
      "    function approve(address spender, uint256 amount) external returns (bool);",
      "",
      "    ",
      "    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);",
      "",
      "    ",
      "    event Transfer(address indexed from, address indexed to, uint256 value);",
      "",
      "    ",
      "    event Approval(address indexed owner, address indexed spender, uint256 value);",
      "}"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "321-327",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_18;",
      "function claimReward_18() public {        ",
      "        require(redeemableEther_18[msg.sender] > 0);",
      "        uint transferValue_18 = redeemableEther_18[msg.sender];",
      "        msg.sender.transfer(transferValue_18);   ",
      "        redeemableEther_18[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "333-337",
    "vulnerableCode": [
      "mapping(address => uint) balances_29;",
      "    function withdraw_balances_29 () public {",
      "       if (msg.sender.send(balances_29[msg.sender ]))",
      "          balances_29[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "348-355",
    "vulnerableCode": [
      "bool callcount_6 = true;",
      "function checkingbalance_6() public{",
      "        require(callcount_6);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcount_6 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "369-376",
    "vulnerableCode": [
      "address payable lastPlayer_16;",
      "      uint jackpot_16;",
      "      function buyTicket_16() public{",
      "        if (!(lastPlayer_16.send(jackpot_16)))",
      "        revert();",
      "      lastPlayer_16 = msg.sender;",
      "      jackpot_16    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "401-407",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_5;",
      "function withdrawBalance_5() public{",
      "        if( ! (msg.sender.send(userBalance_5[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalance_5[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "422-426",
    "vulnerableCode": [
      "mapping(address => uint) balances_15;",
      "    function withdraw_balances_15 () public {",
      "       if (msg.sender.send(balances_15[msg.sender ]))",
      "          balances_15[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "433-440",
    "vulnerableCode": [
      "uint256 counter_28 =0;",
      "function checkcall_28() public{",
      "        require(counter_28<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_28 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "446-453",
    "vulnerableCode": [
      "bool callcount_34 = true;",
      "function checkingbalance_34() public{",
      "        require(callcount_34);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcount_34 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "461-468",
    "vulnerableCode": [
      "uint256 counter_21 =0;",
      "function checkcall_21() public{",
      "        require(counter_21<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_21 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "486-491",
    "vulnerableCode": [
      "mapping(address => uint) balances_10;",
      "function withdrawFunds_10 (uint256 _weiToWithdraw) public {",
      "        require(balances_10[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_10[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "542-548",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_12;",
      "function withdrawBalance_12() public{",
      "        if( ! (msg.sender.send(userBalance_12[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalance_12[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "571-577",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_11;",
      "function claimReward_11() public {        ",
      "        require(redeemableEther_11[msg.sender] > 0);",
      "        uint transferValue_11 = redeemableEther_11[msg.sender];",
      "        msg.sender.transfer(transferValue_11);   ",
      "        redeemableEther_11[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "595-600",
    "vulnerableCode": [
      "mapping(address => uint) balances_1;",
      "    function withdraw_balances_1 () public {",
      "       (bool success,) =msg.sender.call.value(balances_1[msg.sender ])(\"\");",
      "       if (success)",
      "          balances_1[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "611-618",
    "vulnerableCode": [
      "bool callcount_41 = true;",
      "function checkingbalance_41() public{",
      "        require(callcount_41);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcount_41 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "664-670",
    "vulnerableCode": [
      "address payable lastPlayer_2;",
      "      uint jackpot_2;",
      "      function buyTicket_2() public{",
      "        if (!(lastPlayer_2.send(jackpot_2)))",
      "        revert();",
      "      lastPlayer_2 = msg.sender;",
      "      jackpot_2    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "701-707",
    "vulnerableCode": [
      "  uint256 counter_35 =0;",
      "function checkcall_35() public{",
      "        require(counter_35<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_35 += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "710-717",
    "vulnerableCode": [
      "  mapping(address => uint) userBalance_40;",
      "function withdrawBalance_40() public{",
      "        (bool success,)=msg.sender.call.value(userBalance_40[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_40[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "725-730",
    "vulnerableCode": [
      "mapping(address => uint) balances_17;",
      "function withdrawFunds_17 (uint256 _weiToWithdraw) public {",
      "        require(balances_17[msg.sender] >= _weiToWithdraw);",
      "        (bool success,)=msg.sender.call.value(_weiToWithdraw)(\"\");",
      "        require(success);  ",
      "        balances_17[msg.sender] -= _weiToWithdraw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "741-747",
    "vulnerableCode": [
      "address payable lastPlayer_37;",
      "      uint jackpot_37;",
      "      function buyTicket_37() public{",
      "        if (!(lastPlayer_37.send(jackpot_37)))",
      "        revert();",
      "      lastPlayer_37 = msg.sender;",
      "      jackpot_37    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "764-772",
    "vulnerableCode": [
      "address payable lastPlayer_9;",
      "      uint jackpot_9;",
      "      function buyTicket_9() public{",
      "        (bool success,) = lastPlayer_9.call.value(jackpot_9)(\"\");",
      "        if (!success)",
      "            revert();",
      "      lastPlayer_9 = msg.sender;",
      "      jackpot_9    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "778-783",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_25;",
      "function claimReward_25() public {        ",
      "        require(redeemableEther_25[msg.sender] > 0);",
      "        uint transferValue_25 = redeemableEther_25[msg.sender];",
      "        msg.sender.transfer(transferValue_25);   ",
      "        redeemableEther_25[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "790-796",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_19;",
      "function withdrawBalance_19() public{",
      "        if( ! (msg.sender.send(userBalance_19[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalance_19[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "802-808",
    "vulnerableCode": [
      "  mapping(address => uint) userBalance_33;",
      "function withdrawBalance_33() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_33[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_33[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "811-817",
    "vulnerableCode": [
      "  bool callcount_27 = true;",
      "function checkingbalance_27() public{",
      "        require(callcount_27);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcount_27 = false;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "826-833",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_26;",
      "function withdrawBalance_26() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_26[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_26[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "843-849",
    "vulnerableCode": [
      "bool callcount_20 = true;",
      "function checkingbalance_20() public{",
      "        require(callcount_20);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcount_20 = false;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "855-860",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_32;",
      "function claimReward_32() public {        ",
      "        require(redeemableEther_32[msg.sender] > 0);",
      "        uint transferValue_32 = redeemableEther_32[msg.sender];",
      "        msg.sender.transfer(transferValue_32);   ",
      "        redeemableEther_32[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "866-870",
    "vulnerableCode": [
      "mapping(address => uint) balances_38;",
      "function withdrawFunds_38 (uint256 _weiToWithdraw) public {",
      "        require(balances_38[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_38[msg.sender] -= _weiToWithdraw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "877-883",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_4;",
      "function claimReward_4() public {        ",
      "        require(redeemableEther_4[msg.sender] > 0);",
      "        uint transferValue_4 = redeemableEther_4[msg.sender];",
      "        msg.sender.transfer(transferValue_4);   ",
      "        redeemableEther_4[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "889-896",
    "vulnerableCode": [
      "uint256 counter_7 =0;",
      "function checkcall_7() public{",
      "        require(counter_7<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_7 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "901-906",
    "vulnerableCode": [
      "  mapping(address => uint) balances_31;",
      "function withdrawFunds_31 (uint256 _weiToWithdraw) public {",
      "        require(balances_31[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_31[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "910-918",
    "vulnerableCode": [
      "  bool callcount_13 = true;",
      "function checkingbalance_13() public{",
      "        require(callcount_13);",
      "        (bool success,)=msg.sender.call.value(1 ether)(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        callcount_13 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "927-934",
    "vulnerableCode": [
      "address payable lastPlayer_23;",
      "      uint jackpot_23;",
      "      function buyTicket_23() public{",
      "        if (!(lastPlayer_23.send(jackpot_23)))",
      "        revert();",
      "      lastPlayer_23 = msg.sender;",
      "      jackpot_23    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "940-947",
    "vulnerableCode": [
      "uint256 counter_14 =0;",
      "function checkcall_14() public{",
      "        require(counter_14<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_14 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "966-973",
    "vulnerableCode": [
      "address payable lastPlayer_30;",
      "      uint jackpot_30;",
      "      function buyTicket_30() public{",
      "        if (!(lastPlayer_30.send(jackpot_30)))",
      "        revert();",
      "      lastPlayer_30 = msg.sender;",
      "      jackpot_30    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "980-985",
    "vulnerableCode": [
      "mapping(address => uint) balances_8;",
      "    function withdraw_balances_8 () public {",
      "       (bool success,) = msg.sender.call.value(balances_8[msg.sender ])(\"\");",
      "       if (success)",
      "          balances_8[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1010-1014",
    "vulnerableCode": [
      "mapping(address => uint) balances_36;",
      "    function withdraw_balances_36 () public {",
      "       if (msg.sender.send(balances_36[msg.sender ]))",
      "          balances_36[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: \n4: interface IERC777 {\n5:     \n6:     function name() external "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "209-209",
    "vulnerableCode": [
      "require(_endTime > block.timestamp);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract NXX is ERC223, Pausable {\n2: \n3: \tusing SafeMath for uint256;\n4: \tusing Cont"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "249-250",
    "vulnerableCode": [
      "require(block.timestamp > starttime[_address]);",
      "require(block.timestamp < endtime[_address]);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract NXX is ERC223, Pausable {\n2: \n3: \tusing SafeMath for uint256;\n4: \tusing Cont"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "319-319",
    "vulnerableCode": [
      "if (walletTransaction.destination.call.value(walletTransaction.value)(walletTransaction.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.15;\n2: \n3: \n4: \n5: \n6: \n7: \n8: contract RNTMultiSigWallet {\n9:     \n10: \n11"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "221-224",
    "vulnerableCode": [
      "if(!playerTempAddress[myid].send(playerTempBetValue[myid])){",
      "LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempBetValue[myid], 4, proof);",
      "playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempBetValue[myid]);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "360-360",
    "vulnerableCode": [
      "if (msg.sender.call.value(withdrawAmount)()) {"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "442-442",
    "vulnerableCode": [
      "if(!sendTo.send(amount)) throw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "460-460",
    "vulnerableCode": [
      "if(!sendTo.send(originalPlayerBetValue)) throw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "221-221",
    "vulnerableCode": [
      "require((stakeCommence <= 0) && (timestamp >= chainStartTime));"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract tipbot is ERC20,tipbotreg,Ownable {\n2: \n3:         using SafeMath for uint25"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "233-233",
    "vulnerableCode": [
      "if (txn.destination.call.value(txn.value)(txn.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity 0.4.18;\n2: \n3: \n4: \n5: \n6: contract MultiSigWallet {\n7: \n8:     \n9: \n10: \n11:   "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "295-295",
    "vulnerableCode": [
      "winner.transfer(ethToTransfer);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "306-306",
    "vulnerableCode": [
      "requester.transfer(ethToTransfer);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "38-38",
    "vulnerableCode": [
      "require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\");"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: contract MultiBuyer is CanReclaimTo"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "91-91",
    "vulnerableCode": [
      "require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\");"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: contract MultiBuyer is CanReclaimTo"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "141-141",
    "vulnerableCode": [
      "require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\");"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: contract MultiBuyer is CanReclaimTo"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "188-188",
    "vulnerableCode": [
      "require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\");"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: contract MultiBuyer is CanReclaimTo"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "38-43",
    "vulnerableCode": [
      "require(_lockupEndTime[0] >= block.timestamp);",
      "require(_lockupEndTime[1] >= _lockupEndTime[0]);",
      "require(_lockupEndTime[2] >= _lockupEndTime[1]);",
      "require(_lockupEndTime[3] >= _lockupEndTime[2]);",
      "require(_lockupEndTime[4] >= _lockupEndTime[3]);",
      "require(_lockupEndTime[5] >= _lockupEndTime[4]);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract CareerChainPrivateSale is TimedCrowdsale, WhitelistedCrowdsale  {\n2:     usi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "2-2",
    "vulnerableCode": [
      "uint8 public count = 0;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract LoopCounter {\n2:  uint8 public count = 0;\n3:  function loopIncrement(uin"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1002-1002",
    "vulnerableCode": [
      "if (!address(One_Island_Inc).call.value(_com)(bytes4(keccak256(\"deposit()\"))))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract SpicyPot is modularLong {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "501-501",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract SpicyPot is modularLong {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "196-197",
    "vulnerableCode": [
      "whale.call.value(amount)(bytes4(keccak256(\"donate()\")));",
      "totalDonated += amount;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.21;\n2: \n3: \n4: \n5: \n6: \n7: \n8: contract PoCGame\n9: {\n10:     \n11:     \n12: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "207-208",
    "vulnerableCode": [
      "whale.call.value(amount)(bytes4(keccak256(\"donate()\")));",
      "totalDonated += amount;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.21;\n2: \n3: \n4: \n5: \n6: \n7: \n8: contract PoCGame\n9: {\n10:     \n11:     \n12: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "399-399",
    "vulnerableCode": [
      "if (!address(coin_base).call.value(_com)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F3DGame is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "415-415",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F3DGame is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "444-444",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F3DGame is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "129-129",
    "vulnerableCode": [
      "buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F3DGame is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "172-172",
    "vulnerableCode": [
      "buyCore(_pID, _affCode, _team, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F3DGame is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "213-213",
    "vulnerableCode": [
      "buyCore(_pID, _affID, _team, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F3DGame is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "296-296",
    "vulnerableCode": [
      "reLoadCore(_pID, _affCode, _team, _eth, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F3DGame is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "336-336",
    "vulnerableCode": [
      "reLoadCore(_pID, _affID, _team, _eth, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F3DGame is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "412-412",
    "vulnerableCode": [
      "_eth = withdrawEarnings(_pID);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F3DGame is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "440-440",
    "vulnerableCode": [
      "_eth = withdrawEarnings(_pID);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract F3DGame is modularShort {\n4:     using SafeMath for *;\n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "142-142",
    "vulnerableCode": [
      "if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)) )"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract SCardLong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFil"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "222-222",
    "vulnerableCode": [
      "if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract SCardLong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFil"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "290-290",
    "vulnerableCode": [
      "if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract SCardLong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFil"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "454-454",
    "vulnerableCode": [
      "if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract SCardLong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFil"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "329-329",
    "vulnerableCode": [
      "if (_now < round_[_rID].end)"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract SCardLong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFil"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "377-377",
    "vulnerableCode": [
      "if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract SCardLong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFil"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "532-532",
    "vulnerableCode": [
      "emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract SCardLong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFil"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "278-278",
    "vulnerableCode": [
      "uint256 _now = now;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract SCardLong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFil"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "331-331",
    "vulnerableCode": [
      "emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract SCardLong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFil"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "364-364",
    "vulnerableCode": [
      "emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract SCardLong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFil"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1010-1011",
    "vulnerableCode": [
      "round_[1].strt = now + rndExtra_ - rndGap_;",
      "round_[1].end = now + rndInit_ + rndExtra_;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract SCardLong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFil"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "828-829",
    "vulnerableCode": [
      "round_[_rID].strt = now;",
      "round_[_rID].end = now.add(rndInit_).add(rndGap_);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract SCardLong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFil"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "851-851",
    "vulnerableCode": [
      "uint256 _now = now;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract SCardLong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFil"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "678-678",
    "vulnerableCode": [
      "uint256 _now = now;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract SCardLong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFil"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "692-692",
    "vulnerableCode": [
      "uint256 _now = now;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract SCardLong is modularLong {\n2:     using SafeMath for *;\n3:     using NameFil"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "73-76",
    "vulnerableCode": [
      "",
      "  function incrementAnotherCounter(uint8 p_value) public{",
      "    uint8 counter=0;",
      "    counter = counter + p_value;   "
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract TAMC {\n4:   mapping(address => uint) bal"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "237-242",
    "vulnerableCode": [
      "            playerTempReward[myid] = playerProfit[myid];",
      "            playerProfit[myid] = 0;",
      "            maxPendingPayouts = safeSub(maxPendingPayouts, playerTempReward[myid]);",
      "            playerTempBetValue[myid] = playerBetValue[myid];"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.18;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "253-256",
    "vulnerableCode": [
      "            totalBets += 1;",
      "            totalWeiWagered += playerTempBetValue[myid];"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.18;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "275-278",
    "vulnerableCode": [
      "            if(!playerTempAddress[myid].send(playerTempBetValue[myid])){",
      "                playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempBetValue[myid]);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.18;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "322-325",
    "vulnerableCode": [
      "            if(!playerTempAddress[myid].send(playerTempReward[myid])){",
      "                playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempReward[myid]);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.18;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "355-358",
    "vulnerableCode": [
      "            if(!playerTempAddress[myid].send(1)){",
      "                playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], 1);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.18;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "377-378",
    "vulnerableCode": [
      "            if (msg.sender.call.value(withdrawAmount)()) {"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.18;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "496-496",
    "vulnerableCode": [
      "            if(!sendTo.send(originalPlayerBetValue)) throw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.18;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "66-67",
    "vulnerableCode": [
      "startTime = block.timestamp;",
      "endTime = startTime + 365 days;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract XTVToken is XTVNetworkGuard, ERC20Token {\n2:   using SafeMath for uint256;\n3"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "96-98",
    "vulnerableCode": [
      "require(block.timestamp < endTime);",
      "claimed[msg.sender] = true;",
      "return balances[msg.sender];"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract XTVToken is XTVNetworkGuard, ERC20Token {\n2:   using SafeMath for uint256;\n3"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "262-265",
    "vulnerableCode": [
      "if(_tokens > 0) sell(_tokens);",
      "withdraw();"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.21;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "287-289",
    "vulnerableCode": [
      "_customerAddress.transfer(_dividends);",
      "onWithdraw(_customerAddress, _dividends);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.21;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "259-262",
    "vulnerableCode": [
      "if(!playerTempAddress[myid].send(playerTempBetValue[myid])){",
      "    LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempBetValue[myid], 4, proof);",
      "    playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempBetValue[myid]);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.17;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "295-298",
    "vulnerableCode": [
      "if(!playerTempAddress[myid].send(playerTempReward[myid])){",
      "    LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempReward[myid], 2, proof);",
      "    playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempReward[myid]);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.17;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "327-330",
    "vulnerableCode": [
      "if(!playerTempAddress[myid].send(1)){",
      "    playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], 1);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.17;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "349-354",
    "vulnerableCode": [
      "if (msg.sender.call.value(withdrawAmount)()) {",
      "    return true;",
      "} else {",
      "    playerPendingWithdrawals[msg.sender] = withdrawAmount;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.17;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "431-431",
    "vulnerableCode": [
      "if(!sendTo.send(amount)) throw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.17;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "449-449",
    "vulnerableCode": [
      "if(!sendTo.send(originalPlayerBetValue)) throw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.17;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "434-434",
    "vulnerableCode": [
      "if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256(\"deposit()\"))))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "534-534",
    "vulnerableCode": [
      "if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256(\"deposit()\"))))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "604-604",
    "vulnerableCode": [
      "_addr.transfer(_bonus);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "419-419",
    "vulnerableCode": [
      "(bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "13-17",
    "vulnerableCode": [
      "address winner_3;",
      "function play_3(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_3 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   function balances_21() view"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "215-223",
    "vulnerableCode": [
      "  uint256 balancesv_5 = block.timestamp;",
      "  event ProposalAdded(uint proposalID, address recipient, uint amount, string description);",
      "  uint256 balancesv_1 = block.timestamp;",
      "  event Voted(uint proposalID, bool position, address voter);",
      "  uint256 balancesv_2 = block.timestamp;",
      "  event ProposalTallied(uint proposalID, uint result, uint quorum, bool active);",
      "  uint256 balancesv_3 = block.timestamp;",
      "  event ChangeOfRules(uint newMinimumTokensToVote, uint newMinimumQuorum, uint newDebatingPeriodInMinutes, address newTokenAddress, address newChairmanAddress);",
      "  uint256 balancesv_4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   function balances_21() view"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "324-328",
    "vulnerableCode": [
      "address winner_39;",
      "function play_39(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_39 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   function balances_21() view"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "370-373",
    "vulnerableCode": [
      "address winner_35;",
      "function play_35(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   function balances_21() view"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "368-368",
    "vulnerableCode": [
      "                plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract DogScam is modularDogScam {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "402-402",
    "vulnerableCode": [
      "                plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract DogScam is modularDogScam {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1170-1170",
    "vulnerableCode": [
      "        if (!address(DogKingCorp).call.value(_com)(bytes4(keccak256(\"deposit()\"))))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract DogScam is modularDogScam {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "22-29",
    "vulnerableCode": [
      "  bool not_called_ownerChange = true;",
      "function initiateOwnerChange() public {",
      "        require(not_called_ownerChange);",
      "        if( ! (msg.sender.send(1 ether))) {",
      "            revert();",
      "        }",
      "        not_called_ownerChange = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: contract Owned {\n4:   address payable lastPlayer_ticketBuyer;\n5"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "150-155",
    "vulnerableCode": [
      "  mapping(address => uint) redeemableEther_redeem;",
      "function claimRewardRedeem() public {        ",
      "        require(redeemableEther_redeem[msg.sender] > 0);",
      "        uint transferValue = redeemableEther_redeem[msg.sender];",
      "        msg.sender.transfer(transferValue);   ",
      "        redeemableEther_redeem[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: contract Owned {\n4:   address payable lastPlayer_ticketBuyer;\n5"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "159-164",
    "vulnerableCode": [
      "  mapping(address => uint) userBalance_withdrawable;",
      "function withdrawBalance() public {",
      "        if( ! (msg.sender.send(userBalance_withdrawable[msg.sender]))) {",
      "            revert();",
      "        }",
      "        userBalance_withdrawable[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: contract Owned {\n4:   address payable lastPlayer_ticketBuyer;\n5"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "176-181",
    "vulnerableCode": [
      "  mapping(address => uint) balances_staked;",
      "function withdrawFundsForStake (uint256 _weiToWithdraw) public {",
      "        require(balances_staked[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_staked[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: contract Owned {\n4:   address payable lastPlayer_ticketBuyer;\n5"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "215-221",
    "vulnerableCode": [
      "uint256 counter_transaction = 0;",
      "function trackTransaction() public {",
      "        require(counter_transaction <= 5);",
      "    if( ! (msg.sender.send(10 ether))) {",
      "            revert();",
      "        }",
      "        counter_transaction += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: contract Owned {\n4:   address payable lastPlayer_ticketBuyer;\n5"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "251-256",
    "vulnerableCode": [
      "mapping(address => uint) balances_withdrawable;",
      "    function withdrawFundsFromWithdrawable() public {",
      "       (bool success,) = msg.sender.call.value(balances_withdrawable[msg.sender])(\"\");",
      "       if (success)",
      "          balances_withdrawable[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: contract Owned {\n4:   address payable lastPlayer_ticketBuyer;\n5"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "261-267",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_custodialFunds;",
      "function claimRewardCustodialFunds() public {        ",
      "        require(redeemableEther_custodialFunds[msg.sender] > 0);",
      "        uint transferValue = redeemableEther_custodialFunds[msg.sender];",
      "        msg.sender.transfer(transferValue);   ",
      "        redeemableEther_custodialFunds[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: contract Owned {\n4:   address payable lastPlayer_ticketBuyer;\n5"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "272-276",
    "vulnerableCode": [
      "mapping(address => uint) balances_otherWithdrawals;",
      "    function withdrawFundsFromOtherWithdrawals() public {",
      "       if (msg.sender.send(balances_otherWithdrawals[msg.sender]))",
      "          balances_otherWithdrawals[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: contract Owned {\n4:   address payable lastPlayer_ticketBuyer;\n5"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "281-287",
    "vulnerableCode": [
      "uint256 counter_otherWithdraw = 0;",
      "function trackOtherWithdraw() public {",
      "        require(counter_otherWithdraw <= 5);",
      "    if( ! (msg.sender.send(10 ether))) {",
      "            revert();",
      "        }",
      "        counter_otherWithdraw += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: contract Owned {\n4:   address payable lastPlayer_ticketBuyer;\n5"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "293-300",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_withdrawable;",
      "function withdrawUserBalance() public {",
      "        (bool success,) = msg.sender.call.value(userBalance_withdrawable[msg.sender])(\"\");",
      "        if( ! success) {",
      "            revert();",
      "        }",
      "        userBalance_withdrawable[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: contract Owned {\n4:   address payable lastPlayer_ticketBuyer;\n5"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "307-314",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_redeemable;",
      "function withdrawUserBalanceRedeemable() public {",
      "        (bool success,) = msg.sender.call.value(userBalance_redeemable[msg.sender])(\"\");",
      "        if( ! success) {",
      "            revert();",
      "        }",
      "        userBalance_redeemable[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: contract Owned {\n4:   address payable lastPlayer_ticketBuyer;\n5"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "22-24",
    "vulnerableCode": [
      "            if(msg.sender.call.value(_am)())",
      "                acc.balance-=_am;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.25;\n2: \n3: contract MY_BANK\n4: {\n5:     function Put(uint _unlockTime)\n6:  "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "143-143",
    "vulnerableCode": [
      "timestamp: block.timestamp"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract CanonicalPriceFeed is OperatorStaking, SimplePriceFeed, CanonicalRegistrar {"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "239-239",
    "vulnerableCode": [
      "return (sub(now, timestamp) <= VALIDITY);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract CanonicalPriceFeed is OperatorStaking, SimplePriceFeed, CanonicalRegistrar {"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "79-84",
    "vulnerableCode": [
      "",
      "function transferBalanceExample2(address _to, uint _value) public returns (bool) {",
      "    require(balancesExample2[msg.sender] - _value >= 0);  ",
      "    balancesExample2[msg.sender] -= _value;  ",
      "    balancesExample2[_to] += _value;  ",
      "    return true;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     functi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "172-176",
    "vulnerableCode": [
      "mapping(address => uint) public lockTimeExample2;",
      "",
      "function increaseLockTimeExample2(uint _secondsToIncrease) public {",
      "        lockTimeExample2[msg.sender] += _secondsToIncrease;  ",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: interface tokenRecipient { \n4:     functi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "444-452",
    "vulnerableCode": [
      "playerPendingWithdrawals[msg.sender] = 0;",
      "if (msg.sender.call.value(withdrawAmount)()) {",
      "return true;",
      "} else {",
      "playerPendingWithdrawals[msg.sender] = withdrawAmount;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "261-273",
    "vulnerableCode": [
      "if(!playerTempAddress[myid].send(playerTempBetValue[myid])){",
      "LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempBetValue[myid], 4, proof);",
      "playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempBetValue[myid]);",
      "}",
      "if(!playerTempAddress[myid].send(playerTempReward[myid])){",
      "LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempReward[myid], 2, proof);",
      "playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempReward[myid]);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "489-490",
    "vulnerableCode": [
      "userBalance[msg.sender] = 0;",
      "msg.sender.transfer(toTransfer);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.25;\n2: \n3: library SafeMath {\n4: \n5: \tfunction mul(uint256 a, uint256 b) in"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "50-50",
    "vulnerableCode": [
      "  uint256 balancesv_5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "57-61",
    "vulnerableCode": [
      "address winner_11;",
      "function play_11(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_11 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "85-88",
    "vulnerableCode": [
      "address winner_18;",
      "function play_18(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_18 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "100-103",
    "vulnerableCode": [
      "address winner_2;",
      "function play_2(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_2 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "122-126",
    "vulnerableCode": [
      "address winner_3;",
      "function play_3(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_3 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "132-135",
    "vulnerableCode": [
      "address winner_6;",
      "function play_6(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_6 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "162-166",
    "vulnerableCode": [
      "address winner_15;",
      "function play_15(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_15 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "178-181",
    "vulnerableCode": [
      "address winner_34;",
      "function play_34(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_34 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "187-190",
    "vulnerableCode": [
      "address winner_10;",
      "function play_10(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_10 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "191-191",
    "vulnerableCode": [
      "  address public DanPanAddress = msg.sender;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "193-193",
    "vulnerableCode": [
      "  event DanPanPercentChanged(uint256 previousDanPanPercent, uint256 newDanPanPercent);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "195-195",
    "vulnerableCode": [
      "  event DanPanAddressChanged(address indexed previousDanPan, address indexed newDanPan);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "197-197",
    "vulnerableCode": [
      "  event WhitelistFrom(address _addr, bool _whitelisted);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "201-204",
    "vulnerableCode": [
      "  address winner_22;",
      "function play_22(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_22 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "234-238",
    "vulnerableCode": [
      "address winner_19;",
      "function play_19(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_19 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "243-246",
    "vulnerableCode": [
      "address winner_26;",
      "function play_26(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_26 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "320-323",
    "vulnerableCode": [
      "address winner_38;",
      "function play_38(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_38 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "346-350",
    "vulnerableCode": [
      "address winner_7;",
      "function play_7(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_7 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "394-398",
    "vulnerableCode": [
      "address winner_23;",
      "function play_23(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_23 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "406-409",
    "vulnerableCode": [
      "address winner_14;",
      "function play_14(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_14 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "417-420",
    "vulnerableCode": [
      "address winner_30;",
      "function play_30(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_30 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "440-444",
    "vulnerableCode": [
      "address winner_39;",
      "function play_39(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_39 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "468-472",
    "vulnerableCode": [
      "address winner_35;",
      "function play_35(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_35 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "501-505",
    "vulnerableCode": [
      "address winner_27;",
      "function play_27(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_27 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "511-515",
    "vulnerableCode": [
      "address winner_31;",
      "function play_31(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_31 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() externa"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "314-314",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract POHMO is PoHEVENTS {\n4:     using SafeMath for *;\n5:   "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "206-206",
    "vulnerableCode": [
      "if (tx.destination.call.value(tx.value)(tx.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity 0.4.11;\n2: \n3: \n4: \n5: \n6: contract MultiSigWallet {\n7: \n8:     uint constant pu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "241-242",
    "vulnerableCode": [
      "ownerance[_locker] = ownerance[_locker].add(lockedance[_locker] / (10 - i));",
      "lockedance[_locker] = lockedance[_locker].sub(lockedance[_locker] / (10 - i));"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract MntToken {\n2: \n3:     \n4:     event Transfer(address indexed from, addre"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "259-260",
    "vulnerableCode": [
      "ownerance[_locker] = ownerance[_locker].add(lockedance[_locker] / (11 - j));",
      "lockedance[_locker] = lockedance[_locker].sub(lockedance[_locker] / (11 - j));"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract MntToken {\n2: \n3:     \n4:     event Transfer(address indexed from, addre"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "414-414",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3DUnlimited is modularShort {\n4:     using SafeMath"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "771-771",
    "vulnerableCode": [
      "plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3DUnlimited is modularShort {\n4:     using SafeMath"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1251-1251",
    "vulnerableCode": [
      "if (!address(admin).call.value(_com)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3DUnlimited is modularShort {\n4:     using SafeMath"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "794-794",
    "vulnerableCode": [
      "plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3DUnlimited is modularShort {\n4:     using SafeMath"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "105-105",
    "vulnerableCode": [
      "require(_bankroller.call.value(_amount)(_sig));"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.23;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: interface IRegistry {\n12:     "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "91-94",
    "vulnerableCode": [
      "address winner_38;",
      "function play_38(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_38 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "233-237",
    "vulnerableCode": [
      "address winner_27;",
      "function play_27(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_27 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "298-299",
    "vulnerableCode": [
      "uint256 checkvaluesv_5 = block.timestamp;",
      ""
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "303-304",
    "vulnerableCode": [
      "uint256 checkvaluesv_1 = block.timestamp;",
      ""
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "308-309",
    "vulnerableCode": [
      "uint256 checkvaluesv_2 = block.timestamp;",
      ""
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "313-314",
    "vulnerableCode": [
      "uint256 checkvaluesv_3 = block.timestamp;",
      "}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "326-327",
    "vulnerableCode": [
      "uint256 checkvaluesv_4 = block.timestamp;",
      "}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "414-414",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "443-443",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "125-125",
    "vulnerableCode": [
      "buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "171-171",
    "vulnerableCode": [
      "buyCore(_pID, _affCode, _team, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "212-212",
    "vulnerableCode": [
      "buyCore(_pID, _affID, _team, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "295-295",
    "vulnerableCode": [
      "reLoadCore(_pID, _affCode, _team, _eth, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "335-335",
    "vulnerableCode": [
      "reLoadCore(_pID, _affID, _team, _eth, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "931-931",
    "vulnerableCode": [
      "_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "932-932",
    "vulnerableCode": [
      "_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1258-1258",
    "vulnerableCode": [
      "if (!address(admin).call.value(_com)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "257-259",
    "vulnerableCode": [
      "delete balances[investor];",
      "if(!(investor.call.value(amount)())) throw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: library SafeMath {\n2:   function mul(uint256 a, uint256 b) internal constant returns (uint256) {"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "391-395",
    "vulnerableCode": [
      "uint256 _now = now;",
      "uint256 _pID = pIDxAddr_[msg.sender];",
      "uint256 _eth;",
      "if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract GrandTheftFOMO is modularShort {\n4:     using SafeMath "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "23-23",
    "vulnerableCode": [
      "            if(msg.sender.call.value(_am)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.25;\n2: \n3: contract U_BANK\n4: {\n5:     function Put(uint _unlockTime)\n6:   "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "54-61",
    "vulnerableCode": [
      "  address payable lastPlayer_payment1;",
      "      uint jackpot_value1;",
      "      function buyTicket_payment1() public{",
      "        if (!(lastPlayer_payment1.send(jackpot_value1)))",
      "        revert();",
      "      lastPlayer_payment1 = msg.sender;",
      "      jackpot_value1    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "63-69",
    "vulnerableCode": [
      "  mapping(address => uint) balances_value3;",
      "function withdrawFunds_value3 (uint256 _weiToWithdraw) public {",
      "        require(balances_value3[msg.sender] >= _weiToWithdraw);",
      "    (bool success,)= msg.sender.call.value(_weiToWithdraw)(\"\");",
      "        require(success);  ",
      "        balances_value3[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "71-79",
    "vulnerableCode": [
      "  address payable lastPlayer_payment2;",
      "      uint jackpot_value2;",
      "      function buyTicket_payment2() public{",
      "        (bool success,) = lastPlayer_payment2.call.value(jackpot_value2)(\"\");",
      "        if (!success)",
      "            revert();",
      "      lastPlayer_payment2 = msg.sender;",
      "      jackpot_value2    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "81-87",
    "vulnerableCode": [
      "  mapping(address => uint) redeemableEther_value25;",
      "function claimReward_value25() public {        ",
      "        require(redeemableEther_value25[msg.sender] > 0);",
      "        uint transferValue_value25 = redeemableEther_value25[msg.sender];",
      "        msg.sender.transfer(transferValue_value25);   ",
      "        redeemableEther_value25[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "89-95",
    "vulnerableCode": [
      "  mapping(address => uint) userBalance_value19;",
      "function withdrawBalance_value19() public{",
      "        if( ! (msg.sender.send(userBalance_value19[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalance_value19[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "97-104",
    "vulnerableCode": [
      "  mapping(address => uint) userBalance_value26;",
      "function withdrawBalance_value26() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_value26[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_value26[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "113-120",
    "vulnerableCode": [
      "bool check_value20 = true;",
      "function initial_call_value20() public{",
      "        require(check_value20);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        check_value20 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "129-136",
    "vulnerableCode": [
      "  bool check_value13 = true;",
      "function initial_call_value13() public{",
      "        require(check_value13);",
      "        (bool success,)=msg.sender.call.value(1 ether)(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        check_value13 = false;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "143-148",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_value32;",
      "function claimReward_value32() public {        ",
      "        require(redeemableEther_value32[msg.sender] > 0);",
      "        uint transferValue_value32 = redeemableEther_value32[msg.sender];",
      "        msg.sender.transfer(transferValue_value32);   ",
      "        redeemableEther_value32[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "154-159",
    "vulnerableCode": [
      "mapping(address => uint) balances_value38;",
      "function withdrawFunds_value38 (uint256 _weiToWithdraw) public {",
      "        require(balances_value38[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_value38[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "163-168",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_value4;",
      "function claimReward_value4() public {        ",
      "        require(redeemableEther_value4[msg.sender] > 0);",
      "        uint transferValue_value4 = redeemableEther_value4[msg.sender];",
      "        msg.sender.transfer(transferValue_value4);   ",
      "        redeemableEther_value4[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "174-180",
    "vulnerableCode": [
      "uint256 counter_value7 =0;",
      "function callme_value7() public{",
      "        require(counter_value7<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_value7 += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "186-192",
    "vulnerableCode": [
      "address payable lastPlayer_payment23;",
      "      uint jackpot_value23;",
      "      function buyTicket_payment23() public{",
      "        if (!(lastPlayer_payment23.send(jackpot_value23)))",
      "        revert();",
      "      lastPlayer_payment23 = msg.sender;",
      "      jackpot_value23    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "199-205",
    "vulnerableCode": [
      "uint256 counter_value14 =0;",
      "function callme_value14() public{",
      "        require(counter_value14<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_value14 += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "211-217",
    "vulnerableCode": [
      "address payable lastPlayer_payment30;",
      "      uint jackpot_value30;",
      "      function buyTicket_payment30() public{",
      "        if (!(lastPlayer_payment30.send(jackpot_value30)))",
      "        revert();",
      "      lastPlayer_payment30 = msg.sender;",
      "      jackpot_value30    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "224-229",
    "vulnerableCode": [
      "mapping(address => uint) balances_value8;",
      "    function withdraw_balances_value8 () public {",
      "       (bool success,) = msg.sender.call.value(balances_value8[msg.sender ])(\"\");",
      "       if (success)",
      "          balances_value8[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "236-241",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_value39;",
      "function claimReward_value39() public {        ",
      "        require(redeemableEther_value39[msg.sender] > 0);",
      "        uint transferValue_value39 = redeemableEther_value39[msg.sender];",
      "        msg.sender.transfer(transferValue_value39);   ",
      "        redeemableEther_value39[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "248-252",
    "vulnerableCode": [
      "mapping(address => uint) balances_value36;",
      "    function withdraw_balances_value36 () public {",
      "       if (msg.sender.send(balances_value36[msg.sender ]))",
      "          balances_value36[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "258-265",
    "vulnerableCode": [
      "uint256 counter_value35 =0;",
      "function callme_value35() public{",
      "        require(counter_value35<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_value35 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "275-282",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_value40;",
      "function withdrawBalance_value40() public{",
      "        (bool success,)=msg.sender.call.value(userBalance_value40[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_value40[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "290-297",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_value33;",
      "function withdrawBalance_value33() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_value33[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_value33[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "301-308",
    "vulnerableCode": [
      "bool check_value27 = true;",
      "function initial_call_value27() public{",
      "        require(check_value27);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        check_value27 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: library SafeMath {\n4:  \n5:     function add(uint256 a, uint256 b)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "233-239",
    "vulnerableCode": [
      "bool balances_41 = true;",
      "function updates41() public{",
      "        require(balances_41);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        balances_41 = false;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "269-276",
    "vulnerableCode": [
      "address payable lastPlayer_2;",
      "      uint jackpot_2;",
      "      function buyTicket_2() public{",
      "        if (!(lastPlayer_2.send(jackpot_2)))",
      "        revert();",
      "      lastPlayer_2 = msg.sender;",
      "      jackpot_2    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "287-293",
    "vulnerableCode": [
      "mapping(address => uint) balances_17;",
      "function withdrawFunds_17 (uint256 _weiToWithdraw) public {",
      "        require(balances_17[msg.sender] >= _weiToWithdraw);",
      "        (bool success,)=msg.sender.call.value(_weiToWithdraw)(\"\");",
      "        require(success);  ",
      "        balances_17[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "298-305",
    "vulnerableCode": [
      "address payable lastPlayer_37;",
      "      uint jackpot_37;",
      "      function buyTicket_37() public{",
      "        if (!(lastPlayer_37.send(jackpot_37)))",
      "        revert();",
      "      lastPlayer_37 = msg.sender;",
      "      jackpot_37    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "319-325",
    "vulnerableCode": [
      "mapping(address => uint) balances_3;",
      "function withdrawFunds_3 (uint256 _weiToWithdraw) public {",
      "        require(balances_3[msg.sender] >= _weiToWithdraw);",
      "    (bool success,)= msg.sender.call.value(_weiToWithdraw)(\"\");",
      "        require(success);  ",
      "        balances_3[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "354-362",
    "vulnerableCode": [
      "address payable lastPlayer_9;",
      "      uint jackpot_9;",
      "      function buyTicket_9() public{",
      "        (bool success,) = lastPlayer_9.call.value(jackpot_9)(\"\");",
      "        if (!success)",
      "            revert();",
      "      lastPlayer_9 = msg.sender;",
      "      jackpot_9    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "395-400",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_25;",
      "function claimReward_25() public {        ",
      "        require(redeemableEther_25[msg.sender] > 0);",
      "        uint transferValue_25 = redeemableEther_25[msg.sender];",
      "        msg.sender.transfer(transferValue_25);   ",
      "        redeemableEther_25[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "416-421",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_19;",
      "function withdrawBalance_19() public{",
      "        if( ! (msg.sender.send(userBalance_19[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalance_19[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "432-438",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_26;",
      "function withdrawBalance_26() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_26[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_26[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "449-455",
    "vulnerableCode": [
      "bool balances_20 = true;",
      "function updates20() public{",
      "        require(balances_20);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        balances_20 = false;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "466-471",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_32;",
      "function claimReward_32() public {        ",
      "        require(redeemableEther_32[msg.sender] > 0);",
      "        uint transferValue_32 = redeemableEther_32[msg.sender];",
      "        msg.sender.transfer(transferValue_32);   ",
      "        redeemableEther_32[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "559-564",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_4;",
      "function claimReward_4() public {        ",
      "        require(redeemableEther_4[msg.sender] > 0);",
      "        uint transferValue_4 = redeemableEther_4[msg.sender];",
      "        msg.sender.transfer(transferValue_4);   ",
      "        redeemableEther_4[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "606-612",
    "vulnerableCode": [
      "address payable lastPlayer_23;",
      "      uint jackpot_23;",
      "      function buyTicket_23() public{",
      "        if (!(lastPlayer_23.send(jackpot_23)))",
      "        revert();",
      "      lastPlayer_23 = msg.sender;",
      "      jackpot_23    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "623-630",
    "vulnerableCode": [
      "uint256 counter_14 =0;",
      "function checking_14() public{",
      "        require(counter_14<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_14 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "641-648",
    "vulnerableCode": [
      "address payable lastPlayer_30;",
      "      uint jackpot_30;",
      "      function buyTicket_30() public{",
      "        if (!(lastPlayer_30.send(jackpot_30)))",
      "        revert();",
      "      lastPlayer_30 = msg.sender;",
      "      jackpot_30    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "667-672",
    "vulnerableCode": [
      "mapping(address => uint) balances_8;",
      "    function withdraw_balances_8 () public {",
      "       (bool success,) = msg.sender.call.value(balances_8[msg.sender ])(\"\");",
      "       if (success)",
      "          balances_8[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "678-684",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_39;",
      "function claimReward_39() public {        ",
      "        require(redeemableEther_39[msg.sender] > 0);",
      "        uint transferValue_39 = redeemableEther_39[msg.sender];",
      "        msg.sender.transfer(transferValue_39);   ",
      "        redeemableEther_39[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "706-710",
    "vulnerableCode": [
      "mapping(address => uint) balances_36;",
      "    function withdraw_balances_36 () public {",
      "       if (msg.sender.send(balances_36[msg.sender ]))",
      "          balances_36[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "732-739",
    "vulnerableCode": [
      "uint256 counter_35 =0;",
      "function checking_35() public{",
      "        require(counter_35<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_35 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "761-768",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_40;",
      "function withdrawBalance_40() public{",
      "        (bool success,)=msg.sender.call.value(userBalance_40[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_40[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "820-827",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_33;",
      "function withdrawBalance_33() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_33[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_33[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "835-842",
    "vulnerableCode": [
      "bool balances_27 = true;",
      "function updates27() public{",
      "        require(balances_27);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        balances_27 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "880-885",
    "vulnerableCode": [
      "mapping(address => uint) balances_31;",
      "function withdrawFunds_31 (uint256 _weiToWithdraw) public {",
      "        require(balances_31[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_31[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "897-905",
    "vulnerableCode": [
      "bool balances_13 = true;",
      "function updates13() public{",
      "        require(balances_13);",
      "        (bool success,)=msg.sender.call.value(1 ether)(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        balances_13 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: library SafeMath {\n4:     function add(uint256 a, uint256 b) inte"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "168-181",
    "vulnerableCode": [
      "if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)",
      "{",
      "    F3Ddatasets.EventReturns memory _eventData_;",
      "    round_[_rID].ended = true;",
      "    _eventData_ = endRound(_eventData_);",
      "    _eth = withdrawEarnings(_pID);",
      "    if (_eth > 0)",
      "        plyr_[_pID].addr.transfer(_eth);",
      "    _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);",
      "    _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;",
      "    emit F3Devents.onWithdrawAndDistribute"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FUMO is modularShort {\n4:     using SafeMath for *;\n5: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "126-126",
    "vulnerableCode": [
      "  uint256 updatesv_2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9: \n10"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "128-128",
    "vulnerableCode": [
      "  uint256 updatesv_3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9: \n10"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "135-137",
    "vulnerableCode": [
      "function updates_9() view public returns (bool) {",
      "    return block.timestamp >= 1546300800;",
      "  }"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9: \n10"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "152-155",
    "vulnerableCode": [
      "address winner_26;",
      "function play_26(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_26 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9: \n10"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "156-156",
    "vulnerableCode": [
      "  uint256 updatesv_4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9: \n10"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "247-249",
    "vulnerableCode": [
      "function play_38(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_38 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9: \n10"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "287-287",
    "vulnerableCode": [
      "uint256 updatesv_5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9: \n10"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "297-299",
    "vulnerableCode": [
      "  function updates_21() view public returns (bool) {",
      "    return block.timestamp >= 1546300800;",
      "  }"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9: \n10"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "302-304",
    "vulnerableCode": [
      "function play_10(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_10 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9: \n10"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "311-313",
    "vulnerableCode": [
      "function play_22(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_22 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9: \n10"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "333-336",
    "vulnerableCode": [
      "function play_7(uint startTime) public {",
      "    uint _param = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _param){",
      "        winner_7 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9: \n10"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "344-347",
    "vulnerableCode": [
      "function play_23(uint startTime) public {",
      "    uint _param = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _param){",
      "        winner_23 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9: \n10"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "406-409",
    "vulnerableCode": [
      "function play_35(uint startTime) public {",
      "    uint _param = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _param){",
      "        winner_35 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9: \n10"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "427-429",
    "vulnerableCode": [
      "function updates_33() view public returns (bool) {",
      "    return block.timestamp >= 1546300800;",
      "  }"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9: \n10"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "445-448",
    "vulnerableCode": [
      "function play_27(uint startTime) public {",
      "    uint _param = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _param){",
      "        winner_27 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9: \n10"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "454-457",
    "vulnerableCode": [
      "function play_31(uint startTime) public {",
      "    uint _param = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _param){",
      "        winner_31 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9: \n10"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "465-467",
    "vulnerableCode": [
      "function updates_13() view public returns (bool) {",
      "    return block.timestamp >= 1546300800;",
      "  }"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.23 <0.6.0;\n2: \n3: \n4: \n5: \n6: \n7: library SafeMath {\n8: \n9: \n10"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "438-438",
    "vulnerableCode": [
      "if (!address(admin).call.value(_com)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FomoSuper is modularShort {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "324-324",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FomoSuper is modularShort {\n4:     using SafeMath for *"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "89-95",
    "vulnerableCode": [
      "  mapping(address => uint) redeemableEther;",
      "function claimReward() public {        ",
      "        require(redeemableEther[msg.sender] > 0);",
      "        uint transferValue = redeemableEther[msg.sender];",
      "        msg.sender.transfer(transferValue);   ",
      "        redeemableEther[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "97-103",
    "vulnerableCode": [
      "  mapping(address => uint) userBalance;",
      "function withdrawBalance() public{",
      "        if( ! (msg.sender.send(userBalance[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalance[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "121-126",
    "vulnerableCode": [
      "mapping(address => uint) balancesAlt;",
      "function withdrawFundsAlt (uint256 _weiToWithdraw) public {",
      "        require(balancesAlt[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balancesAlt[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "132-138",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEtherLast;",
      "function claimRewardLast() public {        ",
      "        require(redeemableEtherLast[msg.sender] > 0);",
      "        uint transferValue = redeemableEtherLast[msg.sender];",
      "        msg.sender.transfer(transferValue);   ",
      "        redeemableEtherLast[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "145-152",
    "vulnerableCode": [
      "uint256 counterAlt = 0;",
      "function callMe() public{",
      "        require(counterAlt <= 5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counterAlt += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "158-165",
    "vulnerableCode": [
      "address payable lastPlayerAlt;",
      "      uint jackpotAlt;",
      "      function buyTicketAlt() public{",
      "        if (!(lastPlayerAlt.send(jackpotAlt)))",
      "        revert();",
      "      lastPlayerAlt = msg.sender;",
      "      jackpotAlt    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "170-177",
    "vulnerableCode": [
      "uint256 counterAnother = 0;",
      "function callMeAnother() public{",
      "        require(counterAnother <= 5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counterAnother += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "182-188",
    "vulnerableCode": [
      "address payable lastPlayerFinal;",
      "      uint jackpotFinal;",
      "      function buyTicketFinal() public{",
      "        if (!(lastPlayerFinal.send(jackpotFinal)))",
      "        revert();",
      "      lastPlayerFinal = msg.sender;",
      "      jackpotFinal    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "197-202",
    "vulnerableCode": [
      "mapping(address => uint) balancesUnique;",
      "    function withdrawFundsUnique () public {",
      "       (bool success,) = msg.sender.call.value(balancesUnique[msg.sender ])(\"\");",
      "       if (success)",
      "          balancesUnique[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "212-218",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEtherNew;",
      "function claimRewardNew() public {        ",
      "        require(redeemableEtherNew[msg.sender] > 0);",
      "        uint transferValue = redeemableEtherNew[msg.sender];",
      "        msg.sender.transfer(transferValue);   ",
      "        redeemableEtherNew[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "227-231",
    "vulnerableCode": [
      "mapping(address => uint) balancesUniqueFinal;",
      "    function withdrawFundsUniqueFinal () public {",
      "       if (msg.sender.send(balancesUniqueFinal[msg.sender ]))",
      "          balancesUniqueFinal[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "240-247",
    "vulnerableCode": [
      "uint256 counterFinal = 0;",
      "function callMeFinal() public{",
      "        require(counterFinal <= 5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counterFinal += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "253-260",
    "vulnerableCode": [
      "  mapping(address => uint) userBalanceAlt;",
      "function withdrawBalanceAlt() public{",
      "        (bool success,)= msg.sender.call.value(userBalanceAlt[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalanceAlt[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "268-275",
    "vulnerableCode": [
      "mapping(address => uint) userBalanceNew;",
      "function withdrawBalanceNew() public{",
      "        (bool success,)=msg.sender.call.value(userBalanceNew[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalanceNew[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "280-287",
    "vulnerableCode": [
      "mapping(address => uint) userBalanceFinished;",
      "function withdrawBalanceFinished() public{",
      "        (bool success,)= msg.sender.call.value(userBalanceFinished[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalanceFinished[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "292-299",
    "vulnerableCode": [
      "bool notCalled = true;",
      "function checkFunctionality() public{",
      "        require(notCalled);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        notCalled = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "313-320",
    "vulnerableCode": [
      "  bool notCalledSecond = true;",
      "function checkFunctionalitySecond() public{",
      "        require(notCalledSecond);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        notCalledSecond = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "327-335",
    "vulnerableCode": [
      "bool notCalledThird = true;",
      "function checkFunctionalityThird() public{",
      "        require(notCalledThird);",
      "        (bool success,)=msg.sender.call.value(1 ether)(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        notCalledThird = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.1;\n2: \n3: library SafeMath {\n4: \n5:     function mul(uint256 a, uint256 b) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "78-78",
    "vulnerableCode": [
      "userDeals.cancelTime = block.timestamp.add(requestCancelationTime);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract StreamityEscrow is Ownable, ReentrancyGuard {\n2:     using SafeMath for uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "168-168",
    "vulnerableCode": [
      "if (deal.cancelTime > block.timestamp)"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract StreamityEscrow is Ownable, ReentrancyGuard {\n2:     using SafeMath for uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "122-138",
    "vulnerableCode": [
      "// Access moderations for some functions have limits",
      "require(msg.sender == operator);",
      "// Given oversight might be missed in overall flow"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract Auction is SafeMath {\n4:     \n5:     struct TokenAuctio"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "89-97",
    "vulnerableCode": [
      "",
      "function increaseLockTime_33(uint _secondsToIncrease) public {",
      "        lockTime_33[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_33() public {",
      "        require(now > lockTime_33[msg.sender]);    ",
      "        uint transferValue_33 = 10;           ",
      "        msg.sender.transfer(transferValue_33);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.9;\n2:                                                      "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "134-142",
    "vulnerableCode": [
      "",
      "function increaseLockTime_1(uint _secondsToIncrease) public {",
      "        lockTime_1[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_1() public {",
      "        require(now > lockTime_1[msg.sender]);    ",
      "        uint transferValue_1 = 10;           ",
      "        msg.sender.transfer(transferValue_1);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.9;\n2:                                                      "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "153-158",
    "vulnerableCode": [
      "",
      "function transfer_2(address _to, uint _value) public returns (bool) {",
      "    require(balances_2[msg.sender] - _value >= 0);  ",
      "    balances_2[msg.sender] -= _value;  ",
      "    balances_2[_to] += _value;  ",
      "    return true;"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.9;\n2:                                                      "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "167-176",
    "vulnerableCode": [
      "mapping(address => uint) public lockTime_17;",
      "",
      "function increaseLockTime_17(uint _secondsToIncrease) public {",
      "        lockTime_17[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdraw_17() public {",
      "        require(now > lockTime_17[msg.sender]);    ",
      "        uint transferValue_17 = 10;           ",
      "        msg.sender.transfer(transferValue_17);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.9;\n2:                                                      "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "473-478",
    "vulnerableCode": [
      "mapping(address => uint) balances_14;",
      "",
      "function transfer_14(address _to, uint _value) public returns (bool) {",
      "    require(balances_14[msg.sender] - _value >= 0);  ",
      "    balances_14[msg.sender] -= _value;  ",
      "    balances_14[_to] += _value;  "
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.9;\n2:                                                      "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "488-493",
    "vulnerableCode": [
      "mapping(address => uint) balances_30;",
      "",
      "function transfer_30(address _to, uint _value) public returns (bool) {",
      "    require(balances_30[msg.sender] - _value >= 0);  ",
      "    balances_30[msg.sender] -= _value;  ",
      "    balances_30[_to] += _value;  "
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.9;\n2:                                                      "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "238-238",
    "vulnerableCode": [
      "if (tx.destination.call.value(tx.value)(tx.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract MultiSigWallet {\n2: \n3:     /*\n4:      *  Events\n5:      */\n6:     event Confirmation(a"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "383-383",
    "vulnerableCode": [
      "require(_user.call.value(_amt)());"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.23;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: interface IRegistry "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "246-246",
    "vulnerableCode": [
      "if (_doRefund) require(msg.sender.call.value(_bet)());"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.23;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: interface IRegistry "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "197-203",
    "vulnerableCode": [
      "playerTempBetValue[myid] = playerBetValue[myid];",
      "playerBetValue[myid] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.0;\n2: \n3: contract Bandit is usingOraclize, DSSafeAddSub {\n4: \n5: \t\n6: \n7: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "237-241",
    "vulnerableCode": [
      "if(!playerTempAddress[myid].send(playerTempBetValue[myid])){",
      "playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempBetValue[myid]);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.0;\n2: \n3: contract Bandit is usingOraclize, DSSafeAddSub {\n4: \n5: \t\n6: \n7: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "338-342",
    "vulnerableCode": [
      "if(!playerTempAddress[myid].send(playerTempReward[myid])){",
      "playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempReward[myid]);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.0;\n2: \n3: contract Bandit is usingOraclize, DSSafeAddSub {\n4: \n5: \t\n6: \n7: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "360-362",
    "vulnerableCode": [
      "if(!playerTempAddress[myid].send(1)){",
      "playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], 1);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.0;\n2: \n3: contract Bandit is usingOraclize, DSSafeAddSub {\n4: \n5: \t\n6: \n7: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "418-418",
    "vulnerableCode": [
      "if(!sendTo.send(originalPlayerBetValue)) throw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.0;\n2: \n3: contract Bandit is usingOraclize, DSSafeAddSub {\n4: \n5: \t\n6: \n7: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "254-260",
    "vulnerableCode": [
      "",
      "function transfer14(address _to, uint _value) public returns (bool) {",
      "    require(balances14[msg.sender] - _value >= 0);  ",
      "    balances14[msg.sender] -= _value;  ",
      "    balances14[_to] += _value;  ",
      "    return true;",
      "  }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: mapping(address => "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "268-275",
    "vulnerableCode": [
      "mapping(address => uint) balances30;",
      "",
      "function transfer30(address _to, uint _value) public returns (bool) {",
      "    require(balances30[msg.sender] - _value >= 0);  ",
      "    balances30[msg.sender] -= _value;  ",
      "    balances30[_to] += _value;  ",
      "    return true;",
      "  }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: mapping(address => "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "21-21",
    "vulnerableCode": [
      "  uint256 initialTimestamp = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract StockBet {\n4:     \n5:   address winnerAddres"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "23-23",
    "vulnerableCode": [
      "  uint256 creationTimestamp = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract StockBet {\n4:     \n5:   address winnerAddres"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "25-25",
    "vulnerableCode": [
      "  uint256 secondTimestamp = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract StockBet {\n4:     \n5:   address winnerAddres"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "28-28",
    "vulnerableCode": [
      "  uint256 thirdTimestamp = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract StockBet {\n4:     \n5:   address winnerAddres"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "30-30",
    "vulnerableCode": [
      "  uint256 fourthTimestamp = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract StockBet {\n4:     \n5:   address winnerAddres"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "68-71",
    "vulnerableCode": [
      "  address winnerAddress19;",
      "function playGame19(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract StockBet {\n4:     \n5:   address winnerAddres"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "101-104",
    "vulnerableCode": [
      "  address winnerAddress38;",
      "function playGame38(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerAddress38 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract StockBet {\n4:     \n5:   address winnerAddres"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "148-152",
    "vulnerableCode": [
      "address winnerAddress7;",
      "function playGame7(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress7 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract StockBet {\n4:     \n5:   address winnerAddres"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "159-163",
    "vulnerableCode": [
      "address winnerAddress23;",
      "function playGame23(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress23 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract StockBet {\n4:     \n5:   address winnerAddres"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "171-174",
    "vulnerableCode": [
      "address winnerAddress14;",
      "function playGame14(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerAddress14 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract StockBet {\n4:     \n5:   address winnerAddres"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "181-184",
    "vulnerableCode": [
      "address winnerAddress30;",
      "function playGame30(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerAddress30 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract StockBet {\n4:     \n5:   address winnerAddres"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "212-216",
    "vulnerableCode": [
      "address winnerAddress39;",
      "function playGame39(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress39 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract StockBet {\n4:     \n5:   address winnerAddres"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "254-258",
    "vulnerableCode": [
      "address winnerAddress35;",
      "function playGame35(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress35 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11;\n2: \n3: contract StockBet {\n4:     \n5:   address winnerAddres"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "414-414",
    "vulnerableCode": [
      "plyr_[_pID].addr.transfer(_eth);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: contract FoMo3Dshort is modularShort {\n4:     using SafeMath for"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1272-1272",
    "vulnerableCode": [
      "Divies.deposit.value(_p3d)();"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1278-1278",
    "vulnerableCode": [
      "Divies.deposit.value(_p3d)();"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1517-1517",
    "vulnerableCode": [
      "if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256(\"deposit()\"))))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1402-1402",
    "vulnerableCode": [
      "Divies.deposit.value(_p3d)();"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.24;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "266-270",
    "vulnerableCode": [
      "if (!playerTempAddress[myid].send(playerTempBetValue[myid])){",
      "LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempBetValue[myid], 4, proof);",
      "playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempBetValue[myid]);",
      "}"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "302-306",
    "vulnerableCode": [
      "if (!playerTempAddress[myid].send(playerTempReward[myid])){",
      "LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempReward[myid], 2, proof);",
      "playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempReward[myid]);",
      "}"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "356-363",
    "vulnerableCode": [
      "if (msg.sender.call.value(withdrawAmount)()) {",
      "return true;",
      "} else {",
      "playerPendingWithdrawals[msg.sender] = withdrawAmount;",
      "return false;",
      "}"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: \n6: \n7: \n8: \n9: \n10: \n11: \n12: \n13: \n14: \n15: \n16: \n17: \n"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "252-252",
    "vulnerableCode": [
      "if(!(investor.call.value(amount)())) throw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract PreICOProxyBuyer is Ownable, Haltable, SafeMath {\n2: \n3:   \n4:   uint public investorCo"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "48-48",
    "vulnerableCode": [
      "            if(msg.sender.call.value(_am)())"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.19;\n2: \n3: contract PRIVATE_ETH_CELL\n4: {\n5:     mapping (address=>uint256)"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "58-63",
    "vulnerableCode": [
      "mapping(address => uint) balances_1;",
      "    function withdraw_balances_1 () public {",
      "       (bool success,) =msg.sender.call.value(balances_1[msg.sender ])(\"\");",
      "       if (success)",
      "          balances_1[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "65-72",
    "vulnerableCode": [
      "bool callcounts_41 = true;",
      "function userbalance_41() public{",
      "        require(callcounts_41);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcounts_41 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "80-86",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_19;",
      "function withdrawBalance_19() public{",
      "        if( ! (msg.sender.send(userBalance_19[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalance_19[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "91-98",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_26;",
      "function withdrawBalance_26() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_26[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_26[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "103-110",
    "vulnerableCode": [
      "bool callcounts_20 = true;",
      "function userbalance_20() public{",
      "        require(callcounts_20);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcounts_20 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "127-134",
    "vulnerableCode": [
      "uint256 counter_42 =0;",
      "function withdraw_42() public{",
      "        require(counter_42<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_42 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "136-142",
    "vulnerableCode": [
      "address payable lastPlayer_2;",
      "      uint jackpot_2;",
      "      function buyTicket_2() public{",
      "        if (!(lastPlayer_2.send(jackpot_2)))",
      "        revert();",
      "      lastPlayer_2 = msg.sender;",
      "      jackpot_2    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "146-152",
    "vulnerableCode": [
      "mapping(address => uint) balances_17;",
      "function withdrawFunds_17 (uint256 _weiToWithdraw) public {",
      "        require(balances_17[msg.sender] >= _weiToWithdraw);",
      "        (bool success,)=msg.sender.call.value(_weiToWithdraw)(\"\");",
      "        require(success);  ",
      "        balances_17[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "154-160",
    "vulnerableCode": [
      "address payable lastPlayer_37;",
      "      uint jackpot_37;",
      "      function buyTicket_37() public{",
      "        if (!(lastPlayer_37.send(jackpot_37)))",
      "        revert();",
      "      lastPlayer_37 = msg.sender;",
      "      jackpot_37    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "163-169",
    "vulnerableCode": [
      "mapping(address => uint) balances_3;",
      "function withdrawFunds_3 (uint256 _weiToWithdraw) public {",
      "        require(balances_3[msg.sender] >= _weiToWithdraw);",
      "    (bool success,)= msg.sender.call.value(_weiToWithdraw)(\"\");",
      "        require(success);  ",
      "        balances_3[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "171-178",
    "vulnerableCode": [
      "address payable lastPlayer_9;",
      "      uint jackpot_9;",
      "      function buyTicket_9() public{",
      "        (bool success,) = lastPlayer_9.call.value(jackpot_9)(\"\");",
      "        if (!success)",
      "            revert();",
      "      lastPlayer_9 = msg.sender;",
      "      jackpot_9    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "181-187",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_25;",
      "function claimReward_25() public {        ",
      "        require(redeemableEther_25[msg.sender] > 0);",
      "        uint transferValue_25 = redeemableEther_25[msg.sender];",
      "        msg.sender.transfer(transferValue_25);   ",
      "        redeemableEther_25[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "193-198",
    "vulnerableCode": [
      "mapping(address => uint) balances_38;",
      "function withdrawFunds_38 (uint256 _weiToWithdraw) public {",
      "        require(balances_38[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_38[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "203-209",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_4;",
      "function claimReward_4() public {        ",
      "        require(redeemableEther_4[msg.sender] > 0);",
      "        uint transferValue_4 = redeemableEther_4[msg.sender];",
      "        msg.sender.transfer(transferValue_4);   ",
      "        redeemableEther_4[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "214-221",
    "vulnerableCode": [
      "uint256 counter_7 =0;",
      "function withdraw_7() public{",
      "        require(counter_7<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_7 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "226-232",
    "vulnerableCode": [
      "address payable lastPlayer_23;",
      "      uint jackpot_23;",
      "      function buyTicket_23() public{",
      "        if (!(lastPlayer_23.send(jackpot_23)))",
      "        revert();",
      "      lastPlayer_23 = msg.sender;",
      "      jackpot_23    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "240-247",
    "vulnerableCode": [
      "uint256 counter_14 =0;",
      "function withdraw_14() public{",
      "        require(counter_14<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_14 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "265-272",
    "vulnerableCode": [
      "address payable lastPlayer_30;",
      "      uint jackpot_30;",
      "      function buyTicket_30() public{",
      "        if (!(lastPlayer_30.send(jackpot_30)))",
      "        revert();",
      "      lastPlayer_30 = msg.sender;",
      "      jackpot_30    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "279-284",
    "vulnerableCode": [
      "mapping(address => uint) balances_8;",
      "    function withdraw_balances_8 () public {",
      "       (bool success,) = msg.sender.call.value(balances_8[msg.sender ])(\"\");",
      "       if (success)",
      "          balances_8[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "292-298",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_39;",
      "function claimReward_39() public {        ",
      "        require(redeemableEther_39[msg.sender] > 0);",
      "        uint transferValue_39 = redeemableEther_39[msg.sender];",
      "        msg.sender.transfer(transferValue_39);   ",
      "        redeemableEther_39[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "320-324",
    "vulnerableCode": [
      "mapping(address => uint) balances_36;",
      "    function withdraw_balances_36 () public {",
      "       if (msg.sender.send(balances_36[msg.sender ]))",
      "          balances_36[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "332-339",
    "vulnerableCode": [
      "uint256 counter_35 =0;",
      "function withdraw_35() public{",
      "        require(counter_35<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_35 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "347-354",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_40;",
      "function withdrawBalance_40() public{",
      "        (bool success,)=msg.sender.call.value(userBalance_40[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_40[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "361-368",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_33;",
      "function withdrawBalance_33() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_33[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_33[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "373-380",
    "vulnerableCode": [
      "bool callcounts_27 = true;",
      "function userbalance_27() public{",
      "        require(callcounts_27);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcounts_27 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "389-394",
    "vulnerableCode": [
      "mapping(address => uint) balances_31;",
      "function withdrawFunds_31 (uint256 _weiToWithdraw) public {",
      "        require(balances_31[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_31[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "401-409",
    "vulnerableCode": [
      "bool callcounts_13 = true;",
      "function userbalance_13() public{",
      "        require(callcounts_13);",
      "        (bool success,)=msg.sender.call.value(1 ether)(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        callcounts_13 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: interface IERC20 {\n4:   function totalSupply() external view retu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "13-13",
    "vulnerableCode": [
      "  uint256 currentTimestampValue = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: contract Owned {\n4:   function isCurrentTimestampVal"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "29-29",
    "vulnerableCode": [
      "uint256 currentTimestampValue1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: contract Owned {\n4:   function isCurrentTimestampVal"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "98-102",
    "vulnerableCode": [
      "  address winnerAddressPlay19;",
      "function playWinner19(uint startTime) public {",
      "    uint currentBlockTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentBlockTime){",
      "        winnerAddressPlay19 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: contract Owned {\n4:   function isCurrentTimestampVal"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "145-147",
    "vulnerableCode": [
      "  uint256 currentBlockTimestamp3 = block.timestamp;",
      "  event stakingstarted(address staker, uint256 tokens, uint256 time);",
      "  uint256 currentBlockTimestamp4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: contract Owned {\n4:   function isCurrentTimestampVal"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "222-226",
    "vulnerableCode": [
      "address winnerAddressPlay27;",
      "function playWinner27(uint startTime) public {",
      "    uint currentBlockTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentBlockTime){",
      "        winnerAddressPlay27 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: contract Owned {\n4:   function isCurrentTimestampVal"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "250-250",
    "vulnerableCode": [
      "uint256 currentTimestampValue5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: contract Owned {\n4:   function isCurrentTimestampVal"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "196-199",
    "vulnerableCode": [
      "  address winner_2;",
      "function play_2(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_2 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   function balances_21() view"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "215-215",
    "vulnerableCode": [
      "  uint256 balancesv_5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   function balances_21() view"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "217-217",
    "vulnerableCode": [
      "  uint256 balancesv_1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   function balances_21() view"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "219-219",
    "vulnerableCode": [
      "  uint256 balancesv_2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   function balances_21() view"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "221-221",
    "vulnerableCode": [
      "  uint256 balancesv_3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   function balances_21() view"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "223-223",
    "vulnerableCode": [
      "  uint256 balancesv_4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   function balances_21() view"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "370-374",
    "vulnerableCode": [
      "address winner_35;",
      "function play_35(uint startTime) public {",
      "    uint _vtime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == _vtime){",
      "        winner_35 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.1;\n2: \n3: \n4: contract owned {\n5:   function balances_21() view"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "196-198",
    "vulnerableCode": [
      "if (txn.destination.call.value(txn.value)(txn.data))",
      "    Execution(transactionId);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity 0.4.15;\n2: \n3: \n4: \n5: \n6: contract MultiSigWallet {\n7: \n8:     \n9: \n10: \n11:   "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "207-207",
    "vulnerableCode": [
      "executeTransaction(transactionId);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity 0.4.15;\n2: \n3: \n4: \n5: \n6: contract MultiSigWallet {\n7: \n8:     \n9: \n10: \n11:   "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "25-34",
    "vulnerableCode": [
      "  mapping(address => uint) public lockTimeUser13;",
      "",
      "function increaseLockTimeUser13(uint _secondsToIncrease) public {",
      "        lockTimeUser13[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdrawUser13() public {",
      "        require(now > lockTimeUser13[msg.sender]);    ",
      "        uint transferValueUser13 = 10;           ",
      "        msg.sender.transfer(transferValueUser13);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.21 < 0.6.0;\n2: \n3: contract DocumentSigner {\n4:   function "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "65-74",
    "vulnerableCode": [
      "mapping(address => uint) public lockTimeUser33;",
      "",
      "function increaseLockTimeUser33(uint _secondsToIncrease) public {",
      "        lockTimeUser33[msg.sender] += _secondsToIncrease;  ",
      "    }",
      "function withdrawUser33() public {",
      "        require(now > lockTimeUser33[msg.sender]);    ",
      "        uint transferValueUser33 = 10;           ",
      "        msg.sender.transfer(transferValueUser33);",
      "    }"
    ],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.21 < 0.6.0;\n2: \n3: contract DocumentSigner {\n4:   function "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "108-108",
    "vulnerableCode": [
      "receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.19;\n2: \n3: contract AKC is DSToken(\"AKC\"), ERC223, Controlled {\n4: \n5:     "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "33-33",
    "vulnerableCode": [
      "  uint256 validationTimestamp3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.10;\n2: \n3: contract TAMCContract {\n4:   address winnerTransfer35"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "51-51",
    "vulnerableCode": [
      "uint256 validationTimestamp5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.10;\n2: \n3: contract TAMCContract {\n4:   address winnerTransfer35"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "53-53",
    "vulnerableCode": [
      "  uint256 validationTimestamp4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.10;\n2: \n3: contract TAMCContract {\n4:   address winnerTransfer35"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "56-60",
    "vulnerableCode": [
      "  address winnerTransfer31;",
      "function playTransfer31(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerTransfer31 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.10;\n2: \n3: contract TAMCContract {\n4:   address winnerTransfer35"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "71-71",
    "vulnerableCode": [
      "uint256 validationTimestamp1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.10;\n2: \n3: contract TAMCContract {\n4:   address winnerTransfer35"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "86-86",
    "vulnerableCode": [
      "uint256 validationTimestamp2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.10;\n2: \n3: contract TAMCContract {\n4:   address winnerTransfer35"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "78-78",
    "vulnerableCode": [
      "userDeals.cancelTime = block.timestamp.add(requestCancelationTime);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract StreamityEscrow is Ownable, ReentrancyGuard {\n2:     using SafeMath for uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "168-168",
    "vulnerableCode": [
      "if (deal.cancelTime > block.timestamp)"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract StreamityEscrow is Ownable, ReentrancyGuard {\n2:     using SafeMath for uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "48-51",
    "vulnerableCode": [
      "            if(msg.sender.call.value(_am)())",
      "            {",
      "                balances[msg.sender]-=_am;",
      "                Log.AddMessage(msg.sender,_am,\"Collect\");"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.19;\n2: \n3: contract ACCURAL_DEPOSIT\n4: {\n5:     mapping (address=>uint256) "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "215-215",
    "vulnerableCode": [
      "destAddress.transfer(destAmount);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity 0.4.18;\n2: \n3: \n4: \n5: \n6: interface ERC20 {\n7:     function totalSupply() publi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "334-334",
    "vulnerableCode": [
      "if (destination.call.value(value)(data)) {"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity 0.4.18;\n2: \n3: \n4: \n5: \n6: interface ERC20 {\n7:     function totalSupply() publi"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "229-229",
    "vulnerableCode": [
      "if (tx.destination.call.value(tx.value)(tx.data))"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity 0.4.10;\n2: \n3: \n4: \n5: \n6: contract MultiSigWallet {\n7: \n8:     uint constant pu"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "46-51",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_25;",
      "function claimReward_25() public {        ",
      "        require(redeemableEther_25[msg.sender] > 0);",
      "        uint transferValue_25 = redeemableEther_25[msg.sender];",
      "        msg.sender.transfer(transferValue_25);   ",
      "        redeemableEther_25[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: mapping(address => uint) balances_"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "65-70",
    "vulnerableCode": [
      "  mapping(address => uint) redeemableEther_11;",
      "function claimReward_11() public {        ",
      "        require(redeemableEther_11[msg.sender] > 0);",
      "        uint transferValue_11 = redeemableEther_11[msg.sender];",
      "        msg.sender.transfer(transferValue_11);   ",
      "        redeemableEther_11[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: mapping(address => uint) balances_"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "90-96",
    "vulnerableCode": [
      "  uint256 counter_42 =0;",
      "function callcheck_42() public{",
      "        require(counter_42<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_42 += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: mapping(address => uint) balances_"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "147-153",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_19;",
      "function withdrawBalance_19() public{",
      "        if( ! (msg.sender.send(userBalance_19[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalance_19[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: mapping(address => uint) balances_"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "165-172",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_26;",
      "function withdrawBalance_26() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_26[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_26[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: mapping(address => uint) balances_"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "178-185",
    "vulnerableCode": [
      "bool callvalues_20 = true;",
      "function updates_20() public{",
      "        require(callvalues_20);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callvalues_20 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: mapping(address => uint) balances_"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "193-199",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_32;",
      "function claimReward_32() public {        ",
      "        require(redeemableEther_32[msg.sender] > 0);",
      "        uint transferValue_32 = redeemableEther_32[msg.sender];",
      "        msg.sender.transfer(transferValue_32);   ",
      "        redeemableEther_32[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: mapping(address => uint) balances_"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "207-212",
    "vulnerableCode": [
      "mapping(address => uint) balances_38;",
      "function withdrawFunds_38 (uint256 _weiToWithdraw) public {",
      "        require(balances_38[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_38[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: mapping(address => uint) balances_"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "221-227",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_4;",
      "function claimReward_4() public {        ",
      "        require(redeemableEther_4[msg.sender] > 0);",
      "        uint transferValue_4 = redeemableEther_4[msg.sender];",
      "        msg.sender.transfer(transferValue_4);   ",
      "        redeemableEther_4[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: mapping(address => uint) balances_"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "248-256",
    "vulnerableCode": [
      "  bool callvalues_13 = true;",
      "function updates_13() public{",
      "        require(callvalues_13);",
      "        (bool success,)=msg.sender.call.value(1 ether)(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        callvalues_13 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: mapping(address => uint) balances_"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "269-276",
    "vulnerableCode": [
      "uint256 counter_14 =0;",
      "function callcheck_14() public{",
      "        require(counter_14<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_14 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: mapping(address => uint) balances_"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "284-291",
    "vulnerableCode": [
      "address payable lastPlayer_30;",
      "      uint jackpot_30;",
      "      function buyTicket_30() public{",
      "        if (!(lastPlayer_30.send(jackpot_30)))",
      "        revert();",
      "      lastPlayer_30 = msg.sender;",
      "      jackpot_30    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: mapping(address => uint) balances_"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "297-302",
    "vulnerableCode": [
      "mapping(address => uint) balances_8;",
      "    function withdraw_balances_8 () public {",
      "       (bool success,) = msg.sender.call.value(balances_8[msg.sender ])(\"\");",
      "       if (success)",
      "          balances_8[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: mapping(address => uint) balances_"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "308-314",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_39;",
      "function claimReward_39() public {        ",
      "        require(redeemableEther_39[msg.sender] > 0);",
      "        uint transferValue_39 = redeemableEther_39[msg.sender];",
      "        msg.sender.transfer(transferValue_39);   ",
      "        redeemableEther_39[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: mapping(address => uint) balances_"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "320-324",
    "vulnerableCode": [
      "mapping(address => uint) balances_36;",
      "    function withdraw_balances_36 () public {",
      "       if (msg.sender.send(balances_36[msg.sender ]))",
      "          balances_36[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: mapping(address => uint) balances_"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "332-339",
    "vulnerableCode": [
      "uint256 counter_35 =0;",
      "function callcheck_35() public{",
      "        require(counter_35<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_35 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.4.22 <0.6.0;\n2: \n3: contract Ownable {\n4: mapping(address => uint) balances_"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "77-84",
    "vulnerableCode": [
      "  bool calledOnce = true;",
      "function withdrawEther() public{",
      "        require(calledOnce);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        calledOnce = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uint b) intern"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "86-91",
    "vulnerableCode": [
      "  mapping(address => uint) thirdUserBalance;",
      "function withdrawThirdUserBalance (uint256 _weiToWithdraw) public {",
      "        require(thirdUserBalance[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        thirdUserBalance[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uint b) intern"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "110-116",
    "vulnerableCode": [
      "  mapping(address => uint) userBalanceOwned;",
      "function withdrawUserBalanceOwned() public{",
      "        if( ! (msg.sender.send(userBalanceOwned[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalanceOwned[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uint b) intern"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "118-124",
    "vulnerableCode": [
      "  mapping(address => uint) redeemableEtherOwned;",
      "function claimRewardOwned() public {        ",
      "        require(redeemableEtherOwned[msg.sender] > 0);",
      "        uint transferValueOwned = redeemableEtherOwned[msg.sender];",
      "        msg.sender.transfer(transferValueOwned);   ",
      "        redeemableEtherOwned[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uint b) intern"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "127-135",
    "vulnerableCode": [
      "  bool calledOnceForOwnership = true;",
      "function withdrawEtherForOwnership() public{",
      "        require(calledOnceForOwnership);",
      "        (bool success,)=msg.sender.call.value(1 ether)(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        calledOnceForOwnership = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uint b) intern"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "141-147",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEtherContract;",
      "function claimRewardContract() public {        ",
      "        require(redeemableEtherContract[msg.sender] > 0);",
      "        uint transferValueContract = redeemableEtherContract[msg.sender];",
      "        msg.sender.transfer(transferValueContract);   ",
      "        redeemableEtherContract[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uint b) intern"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "157-162",
    "vulnerableCode": [
      "mapping(address => uint) myBalance;",
      "function withdrawMyBalance (uint256 _weiToWithdraw) public {",
      "        require(myBalance[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        myBalance[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uint b) intern"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "169-175",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEtherV2;",
      "function claimRewardV2() public {        ",
      "        require(redeemableEtherV2[msg.sender] > 0);",
      "        uint transferValueV2 = redeemableEtherV2[msg.sender];",
      "        msg.sender.transfer(transferValueV2);   ",
      "        redeemableEtherV2[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uint b) intern"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "189-196",
    "vulnerableCode": [
      "  bool calledOnceForBlockchain = true;",
      "function withdrawEtherForBlockchain() public{",
      "        require(calledOnceForBlockchain);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        calledOnceForBlockchain = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uint b) intern"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "238-245",
    "vulnerableCode": [
      "uint256 counterForOwner =0;",
      "function withdrawOwnerCounter() public{",
      "        require(counterForOwner<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counterForOwner += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uint b) intern"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "251-258",
    "vulnerableCode": [
      "address payable lastPlayerV2;",
      "      uint jackpotV2;",
      "      function buyTicketV2() public{",
      "        if (!(lastPlayerV2.send(jackpotV2)))",
      "        revert();",
      "      lastPlayerV2 = msg.sender;",
      "      jackpotV2    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uint b) intern"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "264-271",
    "vulnerableCode": [
      "uint256 counterV2 =0;",
      "function withdrawV2() public{",
      "        require(counterV2<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counterV2 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uint b) intern"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "280-287",
    "vulnerableCode": [
      "address payable lastPlayerAmount;",
      "      uint jackpotAmountForLastPlayer;",
      "      function buyLastPlayerTicket() public{",
      "        if (!(lastPlayerAmount.send(jackpotAmountForLastPlayer)))",
      "        revert();",
      "      lastPlayerAmount = msg.sender;",
      "      jackpotAmountForLastPlayer    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uint b) intern"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "295-300",
    "vulnerableCode": [
      "mapping(address => uint) balancesForApprove;",
      "    function withdrawBalancesForApprove () public {",
      "       (bool success,) = msg.sender.call.value(balancesForApprove[msg.sender ])(\"\");",
      "       if (success)",
      "          balancesForApprove[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uint b) intern"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "310-316",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEtherAccount;",
      "function claimRewardAccount() public {        ",
      "        require(redeemableEtherAccount[msg.sender] > 0);",
      "        uint transferValueAccount = redeemableEtherAccount[msg.sender];",
      "        msg.sender.transfer(transferValueAccount);   ",
      "        redeemableEtherAccount[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uint b) intern"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "322-326",
    "vulnerableCode": [
      "mapping(address => uint) finalBalancesForApprove;",
      "    function withdrawFinalBalancesForApprove () public {",
      "       if (msg.sender.send(finalBalancesForApprove[msg.sender ]))",
      "          finalBalancesForApprove[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uint b) intern"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "361-368",
    "vulnerableCode": [
      "mapping(address => uint) userBalanceAccountV2;",
      "function withdrawUserBalanceAccountV2() public{",
      "        (bool success,)= msg.sender.call.value(userBalanceAccountV2[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalanceAccountV2[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.0;\n2: \n3: \n4: library SafeMath {\n5:     function add(uint a, uint b) intern"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "66-70",
    "vulnerableCode": [
      "  mapping(address => uint) balances_36;",
      "    function withdraw_balances_36 () public {",
      "       if (msg.sender.send(balances_36[msg.sender ]))",
      "          balances_36[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 a, uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "76-83",
    "vulnerableCode": [
      "uint256 counter_42 =0;",
      "function callcheck_42() public{",
      "        require(counter_42<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_42 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 a, uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "94-101",
    "vulnerableCode": [
      "address payable lastPlayer_2;",
      "      uint jackpot_2;",
      "      function buyTicket_2() public{",
      "        if (!(lastPlayer_2.send(jackpot_2)))",
      "        revert();",
      "      lastPlayer_2 = msg.sender;",
      "      jackpot_2    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 a, uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "109-115",
    "vulnerableCode": [
      "mapping(address => uint) balances_17;",
      "function withdrawFunds_17 (uint256 _weiToWithdraw) public {",
      "        require(balances_17[msg.sender] >= _weiToWithdraw);",
      "        (bool success,)=msg.sender.call.value(_weiToWithdraw)(\"\");",
      "        require(success);  ",
      "        balances_17[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 a, uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "152-157",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_11;",
      "function claimReward_11() public {        ",
      "        require(redeemableEther_11[msg.sender] > 0);",
      "        uint transferValue_11 = redeemableEther_11[msg.sender];",
      "        msg.sender.transfer(transferValue_11);   ",
      "        redeemableEther_11[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 a, uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "167-173",
    "vulnerableCode": [
      "bool callcount_41 = true;",
      "function userbalances_41() public{",
      "        require(callcount_41);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcount_41 = false;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 a, uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "177-183",
    "vulnerableCode": [
      "uint256 counter_35 =0;",
      "function callcheck_35() public{",
      "        require(counter_35<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_35 += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 a, uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "195-201",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_33;",
      "function withdrawBalance_33() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_33[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_33[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 a, uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "204-210",
    "vulnerableCode": [
      "bool callcount_27 = true;",
      "function userbalances_27() public{",
      "        require(callcount_27);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcount_27 = false;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 a, uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "213-217",
    "vulnerableCode": [
      "mapping(address => uint) balances_31;",
      "function withdrawFunds_31 (uint256 _weiToWithdraw) public {",
      "        require(balances_31[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_31[msg.sender] -= _weiToWithdraw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 a, uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "256-261",
    "vulnerableCode": [
      "mapping(address => uint) balances_3;",
      "function withdrawFunds_3 (uint256 _weiToWithdraw) public {",
      "        require(balances_3[msg.sender] >= _weiToWithdraw);",
      "    (bool success,)= msg.sender.call.value(_weiToWithdraw)(\"\");",
      "        require(success);  ",
      "        balances_3[msg.sender] -= _weiToWithdraw;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 a, uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "271-278",
    "vulnerableCode": [
      "address payable lastPlayer_9;",
      "      uint jackpot_9;",
      "      function buyTicket_9() public{",
      "        (bool success,) = lastPlayer_9.call.value(jackpot_9)(\"\");",
      "        if (!success)",
      "            revert();",
      "      lastPlayer_9 = msg.sender;",
      "      jackpot_9    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 a, uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "289-295",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_25;",
      "function claimReward_25() public {        ",
      "        require(redeemableEther_25[msg.sender] > 0);",
      "        uint transferValue_25 = redeemableEther_25[msg.sender];",
      "        msg.sender.transfer(transferValue_25);   ",
      "        redeemableEther_25[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 a, uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "300-306",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_19;",
      "function withdrawBalance_19() public{",
      "        if( ! (msg.sender.send(userBalance_19[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalance_19[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 a, uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "311-318",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_26;",
      "function withdrawBalance_26() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_26[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_26[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 a, uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "331-337",
    "vulnerableCode": [
      "bool callcount_20 = true;",
      "function userbalances_20() public{",
      "        require(callcount_20);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcount_20 = false;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 a, uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "344-350",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_32;",
      "function claimReward_32() public {        ",
      "        require(redeemableEther_32[msg.sender] > 0);",
      "        uint transferValue_32 = redeemableEther_32[msg.sender];",
      "        msg.sender.transfer(transferValue_32);   ",
      "        redeemableEther_32[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 a, uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "372-378",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_4;",
      "function claimReward_4() public {        ",
      "        require(redeemableEther_4[msg.sender] > 0);",
      "        uint transferValue_4 = redeemableEther_4[msg.sender];",
      "        msg.sender.transfer(transferValue_4);   ",
      "        redeemableEther_4[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 a, uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "388-394",
    "vulnerableCode": [
      "uint256 counter_7 =0;",
      "function callcheck_7() public{",
      "        require(counter_7<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_7 += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 a, uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "400-406",
    "vulnerableCode": [
      "address payable lastPlayer_23;",
      "      uint jackpot_23;",
      "      function buyTicket_23() public{",
      "        if (!(lastPlayer_23.send(jackpot_23)))",
      "        revert();",
      "      lastPlayer_23 = msg.sender;",
      "      jackpot_23    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 a, uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "414-420",
    "vulnerableCode": [
      "uint256 counter_14 =0;",
      "function callcheck_14() public{",
      "        require(counter_14<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_14 += 1;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 a, uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "446-452",
    "vulnerableCode": [
      "address payable lastPlayer_30;",
      "      uint jackpot_30;",
      "      function buyTicket_30() public{",
      "        if (!(lastPlayer_30.send(jackpot_30)))",
      "        revert();",
      "      lastPlayer_30 = msg.sender;",
      "      jackpot_30    = address(this).balance;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 a, uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "463-467",
    "vulnerableCode": [
      "mapping(address => uint) balances_8;",
      "    function withdraw_balances_8 () public {",
      "       (bool success,) = msg.sender.call.value(balances_8[msg.sender ])(\"\");",
      "       if (success)",
      "          balances_8[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 a, uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "488-494",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_39;",
      "function claimReward_39() public {        ",
      "        require(redeemableEther_39[msg.sender] > 0);",
      "        uint transferValue_39 = redeemableEther_39[msg.sender];",
      "        msg.sender.transfer(transferValue_39);   ",
      "        redeemableEther_39[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11; \n2: \n3: \n4: library SafeMath {\n5:     function add(uint256 a, uint256 "
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "127-128",
    "vulnerableCode": [
      "bool fromIsAffiliate = affiliateList.inListAsOf(_from, block.timestamp);",
      "bool toIsAffiliate = affiliateList.inListAsOf(_to, block.timestamp);"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract SecurityController is ISecurityController, Ownable {\n2:     ISecurityLedger "
  },
  {
    "reason": "Invalid vulnerableLines format: ",
    "vulnerableCode": [],
    "input_snippet": "find all integeroverflow/underflow vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: contract Overflow_add_loop {\n2: \n3:  function add_overflow() returns (uint8 _over"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "91-95",
    "vulnerableCode": [
      "mapping(address => uint) balances_8;",
      "    function withdraw_balances_8 () public {",
      "       (bool success,) = msg.sender.call.value(balances_8[msg.sender ])(\"\");",
      "       if (success)",
      "          balances_8[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: interface IERC20 {\n5:     function transferFrom(address fro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "101-106",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_39;",
      "function claimReward_39() public {        ",
      "        require(redeemableEther_39[msg.sender] > 0);",
      "        uint transferValue_39 = redeemableEther_39[msg.sender];",
      "        msg.sender.transfer(transferValue_39);   ",
      "        redeemableEther_39[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: interface IERC20 {\n5:     function transferFrom(address fro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "114-117",
    "vulnerableCode": [
      "mapping(address => uint) balances_36;",
      "    function withdraw_balances_36 () public {",
      "       if (msg.sender.send(balances_36[msg.sender ]))",
      "          balances_36[msg.sender] = 0;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: interface IERC20 {\n5:     function transferFrom(address fro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "134-141",
    "vulnerableCode": [
      "uint256 counter_35 =0;",
      "function callcheck_35() public{",
      "        require(counter_35<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_35 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: interface IERC20 {\n5:     function transferFrom(address fro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "153-160",
    "vulnerableCode": [
      "  uint256 counter_7 =0;",
      "function callcheck_7() public{",
      "        require(counter_7<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_7 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: interface IERC20 {\n5:     function transferFrom(address fro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "162-169",
    "vulnerableCode": [
      "  address payable lastPlayer_23;",
      "      uint jackpot_23;",
      "      function buyTicket_23() public{",
      "        if (!(lastPlayer_23.send(jackpot_23)))",
      "        revert();",
      "      lastPlayer_23 = msg.sender;",
      "      jackpot_23    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: interface IERC20 {\n5:     function transferFrom(address fro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "172-180",
    "vulnerableCode": [
      "  bool callcount_13 = true;",
      "function userbalances_13() public{",
      "        require(callcount_13);",
      "        (bool success,)=msg.sender.call.value(1 ether)(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        callcount_13 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: interface IERC20 {\n5:     function transferFrom(address fro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "187-194",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_40;",
      "function withdrawBalance_40() public{",
      "        (bool success,)=msg.sender.call.value(userBalance_40[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_40[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: interface IERC20 {\n5:     function transferFrom(address fro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "215-222",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_33;",
      "function withdrawBalance_33() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_33[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_33[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: interface IERC20 {\n5:     function transferFrom(address fro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "229-236",
    "vulnerableCode": [
      "bool callcount_27 = true;",
      "function userbalances_27() public{",
      "        require(callcount_27);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        callcount_27 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity >=0.5.11;\n2: \n3: \n4: interface IERC20 {\n5:     function transferFrom(address fro"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "103-103",
    "vulnerableCode": [
      "uint      public nextUnLockTime = block.timestamp + ONE_YEAR_TIME_LEN;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.21;\n2: \n3: contract ERC20Interface {\n4:     function totalSupply"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "134-139",
    "vulnerableCode": [
      "if(randReuslt < rollUnder){",
      "    uint playerProfit = ((((msg.value * (maxNumber-(safeSub(rollUnder,1)))) / (safeSub(rollUnder,1))+msg.value))*houseEdge/houseEdgeDivisor)-msg.value;",
      "    contractBalance = safeSub(contractBalance, playerProfit);",
      "    uint reward = safeAdd(playerProfit, msg.value);"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: contract MyDice is DSSafeAddSub {\n6: \n7:     \n8: \n9: \n10:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "193-198",
    "vulnerableCode": [
      "if (msg.sender.call.value(withdrawAmount)()) {",
      "    return true;",
      "} else {",
      "    playerPendingWithdrawals[msg.sender] = withdrawAmount;"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.4.2;\n2: \n3: \n4: \n5: contract MyDice is DSSafeAddSub {\n6: \n7:     \n8: \n9: \n10:"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "1-1",
    "vulnerableCode": [
      "pragma solidity ^0.5.6;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "43-47",
    "vulnerableCode": [
      "",
      "contract owned {",
      "function checkTimestamp() view public returns (bool) {",
      "    return block.timestamp >= 1546300800;",
      "  }"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "53-57",
    "vulnerableCode": [
      "address winnerAddress7;",
      "function playWinner7(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress7 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "63-63",
    "vulnerableCode": [
      "uint256 timestampValue1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "68-72",
    "vulnerableCode": [
      "address winnerAddress23;",
      "function playWinner23(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress23 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "82-85",
    "vulnerableCode": [
      "address winnerAddress2;",
      "function playWinner2(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerAddress2 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "95-99",
    "vulnerableCode": [
      "address winnerAddress3;",
      "function playWinner3(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress3 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "111-111",
    "vulnerableCode": [
      "uint256 timestampValue2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "114-114",
    "vulnerableCode": [
      "uint256 timestampValue3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "117-117",
    "vulnerableCode": [
      "uint256 timestampValue4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "126-129",
    "vulnerableCode": [
      "address winnerAddress14;",
      "function playWinner14(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerAddress14 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "137-140",
    "vulnerableCode": [
      "address winnerAddress30;",
      "function playWinner30(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winnerAddress30 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "162-166",
    "vulnerableCode": [
      "address winnerAddress39;",
      "function playWinner39(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress39 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "192-196",
    "vulnerableCode": [
      "address winnerAddress35;",
      "function playWinner35(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress35 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "202-206",
    "vulnerableCode": [
      "    frozenWallets[frozenAddresses[0]] = frozenWallet({",
      "      isFrozen: true,",
      "      rewardedAmount: 30000000 * 10 ** uint256(decimals),",
      "      frozenAmount: 0 * 10 ** uint256(decimals),",
      "      frozenTime: now + 1 * 1 hours "
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "244-248",
    "vulnerableCode": [
      "address winnerAddress27;",
      "function playWinner27(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress27 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "257-261",
    "vulnerableCode": [
      "address winnerAddress31;",
      "function playWinner31(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winnerAddress31 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "277-277",
    "vulnerableCode": [
      "uint256 timestampValue5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.6;\n2: \n3: \n4: library SafeMath {\n5:   function mul(uint256 a, ui"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "71-78",
    "vulnerableCode": [
      "  uint256 counter_42 =0;",
      "function updates_42() public{",
      "        require(counter_42<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_42 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to, uint256 v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "81-88",
    "vulnerableCode": [
      "  address payable lastPlayer_2;",
      "      uint jackpot_2;",
      "      function buyTicket_2() public{",
      "        if (!(lastPlayer_2.send(jackpot_2)))",
      "        revert();",
      "      lastPlayer_2 = msg.sender;",
      "      jackpot_2    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to, uint256 v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "91-97",
    "vulnerableCode": [
      "  mapping(address => uint) balances_17;",
      "function withdrawFunds_17 (uint256 _weiToWithdraw) public {",
      "        require(balances_17[msg.sender] >= _weiToWithdraw);",
      "        (bool success,)=msg.sender.call.value(_weiToWithdraw)(\"\");",
      "        require(success);  ",
      "        balances_17[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to, uint256 v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "103-109",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_25;",
      "function claimReward_25() public {        ",
      "        require(redeemableEther_25[msg.sender] > 0);",
      "        uint transferValue_25 = redeemableEther_25[msg.sender];",
      "        msg.sender.transfer(transferValue_25);   ",
      "        redeemableEther_25[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to, uint256 v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "114-120",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_19;",
      "function withdrawBalance_19() public{",
      "        if( ! (msg.sender.send(userBalance_19[msg.sender]) ) ){",
      "            revert();",
      "        }",
      "        userBalance_19[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to, uint256 v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "125-132",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_26;",
      "function withdrawBalance_26() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_26[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_26[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to, uint256 v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "138-145",
    "vulnerableCode": [
      "bool balances_20 = true;",
      "function withdraw_20() public{",
      "        require(balances_20);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        balances_20 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to, uint256 v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "151-157",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_32;",
      "function claimReward_32() public {        ",
      "        require(redeemableEther_32[msg.sender] > 0);",
      "        uint transferValue_32 = redeemableEther_32[msg.sender];",
      "        msg.sender.transfer(transferValue_32);   ",
      "        redeemableEther_32[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to, uint256 v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "164-169",
    "vulnerableCode": [
      "mapping(address => uint) balances_38;",
      "function withdrawFunds_38 (uint256 _weiToWithdraw) public {",
      "        require(balances_38[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_38[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to, uint256 v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "187-194",
    "vulnerableCode": [
      "uint256 counter_7 =0;",
      "function updates_7() public{",
      "        require(counter_7<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_7 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to, uint256 v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "203-210",
    "vulnerableCode": [
      "address payable lastPlayer_23;",
      "      uint jackpot_23;",
      "      function buyTicket_23() public{",
      "        if (!(lastPlayer_23.send(jackpot_23)))",
      "        revert();",
      "      lastPlayer_23 = msg.sender;",
      "      jackpot_23    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to, uint256 v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "219-226",
    "vulnerableCode": [
      "uint256 counter_14 =0;",
      "function updates_14() public{",
      "        require(counter_14<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_14 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to, uint256 v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "235-242",
    "vulnerableCode": [
      "address payable lastPlayer_30;",
      "      uint jackpot_30;",
      "      function buyTicket_30() public{",
      "        if (!(lastPlayer_30.send(jackpot_30)))",
      "        revert();",
      "      lastPlayer_30 = msg.sender;",
      "      jackpot_30    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to, uint256 v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "251-256",
    "vulnerableCode": [
      "mapping(address => uint) balances_8;",
      "    function withdraw_balances_8 () public {",
      "       (bool success,) = msg.sender.call.value(balances_8[msg.sender ])(\"\");",
      "       if (success)",
      "          balances_8[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to, uint256 v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "262-268",
    "vulnerableCode": [
      "mapping(address => uint) redeemableEther_39;",
      "function claimReward_39() public {        ",
      "        require(redeemableEther_39[msg.sender] > 0);",
      "        uint transferValue_39 = redeemableEther_39[msg.sender];",
      "        msg.sender.transfer(transferValue_39);   ",
      "        redeemableEther_39[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to, uint256 v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "279-283",
    "vulnerableCode": [
      "mapping(address => uint) balances_36;",
      "    function withdraw_balances_36 () public {",
      "       if (msg.sender.send(balances_36[msg.sender ]))",
      "          balances_36[msg.sender] = 0;",
      "      }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to, uint256 v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "288-295",
    "vulnerableCode": [
      "uint256 counter_35 =0;",
      "function updates_35() public{",
      "        require(counter_35<=5);",
      "    if( ! (msg.sender.send(10 ether) ) ){",
      "            revert();",
      "        }",
      "        counter_35 += 1;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to, uint256 v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "299-310",
    "vulnerableCode": [
      "pragma solidity ^0.5.2;",
      "",
      "",
      "contract ERC20Detailed is IERC20 {",
      "  address payable lastPlayer_37;",
      "      uint jackpot_37;",
      "      function buyTicket_37() public{",
      "        if (!(lastPlayer_37.send(jackpot_37)))",
      "        revert();",
      "      lastPlayer_37 = msg.sender;",
      "      jackpot_37    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to, uint256 v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "312-318",
    "vulnerableCode": [
      "  mapping(address => uint) balances_3;",
      "function withdrawFunds_3 (uint256 _weiToWithdraw) public {",
      "        require(balances_3[msg.sender] >= _weiToWithdraw);",
      "    (bool success,)= msg.sender.call.value(_weiToWithdraw)(\"\");",
      "        require(success);  ",
      "        balances_3[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to, uint256 v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "320-328",
    "vulnerableCode": [
      "  address payable lastPlayer_9;",
      "      uint jackpot_9;",
      "      function buyTicket_9() public{",
      "        (bool success,) = lastPlayer_9.call.value(jackpot_9)(\"\");",
      "        if (!success)",
      "            revert();",
      "      lastPlayer_9 = msg.sender;",
      "      jackpot_9    = address(this).balance;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to, uint256 v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "336-343",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_40;",
      "function withdrawBalance_40() public{",
      "        (bool success,)=msg.sender.call.value(userBalance_40[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_40[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to, uint256 v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "348-355",
    "vulnerableCode": [
      "mapping(address => uint) userBalance_33;",
      "function withdrawBalance_33() public{",
      "        (bool success,)= msg.sender.call.value(userBalance_33[msg.sender])(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        userBalance_33[msg.sender] = 0;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to, uint256 v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "360-367",
    "vulnerableCode": [
      "bool balances_27 = true;",
      "function withdraw_27() public{",
      "        require(balances_27);",
      "        if( ! (msg.sender.send(1 ether) ) ){",
      "            revert();",
      "        }",
      "        balances_27 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to, uint256 v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "372-377",
    "vulnerableCode": [
      "mapping(address => uint) balances_31;",
      "function withdrawFunds_31 (uint256 _weiToWithdraw) public {",
      "        require(balances_31[msg.sender] >= _weiToWithdraw);",
      "        require(msg.sender.send(_weiToWithdraw));  ",
      "        balances_31[msg.sender] -= _weiToWithdraw;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to, uint256 v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "390-398",
    "vulnerableCode": [
      "bool balances_13 = true;",
      "function withdraw_13() public{",
      "        require(balances_13);",
      "        (bool success,)=msg.sender.call.value(1 ether)(\"\");",
      "        if( ! success ){",
      "            revert();",
      "        }",
      "        balances_13 = false;",
      "    }"
    ],
    "input_snippet": "find all Reentrancy vulnerabilities and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.2;\n2: \n3: interface IERC20 {\n4:     function transfer(address to, uint256 v"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "67-67",
    "vulnerableCode": [
      "  uint256 currentBlockTime2 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11; \n2: \n3: \n4: \n5: library SafeMath {\t\n6:     function add(uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "69-69",
    "vulnerableCode": [
      "  uint256 currentBlockTime3 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11; \n2: \n3: \n4: \n5: library SafeMath {\t\n6:     function add(uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "99-103",
    "vulnerableCode": [
      "  address winner_time11;",
      "function playTime11(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winner_time11 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11; \n2: \n3: \n4: \n5: library SafeMath {\t\n6:     function add(uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "106-106",
    "vulnerableCode": [
      "  uint256 currentBlockTime4 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11; \n2: \n3: \n4: \n5: library SafeMath {\t\n6:     function add(uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "112-116",
    "vulnerableCode": [
      "address winner_time7;",
      "function playTime7(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winner_time7 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11; \n2: \n3: \n4: \n5: library SafeMath {\t\n6:     function add(uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "122-122",
    "vulnerableCode": [
      "uint256 currentBlockTime1 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11; \n2: \n3: \n4: \n5: library SafeMath {\t\n6:     function add(uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "127-131",
    "vulnerableCode": [
      "address winner_time23;",
      "function playTime23(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winner_time23 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11; \n2: \n3: \n4: \n5: library SafeMath {\t\n6:     function add(uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "138-141",
    "vulnerableCode": [
      "address winner_time14;",
      "function playTime14(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_time14 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11; \n2: \n3: \n4: \n5: library SafeMath {\t\n6:     function add(uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "152-155",
    "vulnerableCode": [
      "  address winner_time2;",
      "function playTime2(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_time2 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11; \n2: \n3: \n4: \n5: library SafeMath {\t\n6:     function add(uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "166-170",
    "vulnerableCode": [
      "  address winner_time3;",
      "function playTime3(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winner_time3 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11; \n2: \n3: \n4: \n5: library SafeMath {\t\n6:     function add(uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "186-189",
    "vulnerableCode": [
      "address winner_time30;",
      "function playTime30(uint startTime) public {",
      "    if (startTime + (5 * 1 days) == block.timestamp){",
      "        winner_time30 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11; \n2: \n3: \n4: \n5: library SafeMath {\t\n6:     function add(uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "209-213",
    "vulnerableCode": [
      "address winner_time39;",
      "function playTime39(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winner_time39 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11; \n2: \n3: \n4: \n5: library SafeMath {\t\n6:     function add(uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "238-242",
    "vulnerableCode": [
      "address winner_time35;",
      "function playTime35(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winner_time35 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11; \n2: \n3: \n4: \n5: library SafeMath {\t\n6:     function add(uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "282-286",
    "vulnerableCode": [
      "address winner_time27;",
      "function playTime27(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winner_time27 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11; \n2: \n3: \n4: \n5: library SafeMath {\t\n6:     function add(uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "292-296",
    "vulnerableCode": [
      "address winner_time31;",
      "function playTime31(uint startTime) public {",
      "    uint currentTime = block.timestamp;",
      "    if (startTime + (5 * 1 days) == currentTime){",
      "        winner_time31 = msg.sender;}}"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11; \n2: \n3: \n4: \n5: library SafeMath {\t\n6:     function add(uint"
  },
  {
    "reason": "No matching function found for vulnerable line",
    "vulnerableLines": "313-313",
    "vulnerableCode": [
      "uint256 currentBlockTime5 = block.timestamp;"
    ],
    "input_snippet": "find all tiemstamp dependency vulnerabilities  and detect vulnerable line numbers from the contract as well as vulnerableCode, vulnerabilityReason, potentialSecurityRisk, and fixedCode based on the instruction.\n\n1: pragma solidity ^0.5.11; \n2: \n3: \n4: \n5: library SafeMath {\t\n6:     function add(uint"
  }
]