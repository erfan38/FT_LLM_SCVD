function buyFromPrivateSaleFor( IERC721 nftContract, uint256 tokenId, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s ) public payable nonReentrant { if (deadline < block.timestamp) { revert NFTMarketPrivateSale_Sale_Expired(); } else if (deadline > block.timestamp + 2 days) { revert NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max(); } if (amount > msg.value) { unchecked { uint256 delta = amount - msg.value; feth.marketWithdrawFrom(msg.sender, delta); } } else if (amount < msg.value) { revert NFTMarketPrivateSale_Too_Much_Value_Provided(); } address payable seller = payable(nftContract.ownerOf(tokenId)); { bytes32 digest = keccak256( abi.encodePacked( "\x19\x01", DOMAIN_SEPARATOR, keccak256(abi.encode(BUY_FROM_PRIVATE_SALE_TYPEHASH, nftContract, tokenId, msg.sender, amount, deadline)) ) ); if (ecrecover(digest, v, r, s) != seller) { revert NFTMarketPrivateSale_Signature_Verification_Failed(); } } nftContract.transferFrom(seller, msg.sender, tokenId); (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds( address(nftContract), tokenId, seller, amount ); emit PrivateSaleFinalized( address(nftContract), tokenId, seller, msg.sender, f8nFee, creatorFee, ownerRev, deadline ); }
