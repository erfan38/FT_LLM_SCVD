function mintLegendaryGobbler(uint256[] calldata gobblerIds) external returns (uint256 gobblerId) { gobblerId = FIRST_LEGENDARY_GOBBLER_ID + legendaryGobblerAuctionData.numSold; if (gobblerId > MAX_SUPPLY) revert NoRemainingLegendaryGobblers(); uint256 cost = legendaryGobblerPrice(); if (gobblerIds.length < cost) revert InsufficientGobblerAmount(cost); unchecked { uint256 burnedMultipleTotal; uint256 id; for (uint256 i = 0; i < cost; ++i) { id = gobblerIds[i]; if (id >= FIRST_LEGENDARY_GOBBLER_ID) revert CannotBurnLegendary(id); require(getGobblerData[id].owner == msg.sender, "WRONG_FROM"); burnedMultipleTotal += getGobblerData[id].emissionMultiple; emit Transfer(msg.sender, getGobblerData[id].owner = address(0), id); } getGobblerData[gobblerId].emissionMultiple = uint32(burnedMultipleTotal * 2); getUserData[msg.sender].lastBalance = uint128(gooBalance(msg.sender)); getUserData[msg.sender].lastTimestamp = uint64(block.timestamp); getUserData[msg.sender].emissionMultiple += uint32(burnedMultipleTotal); getUserData[msg.sender].gobblersOwned = uint32(getUserData[msg.sender].gobblersOwned - cost + 1); legendaryGobblerAuctionData.startPrice = uint120( cost <= LEGENDARY_GOBBLER_INITIAL_START_PRICE / 2 ? LEGENDARY_GOBBLER_INITIAL_START_PRICE : cost * 2 ); legendaryGobblerAuctionData.numSold += 1; emit LegendaryGobblerMinted(msg.sender, gobblerId, gobblerIds[:cost]); _mint(msg.sender, gobblerId); } }
