function createPledge( address receiver, address rewardToken, uint256 targetVotes, uint256 rewardPerVote, uint256 endTimestamp, uint256 maxTotalRewardAmount, uint256 maxFeeAmount ) external whenNotPaused nonReentrant returns(uint256){ address creator = msg.sender; if(receiver == address(0) || rewardToken == address(0)) revert Errors.ZeroAddress(); if(targetVotes < minTargetVotes) revert Errors.TargetVoteUnderMin(); if(minAmountRewardToken[rewardToken] == 0) revert Errors.TokenNotWhitelisted(); if(rewardPerVote < minAmountRewardToken[rewardToken]) revert Errors.RewardPerVoteTooLow(); if(endTimestamp == 0) revert Errors.NullEndTimestamp(); if(endTimestamp != _getRoundedTimestamp(endTimestamp)) revert Errors.InvalidEndTimestamp(); CreatePledgeVars memory vars; vars.duration = endTimestamp - block.timestamp; if(vars.duration < minDelegationTime) revert Errors.DurationTooShort(); vars.votesDifference = targetVotes - votingEscrow.balanceOf(receiver); vars.totalRewardAmount = (rewardPerVote * vars.votesDifference * vars.duration) / UNIT; vars.feeAmount = (vars.totalRewardAmount * protocalFeeRatio) / MAX_PCT ; if(vars.totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount(); if(vars.feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount(); IERC20(rewardToken).safeTransferFrom(creator, address(this), vars.totalRewardAmount); IERC20(rewardToken).safeTransferFrom(creator, chestAddress, vars.feeAmount); vars.newPledgeID = pledgesIndex(); pledgeAvailableRewardAmounts[vars.newPledgeID] += vars.totalRewardAmount; pledges.push(Pledge( targetVotes, vars.votesDifference, rewardPerVote, receiver, rewardToken, safe64(endTimestamp), false )); pledgeOwner[vars.newPledgeID] = creator; ownerPledges[creator].push(vars.newPledgeID); emit NewPledge(creator, receiver, rewardToken, targetVotes, rewardPerVote, endTimestamp); return vars.newPledgeID; }
