function RedeemTo(uint256[] memory lock_index, address to) public nonReentrant { uint256 total_to_redeem = 0; uint256 total_to_burn = 0; for(uint256 i; i < lock_index.length; i++){ uint256 index = lock_index[i]; UserLockInfo memory lock_info = _userLocks[msg.sender][index]; require(block.timestamp >= lock_info.time, "dMute::Redeem: INSUFFICIENT_LOCK_TIME"); require(lock_info.amount >= 0 , "dMute::Redeem: INSUFFICIENT_AMOUNT"); require(lock_info.tokens_minted >= 0 , "dMute::Redeem: INSUFFICIENT_MINT_AMOUNT"); total_to_redeem = total_to_redeem.add(lock_info.amount); total_to_burn = total_to_burn.add(lock_info.tokens_minted); _userLocks[msg.sender][index] = UserLockInfo(0,0,0); } require(total_to_redeem > 0, "dMute::Lock: INSUFFICIENT_REDEEM_AMOUNT"); require(total_to_burn > 0, "dMute::Lock: INSUFFICIENT_BURN_AMOUNT"); for(uint256 i = _userLocks[msg.sender].length; i > 0; i--){ UserLockInfo memory lock_info = _userLocks[msg.sender][i - 1]; if(lock_info.time == 0){ _userLocks[msg.sender][i - 1] = _userLocks[msg.sender][_userLocks[msg.sender].length - 1]; _userLocks[msg.sender].pop(); } } IERC20(MuteToken).transfer(to, total_to_redeem); _burn(msg.sender, total_to_burn); emit RedeemEvent(msg.sender, total_to_redeem, total_to_burn); }
