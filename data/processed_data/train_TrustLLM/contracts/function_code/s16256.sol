function create( address _baseToken, address _nft, uint128 _virtualBaseTokenReserves, uint128 _virtualNftReserves, uint56 _changeFee, uint16 _feeRate, bytes32 _merkleRoot, bool _useStolenNftOracle, bool _payRoyalties, bytes32 _salt, uint256[] memory tokenIds, uint256 baseTokenAmount ) public payable returns (PrivatePool privatePool) { if ((_baseToken == address(0) && msg.value != baseTokenAmount) || (_baseToken != address(0) && msg.value > 0)) { revert PrivatePool.InvalidEthAmount(); } privatePool = PrivatePool(payable(privatePoolImplementation.cloneDeterministic(_salt))); _safeMint(msg.sender, uint256(uint160(address(privatePool)))); privatePool.initialize( _baseToken, _nft, _virtualBaseTokenReserves, _virtualNftReserves, _changeFee, _feeRate, _merkleRoot, _useStolenNftOracle, _payRoyalties ); if (_baseToken == address(0)) { address(privatePool).safeTransferETH(baseTokenAmount); } else { ERC20(_baseToken).transferFrom(msg.sender, address(privatePool), baseTokenAmount); } for (uint256 i = 0; i < tokenIds.length; i++) { ERC721(_nft).safeTransferFrom(msg.sender, address(privatePool), tokenIds[i]); } emit Create(address(privatePool), tokenIds, baseTokenAmount); }
