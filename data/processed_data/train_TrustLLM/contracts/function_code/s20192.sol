function cancel(NounsDAOStorageV3.StorageV3 storage ds, uint256 proposalId) external { NounsDAOStorageV3.ProposalState proposalState = stateInternal(ds, proposalId); if ( proposalState == NounsDAOStorageV3.ProposalState.Canceled || proposalState == NounsDAOStorageV3.ProposalState.Defeated || proposalState == NounsDAOStorageV3.ProposalState.Expired || proposalState == NounsDAOStorageV3.ProposalState.Executed || proposalState == NounsDAOStorageV3.ProposalState.Vetoed ) { revert CantCancelProposalAtFinalState(); } NounsDAOStorageV3.Proposal storage proposal = ds._proposals[proposalId]; address proposer = proposal.proposer; NounsTokenLike nouns = ds.nouns; uint256 votes = nouns.getPriorVotes(proposer, block.number - 1); bool msgSenderIsProposer = proposer == msg.sender; address[] memory signers = proposal.signers; for (uint256 i = 0; i < signers.length; ++i) { msgSenderIsProposer = msgSenderIsProposer || msg.sender == signers[i]; votes += nouns.getPriorVotes(signers[i], block.number - 1); } require( msgSenderIsProposer || votes <= proposal.proposalThreshold, 'NounsDAO::cancel: proposer above threshold' ); proposal.canceled = true; INounsDAOExecutor timelock = getProposalTimelock(ds, proposal); for (uint256 i = 0; i < proposal.targets.length; i++) { timelock.cancelTransaction( proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta ); } emit ProposalCanceled(proposalId); }
