function moveStakedLiquidity( uint256 tokenId_, uint256[] memory fromBuckets_, uint256[] memory toBuckets_, uint256 expiry_ ) external nonReentrant override { StakeInfo storage stakeInfo = stakes[tokenId_]; if (msg.sender != stakeInfo.owner) revert NotOwnerOfDeposit(); uint256 fromBucketLength = fromBuckets_.length; if (fromBucketLength != toBuckets_.length) revert MoveStakedLiquidityInvalid(); address ajnaPool = stakeInfo.ajnaPool; uint256 curBurnEpoch = IPool(ajnaPool).currentBurnEpoch(); _claimRewards( stakeInfo, tokenId_, curBurnEpoch, false, ajnaPool ); uint256 fromIndex; uint256 toIndex; for (uint256 i = 0; i < fromBucketLength; ) { fromIndex = fromBuckets_[i]; toIndex = toBuckets_[i]; IPositionManagerOwnerActions.MoveLiquidityParams memory moveLiquidityParams = IPositionManagerOwnerActions.MoveLiquidityParams( tokenId_, ajnaPool, fromIndex, toIndex, expiry_ ); positionManager.moveLiquidity(moveLiquidityParams); BucketState storage toBucket = stakeInfo.snapshot[toIndex]; toBucket.lpsAtStakeTime = uint128(positionManager.getLP(tokenId_, toIndex)); toBucket.rateAtStakeTime = uint128(IPool(ajnaPool).bucketExchangeRate(toIndex)); delete stakeInfo.snapshot[fromIndex]; unchecked { ++i; } } emit MoveStakedLiquidity(tokenId_, fromBuckets_, toBuckets_); uint256 updateReward = _updateBucketExchangeRates( ajnaPool, toBuckets_ ); _transferAjnaRewards(updateReward); }
