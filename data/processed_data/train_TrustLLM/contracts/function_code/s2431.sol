function _processExpiredLocks( address _account, bool _relock, address _rewardAddress, uint256 _checkDelay ) internal updateReward(_account) { LockedBalance[] storage locks = userLocks[_account]; Balances storage userBalance = balances[_account]; uint112 locked; uint256 length = locks.length; uint256 reward = 0; uint256 expiryTime = _checkDelay == 0 && _relock ? block.timestamp.add(rewardsDuration) : block.timestamp.sub(_checkDelay); require(length > 0, "no locks"); if (isShutdown || locks[length - 1].unlockTime <= expiryTime) { locked = userBalance.locked; userBalance.nextUnlockIndex = length.to32(); if (_checkDelay > 0) { uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration); uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(rewardsDuration); uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator); reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator); } } else { uint32 nextUnlockIndex = userBalance.nextUnlockIndex; for (uint256 i = nextUnlockIndex; i < length; i++) { if (locks[i].unlockTime > expiryTime) break; locked = locked.add(locks[i].amount); if (_checkDelay > 0) { uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration); uint256 epochsover = currentEpoch.sub(uint256(locks[i].unlockTime)).div(rewardsDuration); uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator); reward = reward.add(uint256(locks[i].amount).mul(rRate).div(denominator)); } nextUnlockIndex++; } userBalance.nextUnlockIndex = nextUnlockIndex; } require(locked > 0, "no exp locks"); userBalance.locked = userBalance.locked.sub(locked); lockedSupply = lockedSupply.sub(locked); _checkpointDelegate(delegates(_account), 0, 0); emit Withdrawn(_account, locked, _relock); if (reward > 0) { locked = locked.sub(reward.to112()); stakingToken.safeTransfer(_rewardAddress, reward); emit KickReward(_rewardAddress, _account, reward); } if (_relock) { _lock(_account, locked); } else { stakingToken.safeTransfer(_account, locked); } }
