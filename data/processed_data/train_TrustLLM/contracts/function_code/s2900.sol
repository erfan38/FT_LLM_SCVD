function initialize( address _stakingToken, address _yieldyToken, address _tokeToken, address _tokePool, address _tokeManager, address _tokeReward, address _liquidityReserve, address _feeAddress, address _curvePool, uint256 _epochDuration, uint256 _firstEpochEndTime ) external initializer { OwnableUpgradeable.__Ownable_init(); require( _stakingToken != address(0) && _yieldyToken != address(0) && _tokeToken != address(0) && _tokePool != address(0) && _tokeManager != address(0) && _tokeReward != address(0) && _liquidityReserve != address(0), "Invalid address" ); STAKING_TOKEN = _stakingToken; YIELDY_TOKEN = _yieldyToken; TOKE_TOKEN = _tokeToken; TOKE_POOL = _tokePool; TOKE_MANAGER = _tokeManager; TOKE_REWARD = _tokeReward; LIQUIDITY_RESERVE = _liquidityReserve; FEE_ADDRESS = _feeAddress; CURVE_POOL = _curvePool; COW_SETTLEMENT = 0x9008D19f58AAbD9eD0D60971565AA8510560ab41; COW_RELAYER = 0xC92E8bdf79f0507f65a392b0ab4667716BFE0110; timeLeftToRequestWithdrawal = 12 hours; if (CURVE_POOL != address(0)) { IERC20(TOKE_POOL).approve(CURVE_POOL, type(uint256).max); setToAndFromCurve(); } IERC20(STAKING_TOKEN).approve(TOKE_POOL, type(uint256).max); IERC20Upgradeable(YIELDY_TOKEN).approve( LIQUIDITY_RESERVE, type(uint256).max ); IERC20Upgradeable(YIELDY_TOKEN).approve( LIQUIDITY_RESERVE, type(uint256).max ); IERC20Upgradeable(TOKE_TOKEN).approve(COW_RELAYER, type(uint256).max); epoch = Epoch({ duration: _epochDuration, number: 1, timestamp: block.timestamp, endTime: _firstEpochEndTime, distribute: 0 }); }
