function propose( address[] memory _targets, uint256[] memory _values, bytes[] memory _calldatas, string memory _description ) external returns (bytes32) { uint256 currentProposalThreshold = proposalThreshold(); unchecked { if (getVotes(msg.sender, block.timestamp - 1) < proposalThreshold()) revert BELOW_PROPOSAL_THRESHOLD(); } uint256 numTargets = _targets.length; if (numTargets == 0) revert PROPOSAL_TARGET_MISSING(); if (numTargets != _values.length) revert PROPOSAL_LENGTH_MISMATCH(); if (numTargets != _calldatas.length) revert PROPOSAL_LENGTH_MISMATCH(); bytes32 descriptionHash = keccak256(bytes(_description)); bytes32 proposalId = hashProposal(_targets, _values, _calldatas, descriptionHash); Proposal storage proposal = proposals[proposalId]; if (proposal.voteStart != 0) revert PROPOSAL_EXISTS(proposalId); uint256 snapshot; uint256 deadline; unchecked { snapshot = block.timestamp + settings.votingDelay; deadline = snapshot + settings.votingPeriod; } proposal.voteStart = uint32(snapshot); proposal.voteEnd = uint32(deadline); proposal.proposalThreshold = uint32(currentProposalThreshold); proposal.quorumVotes = uint32(quorum()); proposal.proposer = msg.sender; proposal.timeCreated = uint32(block.timestamp); emit ProposalCreated(proposalId, _targets, _values, _calldatas, _description, descriptionHash, proposal); return proposalId; }
