function execTransaction( Transaction memory _tx, uint256 batchId, FeeRefund memory refundInfo, bytes memory signatures ) public payable virtual override returns (bool success) { uint256 startGas = gasleft() + 21000 + msg.data.length * 8; bytes32 txHash; { bytes memory txHashData = encodeTransactionData( _tx, refundInfo, nonces[batchId] ); nonces[batchId]++; txHash = keccak256(txHashData); checkSignatures(txHash, txHashData, signatures); } require(gasleft() >= max((_tx.targetTxGas * 64) / 63,_tx.targetTxGas + 2500) + 500, "BSA010"); { success = execute(_tx.to, _tx.value, _tx.data, _tx.operation, refundInfo.gasPrice == 0 ? (gasleft() - 2500) : _tx.targetTxGas); require(success || _tx.targetTxGas != 0 || refundInfo.gasPrice != 0, "BSA013"); uint256 payment = 0; if (refundInfo.gasPrice > 0) { payment = handlePayment(startGas - gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver); emit WalletHandlePayment(txHash, payment); } } }
