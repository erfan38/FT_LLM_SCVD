function liquidateClean( uint128 _sharesToLiquidate, uint256 _deadline, address _borrower ) external whenNotPaused nonReentrant approvedLender(msg.sender) returns (uint256 _collateralForLiquidator) { if (block.timestamp > _deadline) revert PastDeadline(block.timestamp, _deadline); _addInterest(); uint256 _exchangeRate = _updateExchangeRate(); if (_isSolvent(_borrower, _exchangeRate)) { revert BorrowerSolvent(); } VaultAccount memory _totalBorrow = totalBorrow; uint256 _userCollateralBalance = userCollateralBalance[_borrower]; uint128 _borrowerShares = userBorrowShares[_borrower].toUint128(); int256 _leftoverCollateral; { uint256 _liquidationAmountInCollateralUnits = ((_totalBorrow.toAmount(_sharesToLiquidate, false) * _exchangeRate) / EXCHANGE_PRECISION); uint256 _optimisticCollateralForLiquidator = (_liquidationAmountInCollateralUnits * (LIQ_PRECISION + cleanLiquidationFee)) / LIQ_PRECISION; _leftoverCollateral = (_userCollateralBalance.toInt256() - _optimisticCollateralForLiquidator.toInt256()); _collateralForLiquidator = _leftoverCollateral <= 0 ? _userCollateralBalance : (_liquidationAmountInCollateralUnits * (LIQ_PRECISION + dirtyLiquidationFee)) / LIQ_PRECISION; } uint128 _amountLiquidatorToRepay = (_totalBorrow.toAmount(_sharesToLiquidate, true)).toUint128(); uint128 _sharesToAdjust; uint128 _amountToAdjust; { if (_leftoverCollateral <= 0) { uint128 _leftoverBorrowShares = _borrowerShares - _sharesToLiquidate; if (_leftoverBorrowShares > 0) { _sharesToAdjust = _leftoverBorrowShares; _amountToAdjust = (_totalBorrow.toAmount(_sharesToAdjust, false)).toUint128(); totalAsset.amount -= _amountToAdjust; _totalBorrow.amount -= _amountToAdjust; _totalBorrow.shares -= _sharesToAdjust; } } } _repayAsset(_totalBorrow, _amountLiquidatorToRepay, _sharesToLiquidate, msg.sender, _borrower); _removeCollateral(_collateralForLiquidator, msg.sender, _borrower); emit Liquidate( _borrower, _collateralForLiquidator, _sharesToLiquidate, _amountLiquidatorToRepay, _sharesToAdjust, _amountToAdjust ); }
