[
    {
        "Vulnerability Type":"arithmetic",
        "File Name":"token.sol",
        "Source Code":"\/*\n * @source: https:\/\/github.com\/sigp\/solidity-security-blog\n * @author: Steve Marx\n * @vulnerable_at_lines: 20,22\n *\/\n\n pragma solidity ^0.4.18;\n\n contract Token {\n\n   mapping(address => uint) balances;\n   uint public totalSupply;\n\n   function Token(uint _initialSupply) {\n     balances[msg.sender] = totalSupply = _initialSupply;\n   }\n\n   function transfer(address _to, uint _value) public returns (bool) {\n     \/\/ <yes> <report> ARITHMETIC\n     require(balances[msg.sender] - _value >= 0);\n     \/\/ <yes> <report> ARITHMETIC\n     balances[msg.sender] -= _value;\n     balances[_to] += _value;\n     return true;\n   }\n\n   function balanceOf(address _owner) public constant returns (uint balance) {\n     return balances[_owner];\n   }\n }",
        "input":"pragma solidity ^0.4.18;\n\n contract Token {\n\n   mapping(address => uint) balances;\n   uint public totalSupply;\n\n   function Token(uint _initialSupply) {\n     balances[msg.sender] = totalSupply = _initialSupply;\n   }\n\n   function transfer(address _to, uint _value) public returns (bool) {\n     \n     require(balances[msg.sender] - _value >= 0);\n     \n     balances[msg.sender] -= _value;\n     balances[_to] += _value;\n     return true;\n   }\n\n   function balanceOf(address _owner) public constant returns (uint balance) {\n     return balances[_owner];\n   }\n }"
    },
    {
        "Vulnerability Type":"arithmetic",
        "File Name":"overflow_single_tx.sol",
        "Source Code":"\/*\n * @source: https:\/\/github.com\/ConsenSys\/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 18,24,30,36,42,48\n *\/\n\n\/\/Single transaction overflow\n\/\/Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowSingleTransaction {\n    uint public count = 1;\n\n    \/\/ ADD overflow with result stored in state variable.\n    function overflowaddtostate(uint256 input) public {\n        \/\/ <yes> <report> ARITHMETIC\n        count += input;\n    }\n\n    \/\/ MUL overflow with result stored in state variable.\n    function overflowmultostate(uint256 input) public {\n        \/\/ <yes> <report> ARITHMETIC\n        count *= input;\n    }\n\n    \/\/ Underflow with result stored in state variable.\n    function underflowtostate(uint256 input) public {\n        \/\/ <yes> <report> ARITHMETIC\n        count -= input;\n    }\n\n    \/\/ ADD Overflow, no effect on state.\n    function overflowlocalonly(uint256 input) public {\n        \/\/ <yes> <report> ARITHMETIC\n        uint res = count + input;\n    }\n\n    \/\/ MUL Overflow, no effect on state.\n    function overflowmulocalonly(uint256 input) public {\n        \/\/ <yes> <report> ARITHMETIC\n        uint res = count * input;\n    }\n\n    \/\/ Underflow, no effect on state.\n    function underflowlocalonly(uint256 input) public {\n        \/\/ <yes> <report> ARITHMETIC\n       \tuint res = count - input;\n    }\n\n}",
        "input":"pragma solidity ^0.4.23;\n\ncontract IntegerOverflowSingleTransaction {\n    uint public count = 1;\n\n    \n    function overflowaddtostate(uint256 input) public {\n        \n        count += input;\n    }\n\n    \n    function overflowmultostate(uint256 input) public {\n        \n        count *= input;\n    }\n\n    \n    function underflowtostate(uint256 input) public {\n        \n        count -= input;\n    }\n\n    \n    function overflowlocalonly(uint256 input) public {\n        \n        uint res = count + input;\n    }\n\n    \n    function overflowmulocalonly(uint256 input) public {\n        \n        uint res = count * input;\n    }\n\n    \n    function underflowlocalonly(uint256 input) public {\n        \n       \tuint res = count - input;\n    }\n\n}"
    },
    {
        "Vulnerability Type":"arithmetic",
        "File Name":"integer_overflow_minimal.sol",
        "Source Code":"\/*\n * @source: https:\/\/github.com\/SmartContractSecurity\/SWC-registry\/blob\/master\/test_cases\/integer_overflow_and_underflow\/integer_overflow_minimal.sol\n * @author: -\n * @vulnerable_at_lines: 17\n *\/\n\n\/\/Single transaction overflow\n\/\/Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.19;\n\ncontract IntegerOverflowMinimal {\n    uint public count = 1;\n\n    function run(uint256 input) public {\n        \/\/ <yes> <report> ARITHMETIC\n        count -= input;\n    }\n}",
        "input":"pragma solidity ^0.4.19;\n\ncontract IntegerOverflowMinimal {\n    uint public count = 1;\n\n    function run(uint256 input) public {\n        \n        count -= input;\n    }\n}"
    },
    {
        "Vulnerability Type":"arithmetic",
        "File Name":"integer_overflow_add.sol",
        "Source Code":"\/*\n * @source: https:\/\/github.com\/ConsenSys\/evm-analyzer-benchmark-suite\/blob\/master\/benchmarks\/integer_overflow_add.sol\n * @author: -\n * @vulnerable_at_lines: 17\n *\/\n\n\/\/Single transaction overflow\n\/\/Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.19;\n\ncontract IntegerOverflowAdd {\n    uint public count = 1;\n\n    function run(uint256 input) public {\n        \/\/ <yes> <report> ARITHMETIC\n        count += input;\n    }\n}",
        "input":"pragma solidity ^0.4.19;\n\ncontract IntegerOverflowAdd {\n    uint public count = 1;\n\n    function run(uint256 input) public {\n        \n        count += input;\n    }\n}"
    },
    {
        "Vulnerability Type":"arithmetic",
        "File Name":"insecure_transfer.sol",
        "Source Code":"\/*\n * @source: https:\/\/consensys.github.io\/smart-contract-best-practices\/known_attacks\/#front-running-aka-transaction-ordering-dependence\n * @author: consensys\n * @vulnerable_at_lines: 18\n *\/\n\npragma solidity ^0.4.10;\n\ncontract IntegerOverflowAdd {\n    mapping (address => uint256) public balanceOf;\n\n    \/\/ INSECURE\n    function transfer(address _to, uint256 _value) public{\n        \/* Check if sender has balance *\/\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        \/\/ <yes> <report> ARITHMETIC\n        balanceOf[_to] += _value;\n}\n\n}",
        "input":"pragma solidity ^0.4.10;\n\ncontract IntegerOverflowAdd {\n    mapping (address => uint256) public balanceOf;\n\n    \n    function transfer(address _to, uint256 _value) public{\n        \n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        \n        balanceOf[_to] += _value;\n}\n\n}"
    },
    {
        "Vulnerability Type":"arithmetic",
        "File Name":"integer_overflow_benign_1.sol",
        "Source Code":"\/*\n * @source: https:\/\/github.com\/SmartContractSecurity\/SWC-registry\/blob\/master\/test_cases\/integer_overflow_and_underflow\/integer_overflow_benign_1.sol\n * @author: -\n * @vulnerable_at_lines: 17\n *\/\n\n\/\/Single transaction overflow\n\/\/Post-transaction effect: overflow never escapes function\n\npragma solidity ^0.4.19;\n\ncontract IntegerOverflowBenign1 {\n    uint public count = 1;\n\n    function run(uint256 input) public {\n        \/\/ <yes> <report> ARITHMETIC\n        uint res = count - input;\n    }\n}",
        "input":"pragma solidity ^0.4.19;\n\ncontract IntegerOverflowBenign1 {\n    uint public count = 1;\n\n    function run(uint256 input) public {\n        \n        uint res = count - input;\n    }\n}"
    },
    {
        "Vulnerability Type":"arithmetic",
        "File Name":"timelock.sol",
        "Source Code":"\/*\n * @source: https:\/\/github.com\/sigp\/solidity-security-blog\n * @author: -\n * @vulnerable_at_lines: 22\n *\/\n\n\/\/added pragma version\n pragma solidity ^0.4.10;\n \n contract TimeLock {\n\n     mapping(address => uint) public balances;\n     mapping(address => uint) public lockTime;\n\n     function deposit() public payable {\n         balances[msg.sender] += msg.value;\n         lockTime[msg.sender] = now + 1 weeks;\n     }\n\n     function increaseLockTime(uint _secondsToIncrease) public {\n         \/\/ <yes> <report> ARITHMETIC\n         lockTime[msg.sender] += _secondsToIncrease;\n     }\n\n     function withdraw() public {\n         require(balances[msg.sender] > 0);\n         require(now > lockTime[msg.sender]);\n         uint transferValue = balances[msg.sender];\n         balances[msg.sender] = 0;\n         msg.sender.transfer(transferValue);\n     }\n }",
        "input":"pragma solidity ^0.4.10;\n \n contract TimeLock {\n\n     mapping(address => uint) public balances;\n     mapping(address => uint) public lockTime;\n\n     function deposit() public payable {\n         balances[msg.sender] += msg.value;\n         lockTime[msg.sender] = now + 1 weeks;\n     }\n\n     function increaseLockTime(uint _secondsToIncrease) public {\n         \n         lockTime[msg.sender] += _secondsToIncrease;\n     }\n\n     function withdraw() public {\n         require(balances[msg.sender] > 0);\n         require(now > lockTime[msg.sender]);\n         uint transferValue = balances[msg.sender];\n         balances[msg.sender] = 0;\n         msg.sender.transfer(transferValue);\n     }\n }"
    },
    {
        "Vulnerability Type":"arithmetic",
        "File Name":"integer_overflow_1.sol",
        "Source Code":"\/*\n * @source: https:\/\/github.com\/trailofbits\/not-so-smart-contracts\/blob\/master\/integer_overflow\/integer_overflow_1.sol\n * @author: -\n * @vulnerable_at_lines: 14\n *\/\n\n pragma solidity ^0.4.15;\n\n contract Overflow {\n     uint private sellerBalance=0;\n\n     function add(uint value) returns (bool){\n         \/\/ <yes> <report> ARITHMETIC\n         sellerBalance += value; \/\/ possible overflow\n\n         \/\/ possible auditor assert\n         \/\/ assert(sellerBalance >= value);\n     }\n\n  \/\/ function safe_add(uint value) returns (bool){\n  \/\/   require(value + sellerBalance >= sellerBalance);\n  \/\/ sellerBalance += value;\n  \/\/ } \n }",
        "input":"pragma solidity ^0.4.15;\n\n contract Overflow {\n     uint private sellerBalance=0;\n\n     function add(uint value) returns (bool){\n         \n         sellerBalance += value; \n\n         \n         \n     }\n\n  \n  \n  \n  \n }"
    },
    {
        "Vulnerability Type":"arithmetic",
        "File Name":"integer_overflow_mapping_sym_1.sol",
        "Source Code":"\/*\n * @source: https:\/\/github.com\/SmartContractSecurity\/SWC-registry\/blob\/master\/test_cases\/integer_overflow_and_underflow\/integer_overflow_mapping_sym_1.sol\n * @author: -\n * @vulnerable_at_lines: 16\n *\/\n\n\/\/Single transaction overflow\n\npragma solidity ^0.4.11;\n\ncontract IntegerOverflowMappingSym1 {\n    mapping(uint256 => uint256) map;\n\n    function init(uint256 k, uint256 v) public {\n        \/\/ <yes> <report> ARITHMETIC\n        map[k] -= v;\n    }\n}",
        "input":"pragma solidity ^0.4.11;\n\ncontract IntegerOverflowMappingSym1 {\n    mapping(uint256 => uint256) map;\n\n    function init(uint256 k, uint256 v) public {\n        \n        map[k] -= v;\n    }\n}"
    },
    {
        "Vulnerability Type":"arithmetic",
        "File Name":"overflow_simple_add.sol",
        "Source Code":"\/*\n * @source: https:\/\/smartcontractsecurity.github.io\/SWC-registry\/docs\/SWC-101#overflow-simple-addsol\n * @author: -\n * @vulnerable_at_lines: 14\n *\/\n\npragma solidity 0.4.25;\n\ncontract Overflow_Add {\n    uint public balance = 1;\n\n    function add(uint256 deposit) public {\n        \/\/ <yes> <report> ARITHMETIC\n        balance += deposit;\n    }\n}",
        "input":"pragma solidity 0.4.25;\n\ncontract Overflow_Add {\n    uint public balance = 1;\n\n    function add(uint256 deposit) public {\n        \n        balance += deposit;\n    }\n}"
    },
    {
        "Vulnerability Type":"arithmetic",
        "File Name":"integer_overflow_mul.sol",
        "Source Code":"\/*\n * @source: https:\/\/github.com\/SmartContractSecurity\/SWC-registry\/blob\/master\/test_cases\/integer_overflow_and_underflow\/integer_overflow_mul.sol\n * @author: -\n * @vulnerable_at_lines: 17\n *\/\n\n\/\/Single transaction overflow\n\/\/Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.19;\n\ncontract IntegerOverflowMul {\n    uint public count = 2;\n\n    function run(uint256 input) public {\n        \/\/ <yes> <report> ARITHMETIC\n        count *= input;\n    }\n}",
        "input":"pragma solidity ^0.4.19;\n\ncontract IntegerOverflowMul {\n    uint public count = 2;\n\n    function run(uint256 input) public {\n        \n        count *= input;\n    }\n}"
    },
    {
        "Vulnerability Type":"arithmetic",
        "File Name":"tokensalechallenge.sol",
        "Source Code":"\/*\n * @source: https:\/\/smartcontractsecurity.github.io\/SWC-registry\/docs\/SWC-101 \/\/ https:\/\/capturetheether.com\/challenges\/math\/token-sale\/\n * @author: Steve Marx\n * @vulnerable_at_lines: 23,25,33\n *\/\n\npragma solidity ^0.4.21;\n\ncontract TokenSaleChallenge {\n    mapping(address => uint256) public balanceOf;\n    uint256 constant PRICE_PER_TOKEN = 1 ether;\n\n    function TokenSaleChallenge(address _player) public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance < 1 ether;\n    }\n\n    function buy(uint256 numTokens) public payable {\n        \/\/ <yes> <report> ARITHMETIC\n        require(msg.value == numTokens * PRICE_PER_TOKEN);\n        \/\/ <yes> <report> ARITHMETIC\n        balanceOf[msg.sender] += numTokens;\n    }\n\n    function sell(uint256 numTokens) public {\n        require(balanceOf[msg.sender] >= numTokens);\n\n        balanceOf[msg.sender] -= numTokens;\n        \/\/ <yes> <report> ARITHMETIC\n        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);\n    }\n}",
        "input":"pragma solidity ^0.4.21;\n\ncontract TokenSaleChallenge {\n    mapping(address => uint256) public balanceOf;\n    uint256 constant PRICE_PER_TOKEN = 1 ether;\n\n    function TokenSaleChallenge(address _player) public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance < 1 ether;\n    }\n\n    function buy(uint256 numTokens) public payable {\n        \n        require(msg.value == numTokens * PRICE_PER_TOKEN);\n        \n        balanceOf[msg.sender] += numTokens;\n    }\n\n    function sell(uint256 numTokens) public {\n        require(balanceOf[msg.sender] >= numTokens);\n\n        balanceOf[msg.sender] -= numTokens;\n        \n        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);\n    }\n}"
    },
    {
        "Vulnerability Type":"arithmetic",
        "File Name":"integer_overflow_multitx_multifunc_feasible.sol",
        "Source Code":"\/*\n * @source: https:\/\/github.com\/ConsenSys\/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 25\n *\/\n\n\/\/Multi-transactional, multi-function\n\/\/Arithmetic instruction reachable\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowMultiTxMultiFuncFeasible {\n    uint256 private initialized = 0;\n    uint256 public count = 1;\n\n    function init() public {\n        initialized = 1;\n    }\n\n    function run(uint256 input) {\n        if (initialized == 0) {\n            return;\n        }\n        \/\/ <yes> <report> ARITHMETIC\n        count -= input;\n    }\n}",
        "input":"pragma solidity ^0.4.23;\n\ncontract IntegerOverflowMultiTxMultiFuncFeasible {\n    uint256 private initialized = 0;\n    uint256 public count = 1;\n\n    function init() public {\n        initialized = 1;\n    }\n\n    function run(uint256 input) {\n        if (initialized == 0) {\n            return;\n        }\n        \n        count -= input;\n    }\n}"
    },
    {
        "Vulnerability Type":"arithmetic",
        "File Name":"BECToken.sol",
        "Source Code":"\/*\n * @source: https:\/\/smartcontractsecurity.github.io\/SWC-registry\/docs\/SWC-101#bectokensol\n * @author: -\n * @vulnerable_at_lines: 264\n *\/\n\npragma solidity ^0.4.16;\n\n\/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n *\/\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a * b;\n    require(a == 0 || c \/ a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n    \/\/ require(b > 0); \/\/ Solidity automatically throws when dividing by 0\n    uint256 c = a \/ b;\n    \/\/ require(a == b * c + a % b); \/\/ There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n    require(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n    return c;\n  }\n}\n\n\/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/179\n *\/\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) public constant returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n\/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n *\/\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  \/**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  *\/\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value > 0 && _value <= balances[msg.sender]);\n\n    \/\/ SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  \/**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  *\/\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n}\n\n\/**\n * @title ERC20 interface\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\n *\/\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public constant returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https:\/\/github.com\/ethereum\/EIPs\/issues\/20\n * @dev Based on code by FirstBlood: https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\n *\/\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  \/**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   *\/\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value > 0 && _value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  \/**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   *\/\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  \/**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   *\/\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n}\n\n\/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n *\/\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  \/**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   *\/\n  function Ownable() {\n    owner = msg.sender;\n  }\n\n\n  \/**\n   * @dev Throws if called by any account other than the owner.\n   *\/\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n\n  \/**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   *\/\n  function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n\/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n *\/\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  \/**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   *\/\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  \/**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   *\/\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  \/**\n   * @dev called by the owner to pause, triggers stopped state\n   *\/\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    Pause();\n  }\n\n  \/**\n   * @dev called by the owner to unpause, returns to normal state\n   *\/\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    Unpause();\n  }\n}\n\n\/**\n * @title Pausable token\n *\n * @dev StandardToken modified with pausable transfers.\n **\/\n\ncontract PausableToken is StandardToken, Pausable {\n\n  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n    return super.transfer(_to, _value);\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n    return super.transferFrom(_from, _to, _value);\n  }\n\n  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n    return super.approve(_spender, _value);\n  }\n\n  function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {\n    uint cnt = _receivers.length;\n    \/\/ <yes> <report> ARITHMETIC\n    uint256 amount = uint256(cnt) * _value;\n    require(cnt > 0 && cnt <= 20);\n    require(_value > 0 && balances[msg.sender] >= amount);\n\n    balances[msg.sender] = balances[msg.sender].sub(amount);\n    for (uint i = 0; i < cnt; i++) {\n        balances[_receivers[i]] = balances[_receivers[i]].add(_value);\n        Transfer(msg.sender, _receivers[i], _value);\n    }\n    return true;\n  }\n}\n\n\/**\n * @title Bec Token\n *\n * @dev Implementation of Bec Token based on the basic standard token.\n *\/\ncontract BecToken is PausableToken {\n    \/**\n    * Public variables of the token\n    * The following variables are OPTIONAL vanities. One does not have to include them.\n    * They allow one to customise the token contract & in no way influences the core functionality.\n    * Some wallets\/interfaces might not even bother to look at this information.\n    *\/\n    string public name = \"BeautyChain\";\n    string public symbol = \"BEC\";\n    string public version = '1.0.0';\n    uint8 public decimals = 18;\n\n    \/**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     *\/\n    function BecToken() {\n      totalSupply = 7000000000 * (10**(uint256(decimals)));\n      balances[msg.sender] = totalSupply;    \/\/ Give the creator all initial tokens\n    }\n\n    function () {\n        \/\/if ether is sent to this address, send it back.\n        revert();\n    }\n}",
        "input":"pragma solidity ^0.4.16;\n\n\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a * b;\n    require(a == 0 || c \/ a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n    \n    uint256 c = a \/ b;\n    \n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n    require(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n    return c;\n  }\n}\n\n\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) public constant returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  \n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value > 0 && _value <= balances[msg.sender]);\n\n    \n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  \n  function balanceOf(address _owner) public constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n}\n\n\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public constant returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  \n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value > 0 && _value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  \n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  \n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n}\n\n\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  \n  function Ownable() {\n    owner = msg.sender;\n  }\n\n\n  \n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n\n  \n  function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  \n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  \n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  \n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    Pause();\n  }\n\n  \n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    Unpause();\n  }\n}\n\n\n\ncontract PausableToken is StandardToken, Pausable {\n\n  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n    return super.transfer(_to, _value);\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n    return super.transferFrom(_from, _to, _value);\n  }\n\n  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n    return super.approve(_spender, _value);\n  }\n\n  function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {\n    uint cnt = _receivers.length;\n    \n    uint256 amount = uint256(cnt) * _value;\n    require(cnt > 0 && cnt <= 20);\n    require(_value > 0 && balances[msg.sender] >= amount);\n\n    balances[msg.sender] = balances[msg.sender].sub(amount);\n    for (uint i = 0; i < cnt; i++) {\n        balances[_receivers[i]] = balances[_receivers[i]].add(_value);\n        Transfer(msg.sender, _receivers[i], _value);\n    }\n    return true;\n  }\n}\n\n\ncontract BecToken is PausableToken {\n    \n    string public name = \"BeautyChain\";\n    string public symbol = \"BEC\";\n    string public version = '1.0.0';\n    uint8 public decimals = 18;\n\n    \n    function BecToken() {\n      totalSupply = 7000000000 * (10**(uint256(decimals)));\n      balances[msg.sender] = totalSupply;    \n    }\n\n    function () {\n        \n        revert();\n    }\n}"
    },
    {
        "Vulnerability Type":"arithmetic",
        "File Name":"integer_overflow_multitx_onefunc_feasible.sol",
        "Source Code":"\/*\n * @source: https:\/\/github.com\/ConsenSys\/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 22\n *\/\n\n\/\/Multi-transactional, single function\n\/\/Arithmetic instruction reachable\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowMultiTxOneFuncFeasible {\n    uint256 private initialized = 0;\n    uint256 public count = 1;\n\n    function run(uint256 input) public {\n        if (initialized == 0) {\n            initialized = 1;\n            return;\n        }\n        \/\/ <yes> <report> ARITHMETIC\n        count -= input;\n    }\n}",
        "input":"pragma solidity ^0.4.23;\n\ncontract IntegerOverflowMultiTxOneFuncFeasible {\n    uint256 private initialized = 0;\n    uint256 public count = 1;\n\n    function run(uint256 input) public {\n        if (initialized == 0) {\n            initialized = 1;\n            return;\n        }\n        \n        count -= input;\n    }\n}"
    }
]